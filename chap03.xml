<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
"http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd"
[
<!ENTITY BASEID "djangobook.chap03">
]>

<chapter lang="ru" id="&BASEID;">

  <title id="&BASEID;.title">
    Основы динамических страниц
  </title>

  <para>
    Данная глава временно взята из первой версии книги и подлежит
    корректировке. Вы можете помочь с этим!
  </para>

  <para>
    Перевод &copy; Попов Руслан &lt;radz &bull; yandex &bull; ru&gt;
  </para>

  <para>
    В предыдущей главе мы объяснили как настроить проект и запустить
    сервер разработки. Конечно, этот сайт пока не делает ничего
    действительно полезного. Всё что он делает &mdash; отображает
    сообщение <quote>It worked!"</quote>. Давайте изменим это. Данная
    глава рассказывает как создавать динамические страницы с помощью
    Django.
  </para>

  <section id="&BASEID;.firstview">

    <title id="&BASEID;.firstview.title">
      Ваше первое представление: Динамическое содержимое
    </title>
    
    <para>
      В качестве первой задачи, давайте создадим страницу, которая
      отображает текущее время и дату. Это хороший пример
      <emphasis>динамической</emphasis> страницы, так как содержимое
      страницы нестатично. Вместо этого, содержимое страницы
      изменяется в соответствии с результатами вычисления (в данном
      случае, вычисление текущего времени). Этот простой пример не
      требует наличия базы данных или ввода данных от пользователя
      &mdash; просто выводит значение времени из часов вашего сервера.
    </para>

    <para>
      Для создания такой страницы мы напишем <emphasis>функцию
      представления</emphasis>. Функция представления, или просто
      <emphasis>представление</emphasis>, является простой функцией на
      языке Python, которая принимает запрос и возвращает отклик. Этот
      отклик может быть содержимым страницы в виде HTML,
      перенаправлением на другую страницу, ошибкой 404, XML документом
      или изображением, да вообще чем угодно. Само представление
      содержит логику необходимую для возврата отклика. Этот код может
      располагаться где угодно, главное чтобы каталог был в пути
      Python. Больше нет никаких требований, так сказать
      <quote>никакой магии</quote>. Для размещения кода, давайте
      создадим файл с именем <filename>views.py</filename> в каталоге
      <filename>mysite</filename>, который мы создали в предыдущей
      главе.
    </para>

    <para>
      Ниже приведено представление, которое возвращает текущее время и
      дату в виде HTML документа:
      <screen>
	<![CDATA[
from django.http import HttpResponse
import datetime

def current_datetime(request):
    now = datetime.datetime.now()
    html = "<html><body>It is now %s.</body></html>" % now
    return HttpResponse(html)
	]]>
      </screen>
    </para>

    <para>
      Пройдёмся по коду, разбираясь с каждой строчкой отдельно:
      <itemizedlist>
	<listitem><para>Сначала мы импортируем класс
	<classname>HttpResponse</classname>, который определён в
	модуле <token>django.http</token>. Обратитесь к приложению
	<quote><xref linkend="djangobook.appendix_h"
	endterm="djangobook.appendix_h.title"/></quote> для
	подробностей по объектам <classname>HttpRequest</classname> и
	<classname>HttpResponse</classname>.</para></listitem>

	<listitem><para>Затем мы импортируем модуль
	<token>datetime</token> из стандартной библиотеки Python,
	набора полезных модулей поставляемых вместе с
	интерпретатором. Модуль <token>datetime</token> содержит
	несколько функций и классов для работы с датой и временем,
	включая функцию, которая возвращает текущее
	время.</para></listitem>

	<listitem>
	  <para>
	    Далее мы определяем функцию
	    <function>current_datetime</function>. Это функция
	    представления. Каждая функция представления принимает
	    <classname>HttpRequest</classname> объект в качестве
	    первого параметра, который обычно называют
	    <varname>request</varname>.
	  </para>
	  
	  <para>
	    Следует отметить, что имя функции представления не имеет
	    значения. Не требуется соблюдать какой-то особый стандарт
	    для того, чтобы Django могла распознать эту функцию. Здесь
	    мы назвали её <function>current_datetime</function>,
	    потому что это имя явно определяет то, для чего
	    предназначена данная функция. Но мы могли бы назвать её
	    как <function>super_duper_awesome_current_time</function>
	    или как-нибудь ещё. Django не обращает на это внимание. В
	    следующей главе мы объясним как Django находит эту
	    функцию.
	  </para>
	</listitem>

	<listitem><para>Первая строка кода внутри функции вычисляет
	текущую дату/время в виде объекта
	<token>datetime.datetime</token> и сохраняет его в виде
	локальной переменной <varname>now</varname>.</para></listitem>

	<listitem><para>Вторая строка кода внутри функции создаёт HTML
	отклик с помощью возможностей Python по форматированию
	строк. Символы <token>%s</token> в строке являются точкой
	подстановки, а символ <token>%</token> в конце строки означает
	<quote>замени <token>%s</token> на значение переменной
	<varname>now</varname>.</quote> (Да, HTML не совсем
	корректный, но мы стараемся сохранять простоту в
	примере.)</para></listitem>

	<listitem><para>Наконец, представление возвращает
	<classname>HttpResponse</classname> объект, который содержит
	сгенерированный результат. Каждая функция представления должна
	возвращать <classname>HttpResponse</classname> объект. (Есть
	исключения из этого правила, но об этом
	позже.)</para></listitem>
      </itemizedlist>
    </para>

    <para>
      <note>
	<title>
	  Временная зона для Django
	</title>
	<para>
	  По умолчанию настройка <constant>TIME_ZONE</constant>
	  установлена в значение
	  <token>America/Chicago</token>. Вероятно, вы там не живёте,
	  так что измените это значение на правильное в вашем файле
	  <filename>settings.py</filename>. Обратитесь к приложению
	  <quote><xref linkend="djangobook.appendix_e"
	  endterm="djangobook.appendix_e.title"/></quote> для
	  подробностей.
	</para>
      </note>
    </para>

  </section>

  <section id="&BASEID;.urlmap">

    <title id="&BASEID;.urlmap.title">
      Схема URL
    </title>
    
    <para>
      Напомним, что функция представления возвращает HTML страницу,
      которая содержит текущее значение даты и времени. Но как же нам
      указать Django, что следует использовать этот код? Вот для этого
      и нужна <emphasis>схема URL</emphasis>.
    </para>

    <para>
      <emphasis>Схема URL</emphasis> описывает содержание вашего
      сайта. Таким образом, при вызове определённого URL, происходит
      поиск соответствующего шаблона в схеме, как только он будет
      найден происходит вызов соответствующей функции
      представления. Вот так Django и понимает, что именно надо
      вызывать. Следует помнить, что функции представления должны
      находиться в пути Python.
    </para>

    <para>
      <note>
	<title>
	  Ваш путь для Python
	</title>

	<para>
	  Путь для Python является списком каталогов вашей системы,
	  где интерпретатор Python производит поиск модулей в момент
	  когда вы используете оператор <token>import</token>.
	</para>

	<para>
	  Например, допустим, что путь имеет следующее значение:
	  <screen>
['', '/usr/lib/python2.4/site-packages', '/home/username/djcode/']
	  </screen>
	  При выполнении кода:
	  <screen>
from foo import bar
	  </screen>
	  интерпретатор сначала проверит наличие файла
	  <filename>foo.py</filename> в текущем каталоге. (Первым
	  элементом списка идёт пустая строка, которая означает
	  <quote>текущий каталог</quote>.) Если такого файла там нет,
	  то интерпретатор ищет файл в каталоге
	  <filename>/usr/lib/python2.4/site-packages</filename>, затем
	  в каталоге
	  <filename>/home/username/djcode/</filename>. Наконец, если
	  файл всё ещё не найден, интерпретатор возвращает
	  <token>ImportError</token>.
	</para>

	<para>
	  Если вам интересно посмотреть на значения пути, запустите
	  интерпретатор и выполните следующие команды:
	  <screen>
&gt;&gt;&gt; import sys
&gt;&gt;&gt; print sys.path
	  </screen>
	</para>

	<para>
	  В общем случае вам не требуется беспокоиться о настройке
	  пути. Это задача Python и Django, они сами об этом
	  позаботятся. (Настройка пути, это одна из задач, которыми
	  занимается скрипт <filename>manage.py</filename>.)
	</para>
      </note>
    </para>

    <para>
      Когда вы выполняли команду <command>django-admin.py
      startproject</command> в прошлой главе, скрипт создал схему URL
      автоматически &mdash; файл <filename>urls.py</filename>. Давайте
      внесём в него изменения. По умолчанию, содержимое файла таково:
      <screen>
from django.conf.urls.defaults import *

urlpatterns = patterns('',
    # Example:
    # (r'^mysite/', include('mysite.apps.foo.urls.foo')),

    # Uncomment this for admin:
#     (r'^admin/', include('django.contrib.admin.urls')),
)
      </screen>
    </para>

    <para>
      Пройдёмся по коду, разбираясь с каждой строчкой отдельно:
      <itemizedlist>
	<listitem><para>Первая строка импортирует все объекты из
	модуля <token>django.conf.urls.defaults</token>, включая
	функцию с именем
	<function>patterns</function>.</para></listitem>

	<listitem><para>Вторая строка вызывает функцию
	<function>patterns()</function> и сохраняет результат в
	переменную <varname>urlpatterns</varname>. Функция
	<function>patterns()</function> получает только один аргумент
	&mdash; пустую строку. Остальные аргументы
	закомментированы. (Эта пустая строка может быть использована
	для определения общего префикса для функций представления, но
	пока мы пропустим эту возможность.)</para></listitem>
      </itemizedlist>
    </para>

    <para>
      Главной особенностью, которую следует отметить, является
      переменная <varname>urlpatterns</varname>. Django ищет её в
      вашем главном модуле схемы URL. Эта переменная определяет
      соответствие между URL и кодом, который обрабатывает запрос.
    </para>

    <para>
      По умолчанию, всё в определении схемы URL закомментировано. Ваше
      приложение находится в начальном состоянии. (Именно это
      указывает Django, что надо отобразить страницу <quote>It
      worked!</quote>, как описывалось в предыдущей главе. Если схема
      URL пуста, Django предполагает. что вы начали новый проект и,
      соответственно, отображает это сообщение.)
    </para>

    <para>
      Надо внести изменения в этот файл для назначения нашего
      представления <token>current_datetime</token>:
      <screen>
from django.conf.urls.defaults import *
from mysite.views import current_datetime

urlpatterns = patterns('',
    (r'^time/$', current_datetime),
)
      </screen>
    </para>

    <para>
      Мы внесли два изменения. Первое, мы произвели импорт
      представления <token>current_datetime</token> из его модуля
      (<filename>mysite/views.py</filename>, имя файла преобразовалось
      в <token>mysite.views</token> в синтаксисе импорта
      Python). Затем, мы добавили строку:
      <screen>
(r'^time/$', current_datetime),
      </screen>
      Эта строка называется <emphasis>шаблоном URL</emphasis>. Это
      пример питоновского кортежа (группа взаимосвязанных элементов
      данных или записей), в котором первый элемент является простым
      регулярным выражением, а второй элемент &mdash; функция
      представления предназначенная для этого шаблона.
    </para>

    <para>
      В действительности, мы просто указываем Django, что любой запрос
      по URL <token>/time/</token> должен быть обработан функцией
      представления <function>current_datetime</function>.
    </para>

    <para>
      Несколько моментов надо отметить:
      <itemizedlist>
	<listitem>
	  <para>
	    В данном примере мы передаём функцию
	    <function>current_datetime</function> как объект, без
	    вызова самой функции. Это ключевая особенность Python (и
	    других динамических языков): функции как объекты первого
	    рода, т.е. вы можете передать их в качестве параметров как
	    обычные переменные. Прикольно, да?
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Символ <token>r</token> в <token>r'^time/$'</token>
	    означает, что <token>'^time/$'</token> является
	    <quote>сырой</quote> строкой. Это позволяет писать
	    регулярные выражения, не заморачиваясь особо
	    экранированием спецсимволов.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Вы должны исключить очевидный слэш в начале
	    <token>'^time/$'</token> для совпадения с
	    <token>/time/</token>. Django автоматически добавляет слэш
	    перед каждым выражением. На первый взгляд это может
	    показаться странным, но так как текущая схема URL может
	    быть включена в другую схему, отсутствие этого слэша
	    упрощает этот процесс. Более подробно об этом будет
	    рассказано в главе <quote><xref
	    linkend="djangobook.chap08"
	    endterm="djangobook.chap08.title"/></quote>.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Символы <token>^</token> и <token>$</token> имеют особое
	    значение. Символ <token>^</token> означает
	    <quote>требуется, чтобы шаблон начинался с начала
	    строки</quote>, а <token>$</token> &mdash;
	    <quote>требуется, чтобы шаблон продолжался до конца
	    строки</quote>.
	  </para>

	  <para>
	    Эта концепция лучше понимается на примере. Если мы
	    рассмотрим шаблон <token>'^time/'</token> (без символа
	    <token>$</token> в конце), то <emphasis>любой</emphasis>
	    URL, который начинается с <token>time/</token> будет
	    соответствовать, такие как <token>time/foo</token>,
	    <token>time/bar</token>, а не только
	    <token>time/</token>. Аналогично, если мы опустим первый
	    символ <token>^</token> (<token>'time/$'</token>), Django
	    примет <emphasis>любой</emphasis> URL, который
	    заканчивается на <token>time/</token>, например,
	    <token>/foo/bar/time/</token>. Таким образом, необходимо
	    использовать оба символа <token>^</token> и
	    <token>$</token>, для точного определения URL. В
	    регулярных выражениях нет ничего лишнего.
	  </para>

	  <para>
	    Вам может быть интересно, что происходит когда кто-нибудь
	    переходит на URL <token>/time</token>. Переход на этот URL
	    обрабатывается так как вы ожидали (через перенаправление),
	    до тех пор пока <varname>APPEND_SLASH</varname> установлен
	    в <token>True</token>. (Обратитесь к приложению
	    <quote><xref linkend="djangobook.appendix_e"
	    endterm="djangobook.appendix_e.title"/></quote> для
	    подробностей.)
	  </para>
	</listitem>
      </itemizedlist>
    </para>

    <para>
      Для проверки внесённых нами изменений надо запустить сервер
      разработки Django, как это было описано в <quote><xref
      linkend="djangobook.chap02.running-devserver"
      endterm="djangobook.chap02.running-devserver.title"/></quote>, с помощью
      команды <command>python manage.py runserver</command>. (Если вы
      его не останавливали, что ж, это прекрасно. Сервер разработки
      автоматически определит наличие изменений в вашем коде и
      подгрузит обновлённые модули. Таким образом, нет необходимости
      перезапускать вручную сервер разработки.) Сервер работает на
      <ulink url="http://127.0.0.1:8000/time/"/>, откройте эту ссылку
      в браузере. Вы должны увидеть вывод вашего представления.
    </para>

    <para>
      Урррааа! Вы создали свою первую страницу с помощью Django.
    </para>

    <para>
      <note>
	<title>
	  Регулярные выражения
	</title>
	<para>
	  <emphasis>Регулярные выражения</emphasis><footnote><para>Для
	  информации по регулярным выражениям обращайтесь на <ulink
	  url="http://www.djangoproject.com/r/python/re-module/"/> и
	  на <ulink
	  url="http://docs.python.org/lib/re-syntax.html"/>.</para></footnote>
	  &mdash; компактный метод определения шаблонов в тексте. В то
	  время как схема URL Django позволяет использование
	  определённых регулярных выражений для работы с URL, вероятно
	  на практике вы будете использовать не так много регулярных
	  выражений для шаблонов. В таблице <quote><xref
	  linkend="&BASEID;.tbl1"
	  endterm="&BASEID;.tbl1.title"/></quote> приведена выборка
	  наиболее используемых шаблонов.
	</para>
      </note>
    </para>

    <para>
      <table id="&BASEID;.tbl1" frame="all" pgwide="1">

	<title id="&BASEID;.tbl1.title">
	  Выборка наиболее используемых шаблонов
	</title>

	<tgroup cols="2" align="left" colsep="1" rowsep="1">

	  <colspec colname="c1" colwidth="2cm"/>
	  <colspec colname="c2" colwidth="12cm"/>

	  <thead>
	    <row>
	      <entry>Символ</entry>
	      <entry>Совпадает</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry><token>.</token> (точка)</entry>
	      <entry>Любой символ</entry>
	    </row>

	    <row>
	      <entry><token>\d</token></entry>
	      <entry>Любая цифра</entry>
	    </row>

	    <row>
	      <entry><token>[A-Z]</token></entry>
	      <entry>Любая буква (верхний регистр)</entry>
	    </row>

	    <row>
	      <entry><token>[a-z]</token></entry>
	      <entry>Любая буква (нижний регистр)</entry>
	    </row>

	    <row>
	      <entry><token>[A-Za-z]</token></entry>
	      <entry>Любая буква (любой регистр)</entry>
	    </row>

	    <row>
	      <entry><token>+</token></entry>
	      <entry>Один или более символов предыдущего
	      выражения, т.е. <token>\d+</token> совпадает с одной
	      или более цифрами</entry>
	    </row>

	    <row>
	      <entry><token>[^/]+</token></entry>
	      <entry>Все символы подряд, кроме слэша</entry>
	    </row>

	    <row>
	      <entry><token>?</token></entry>
	      <entry>Наличие или отсутствие предыдущего выражения,
	      т.е. <token>\d?</token> описывает возможное наличие
	      одной цифры</entry>
	    </row>

	    <row>
	      <entry><token>{1, 3}</token></entry>
	      <entry>Между одним или тремя (включая) предыдущими
	      выражениями</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>
    </para>

  </section>

  <section id="&BASEID;.requestprocess">

    <title id="&BASEID;.requestprocess.title">
      Как Django обрабатывает запрос
    </title>
    
    <para>
      Мы должны отметить несколько моментов о том как это
      происходит. Далее описана нудная работа, которая происходит
      после того как вы запустите сервер разработки Django и выполните
      запрос к странице:
      <itemizedlist>
	<listitem>
	  <para>
	    Команда <command>python manage.py runserver</command>
	    импортирует файл с именем <filename>settings.py</filename>
	    из того же каталога. Этот файл содержит все виды
	    необязательных параметров конфигурации для этого
	    экземпляра Django, но одним из наиболее важных параметров
	    является <token>ROOT_URLCONF</token>. Этот параметр
	    указывает Django какой модуль на языке Python должен быть
	    использован в качестве файла со схемой URL для этого
	    сайта.
	  </para>

	  <para>
	    Помните, что команда <command>django-admin.py
	    startproject</command> создала файлы
	    <filename>settings.py</filename> и
	    <filename>urls.py</filename>? Хорошо, созданный
	    автоматически файл <filename>settings.py</filename>
	    содержит параметр <token>ROOT_URLCONF</token>, который
	    указывает на автоматически созданный файл
	    <filename>urls.py</filename>. Удобно.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    При выполнении запроса, скажем по URL
	    <token>/time/</token>, Django загружает файл со схемой URL
	    на который указывает параметр
	    <token>ROOT_URLCONF</token>. Затем он проверяет каждый
	    шаблон в схеме по порядку, сравнивая запрошенный URL с
	    шаблонами по очереди, пока не найдёт совпадение. Если
	    совпадение найдено, Django вызывает функцию представления,
	    связанную с этим шаблоном, передавая объект
	    <classname>HttpRequest</classname> в качестве первого
	    параметра функции. (Подробности о
	    <classname>HttpRequest</classname> далее.)
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Функция представления должна возвратить
	    <classname>HttpResponse</classname> объект.
	  </para>
	</listitem>
      </itemizedlist>
    </para>

    <para>
      Теперь вы знаете основы работы страниц, созданных с помощью
      Django. Это достаточно просто, просто создайте функции
      представления и опишите их в схеме URL. Вы можете подумать, что
      использование для этого регулярных выражений должно сказаться на
      производительности, но вы будете удивлены.
    </para>

    <section id="&BASEID;.requestprocess.complete">

      <title id="&BASEID;.requestprocess.complete.title">
	Подробности
      </title>
    
      <para>
	В дополнение к только что описанной прямолинейной методике
	связывания функции представления и URL, Django достаточно
	гибок при обработке запросов.
      </para>

      <para>
	Обычный алгоритм работы &mdash; запрос к странице приводит к
	вызову её функции представления, которая возвращает объект
	<classname>HttpResponse</classname> &mdash; может быть упрощен
	или расширен с помощью промежуточного ПО. Страшные секреты
	промежуточного ПО будут полностью разобраны в главе
	<quote><xref linkend="djangobook.chap15"
	endterm="djangobook.chap15.title"/></quote>, но простая схема
	должна помочь вам понять общую концепцию.
      </para>
      
      <para>
	<figure id="&BASEID;.pic1" float="0">
	  <title id="&BASEID;.pic1.title">
	    Полный алгоритм обработки Django
	  </title>
	  <screenshot>
	    <mediaobject>
	      <imageobject>
		<imagedata fileref="pics/get_response.png" format="PNG"/>
	      </imageobject>
	    </mediaobject>
	  </screenshot>
	</figure>
      </para>

      <para>
	Когда HTTP запрос поступает от браузера,
	<emphasis>обработчик</emphasis> на стороне сервера создаёт
	объект <classname>HttpRequest</classname>, который затем
	передаётся дальше и обрабатывается для выдачи отклика.
      </para>

      <para>
	Обработчик вызывает любой доступный код отклика или
	представления. Эти виды кода полезны для расширения
	поступающих объектов <classname>HttpRequest</classname>,
	предоставляя особую обработку для специфических типов
	запросов. Каждый объект <classname>HttpResponse</classname>
	обрабатывается представлением.
      </para>

      <para>
	Ошибки допускают даже самые лучшие разработчики, но
	обработчики исключений могут помочь в их отлове. Если функция
	представления вызывает исключение, управление передаётся коду
	обработки исключения. Если этот код не возвращает объект
	<classname>HttpResponse</classname>, исключение вызывается
	снова.
      </para>

      <para>
	Но даже в этом случае, не всё потеряно. Django содержит
	стандартные представления, которые обрабатывают ошибки 404 и
	500.
      </para>

      <para>
	Наконец, <emphasis>обработчик отклика</emphasis> полезен для
	пост-обработки объекта <classname>HttpResponse</classname>
	перед отправкой его браузеру или для очистки ресурсов.
      </para>
      
    </section>
	
  </section>

  <section id="&BASEID;.loosecoupling">

    <title id="&BASEID;.loosecoupling.title">
      Схема URL и свободное связывание
    </title>
    
    <para>
      Пришло время рассказать о ключевом аспекте скрытом в схеме URL:
      о принципе <emphasis>свободного связывания</emphasis>. Просто
      предположим, свободное связывание &mdash; подход в разработке
      программного обеспечения, который оценивает важность создания
      взаимозаменяемых частей. В случае когда два куска кода свободно
      связаны, изменение кода в одном куске будет иметь несущественное
      влияние или не иметь его вовсе на второй кусок.
    </para>

    <para>
      Схема URL является хорошим практическим примером данного
      принципа. В приложении на Django определения URL и функцию
      представления называют свободно связанными, т.к., решение о том,
      для какого URL должна вызываться данная функция и реализация
      этой функции разнесены в два отдельных места. Такой подход
      позволяет разработчику изменять одно место, не влияя на другое.
    </para>

    <para>
      В отличие от этого, на других платформах разработки, URL
      привязаны к программе. В обычных <ulink
      url="http://www.php.net/">PHP</ulink> приложениях, URL вашего
      приложения определяется тем, где вы разместили код на файловой
      системе. В ранних версиях <ulink
      url="http://www.cherrypy.org/">CherryPy</ulink> среды разработки
      на языке Python, URL приложения зависел от имени метода, в
      котором был размещён код. Такой подход может казаться удобным,
      но он мешает управлению приложением при длительных сроках его
      эксплуатации.
    </para>

    <para>
      Рассмотрим функцию представления, созданную нами ранее, которая
      отображает текущую дату и время. Если нам потребуется изменить
      URL приложения &mdash; скажем с <token>/time/</token> на
      <token>/currenttime/</token> &mdash; мы можем быстро внести
      изменения в схему URL, не трогая саму функцию. Аналогично, если
      нам потребуется внести изменения в функцию представления &mdash;
      как-то изменить её логику &mdash; мы можем сделать это, не влияя
      на URL. Более того, если нам потребуется разделить
      функциональность вывода времени на несколько URL, мы можем легко
      это реализовать на уровне схемы URL, не трогая код функции
      представления.
    </para>

    <para>
      Вот, что такое свободное связывание. Мы продолжим показывать
      примеры этой важной философии далее по книге.
    </para>

  </section>      

  <section id="&BASEID;.404errors">

    <title id="&BASEID;.404errors.title">
      Ошибки 404
    </title>
    
    <para>
      В нашем файле схемы URL к настоящему времени мы определили
      только один шаблон URL: тот, который обрабатывает запросы к
      <token>/time/</token>. Что произойдёт, когда будет вызван другой
      URL?
    </para>

    <para>
      Чтобы ответить на этот вопрос, попытаемся запустить сервер
      разработки Django и перейдём на страницу <ulink
      url="http://127.0.0.1:8000/hello/"/> или <ulink
      url="http://127.0.0.1:8000/does-not-exist/"/> или даже на <ulink
      url="http://127.0.0.1:8000/"/> (в корень сайта). Вы должны
      увидеть сообщение <quote>Page not found</quote>. (Красиво, не
      так ли?  Мы думаем вам понравятся наши пастельные цвета.) Django
      отображает это сообщение, так как для запрашиваемого вами URL
      нет определения в схеме URL.
    </para>

    <para>
      <figure id="&BASEID;.pic2" float="0">
	<title id="&BASEID;.pic2.title">
	  Страница 404 от Django
	</title>
	<screenshot>
	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="pics/404.png" format="PNG"/>
	    </imageobject>
	  </mediaobject>
	</screenshot>
      </figure>
    </para>

    <para>
      Польза от этой страницы не ограничивается простым сообщением об
      ошибке 404, оно также отображает текущую схему URL. По этой
      информации вы можете понять, почему запрашиваемый URL вызвал
      ошибку 404.
    </para>

    <para>
      На самом деле, эта информация предназначена только для вас, для
      разработчика. Если же это происходит на реальном сайте, который
      выставлен в Интернет, вы не должны выдавать подобную информацию
      наружу. По этой причине, страница <quote>Page not found</quote>
      отображается только когда включен режим отладки в Django. Мы
      объясним позже как можно отключить режим отладки. Сейчас надо
      запомнить, что после создания проекта по умолчанию он работает в
      режиме отладки. Как только режим отладки отключен, вы увидите
      другой ответ на неверный URL.
    </para>

  </section>    
      
  <section id="&BASEID;.dynurls">

    <title id="&BASEID;.dynurls.title">
      Ваше второе представление: Динамические URL
    </title>
    
    <para>
      В нашем первом примере, содержимое страницы &mdash; текущая дата
      и время &mdash; были динамическими. Но ссылка для этой страницы
      (<token>/time/</token>) была статической. В большинстве же
      динамических приложений URL содержит параметры, которые влияют
      на выводимую страницу.
    </para>

    <para>
      Создадим второе представление, которое отображает текущую дату и
      время со смещением на определённое количество часов. Цель
      состоит в том, чтобы изменить код сайта так, чтобы страница
      <token>/time/plus/1/</token> отображала дату и время на один час
      вперёд, страница <token>/time/plus/2/</token> отображала дату и
      время на два часа вперёд, страница <token>/time/plus/3/</token>
      отображала дату и время на три часа вперёд и так далее.
    </para>

    <para>
      Новичок может предположить, что надо написать отдельную функцию
      представления для каждого смещения времени, что может выглядеть
      так:
      <screen>
urlpatterns = patterns('',
    (r'^time/$', current_datetime),
    (r'^time/plus/1/$', one_hour_ahead),
    (r'^time/plus/2/$', two_hours_ahead),
    (r'^time/plus/3/$', three_hours_ahead),
    (r'^time/plus/4/$', four_hours_ahead),
)
      </screen>
    </para>

    <para>
      Очевидно, что такой подход неверен. Это приведёт не только к
      появлению повторяющихся представлений, но также приложение будет
      жёстко ограничено в диапазоне поддерживаемых смещений по времени
      &mdash; один, два, три или четыре часа. Если неожиданно нам
      потребуется создать страницу, которая отображает время сдвинутое
      на <emphasis>пять</emphasis> часов вперёд, нам снова потребуется
      отдельное представление и дополнительный шаблон в схеме URL, и
      так далее. Давайте, порассуждаем.
    </para>

    <section id="&BASEID;.prettyurls">

      <title id="&BASEID;.prettyurls.title">
	Слово о красивых URL
      </title>
    
      <para>
	Если у вас есть опыт работы с другими платформами разработки
	для веб, такими как PHP или Java, вы можете подумать:
	<quote>Эй, давай использовать параметр строки
	запроса!</quote>, что-то подобное
	<token>/time/plus?hours=3</token>, в котором часы будут
	назначаться параметру <varname>hours</varname> в строке
	запроса URL (часть после символа <token>?</token>).
      </para>

      <para>
	Вы <emphasis>можете</emphasis> сделать такое с помощью Django
	(и мы позже расскажем об этом, если вы действительно желаете
	это знать), но основная философия нашей среды разработки в
	том, что URL должны быть красивыми. Такой URL как
	<token>/time/plus/3/</token> гораздо яснее, проще и
	читабельней, его можно процитировать кому-нибудь вслух и
	... да просто лучше, чем вышеприведённый вариант. Красивые URL
	являются знаком качества приложения.
      </para>

      <para>
	Применение схем URL в Django поощряет использование красивых
	URL, облегчая работу с ними.
      </para>

    </section>

    <section id="&BASEID;.wildcardurl">

      <title id="&BASEID;.wildcardurl.title">
	Символы группировки в URL
      </title>
    
      <para>
	Продолжаем работать с нашим примером со сдвигом отображаемого
	времени и даты. Будем использовать символы группировки в
	шаблоне URL. Как мы описывали ранее, шаблон URL является
	регулярным выражением. Следовательно, мы можем использовать
	шаблон <token>\d+</token> для совпадения с одной или более
	цифрой:
	<screen>
from django.conf.urls.defaults import *
from mysite.views import current_datetime, hours_ahead

urlpatterns = patterns('',
    (r'^time/$', current_datetime),
    (r'^time/plus/\d+/$', hours_ahead),
)
	</screen>
      </para>

      <para>
	Данный шаблон совпадёт с любым URL из
	<token>/time/plus/2/</token>, <token>/time/plus/25/</token>
	или даже <token>/time/plus/100000000000/</token>. Надо об этом
	подумать, давайте ограничим максимально разрешённое смешение
	99-ю часами. Это означает, что мы позволяем указывать одно или
	двух цифирные числа &mdash; в синтаксисе регулярного выражения
	это означает <token>\d{1,2}</token>:
	<screen>
(r'^time/plus/\d{1,2}/$', hours_ahead),
	</screen>
      </para>

      <para>
	<note>
	  <title>
	    Замечание
	  </title>
	  <para>
	    При разработке приложений всегда важно учитывать
	    возможность ввода нестандартных данных и решать, должно
	    или нет приложение поддерживать такой ввод. В данном
	    примере мы ограничили ввод смещения 99-ю часами. Да и в любом случае, And, by
	    the way, The Outlandishness Curtailers would be a
	    fantastic, if verbose, band name. FIXME.
	  </para>
	</note>
      </para>

      <para>
	Теперь, когда мы определили символы группировки для URL, нам
	нужен способ для передачи этих данных в функцию представления,
	что позволит нам использовать только одну функцию
	представления для любого значения для смещения времени из
	разрешённого диапазона. Способ прост &mdash; надо взять в
	скобки нужную нам часть шаблона URL. В нашем примере, нам
	нужно сохранить введённое число, следовательно берём в скобки
	выражение <token>\d{1,2}</token>:
	<screen>
(r'^time/plus/(\d{1,2})/$', hours_ahead),
	</screen>
      </para>

      <para>
	Если у вас есть опыт работы с регулярными выражениями, здесь
	вы будете как рыба в воде. Мы использовали скобки для
	<emphasis>получения</emphasis> данных из совпавшего с
	регулярным выражением текста.
      </para>

      <para>
	В итоге файл со схемой URL будет выглядеть следующим образом:
	<screen>
from django.conf.urls.defaults import *
from mysite.views import current_datetime, hours_ahead

urlpatterns = patterns('',
    (r'^time/$', current_datetime),
    (r'^time/plus/(\d{1,2})/$', hours_ahead),
)
	</screen>
      </para>

      <para>
	Теперь пришло время создать представление
	<token>hours_ahead</token>.
      </para>

      <para>
	<note>
	  <title>
	    Порядок написания кода
	  </title>

	  <para>
	    В данном примере мы сначала создали шаблон для URL, а
	    затем само представление. Но в предыдущем примере мы
	    сначала создали представление, а затем шаблон. Какой
	    подход лучше? Ну, все разработчики разные.
	  </para>

	  <para>
	    Если вы человек N типа, вам будет удобнее создать сначала
	    все шаблоны URL для вашего приложения, в начале проекта, а
	    затем разработать представления для каждого шаблона. Такой
	    подход имеет преимущество в том, что вы получаете ясный
	    todo лист и знаете всё о параметрах для каждой функции
	    представления, которые предстоит написать.
	  </para>

	  <para>
	    Если вы человек S типа, вам будет удобнее сначала
	    разработать функции представления, а затем связать их в
	    схеме URL. Так тоже можно.
	  </para>

	  <para>
	    Пишите код так, как вам удобно. Оба подхода правильные.
	  </para>
	</note>
      </para>

      <para>
	Код представления <token>hours_ahead</token> будет подобен
	коду представления <token>current_datetime</token>, которое мы
	написали ранее, с небольшой разницей: код будет принимать
	дополнительный аргумент, смещение в часах. Добавим следующее в
	файл <filename>views.py</filename>:
	<screen>
def hours_ahead(request, offset):
    offset = int(offset)
    dt = datetime.datetime.now() + datetime.timedelta(hours=offset)
    html = "&lt;html&gt;&lt;body&gt;In %s hour(s), it will be %s.&lt;/body&gt;&lt;/html&gt;" % (offset, dt)
    return HttpResponse(html)
	</screen>
      </para>

      <para>
	Пройдёмся по коду, разбираясь с каждой строчкой отдельно:
	<itemizedlist>
	  <listitem><para>Так же как мы делали раньше для
	  <token>current_datetime</token>, мы импортируем класс
	  <classname>django.http.HttpResponse</classname> и модуль
	  <token>datetime</token>.</para></listitem>

	  <listitem>
	    <para>
	      Функция представления <token>hours_ahead</token>
	      принимает <emphasis>два</emphasis> параметра:
	      <emphasis>request</emphasis> (запрос) и
	      <emphasis>offset</emphasis> (смещение).

	      <itemizedlist>
		<listitem>
		  <para>
		    <emphasis>Запрос</emphasis> &mdash; это объект
		    <classname>HttpRequest</classname>, такой же как и
		    в случае с
		    <token>current_datetime</token>. Повторим ещё раз:
		    каждое представление <emphasis>всегда</emphasis>
		    принимает объект
		    <classname>HttpRequest</classname> в качестве
		    первого параметра.
		  </para>
		</listitem>

		<listitem>
		  <para>
		    <emphasis>Смещение</emphasis> &mdash; это строка
		    полученная с помощью скобок из шаблона
		    URL. Например, если был запрошен URL
		    <token>/time/plus/3/</token>, то
		    <emphasis>offset</emphasis> будет содержать
		    <token>3</token>. Если будет запрошен URL
		    <token>/time/plus/21/</token>, то
		    <emphasis>offset</emphasis> будет содержать
		    <token>21</token>. Следует отметить, что
		    полученные строки всегда будут
		    <emphasis>строками</emphasis>, не целыми, даже
		    если строка состоит только из чисел, например,
		    <token>21</token>.
		  </para>

		  <para>
		    Мы решили назвать эту переменную
		    <token>offset</token>, но вы можете назвать её как
		    пожелаете в соответствии со стандартами языка
		    Python. Имя переменной ни на что не влияет. Важно
		    то, что есть второй аргумент у функции. Также в
		    схеме URL есть возможность использовать
		    именованные аргументы вместо позиционных. Мы
		    рассмотрим это в главе <quote><xref
		    linkend="djangobook.chap08"
		    endterm="djangobook.chap08.title"/></quote>.
		  </para>
		</listitem>
	      </itemizedlist>

	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      Первым делом следует вызвать функцию
	      <function>int()</function> для параметра
	      <token>offset</token>. Функция преобразует строку в
	      целое число.
	    </para>

	    <para>
	      Следует отметить, что Python вызовет исключение
	      <token>ValueError</token>, если вы вызовите функцию
	      <function>int()</function> для значения, которое нельзя
	      преобразовать в целое число. Например, для строкового
	      значения <quote>foo</quote>. Тем не менее, в этом
	      примере нет нужны беспокоиться о перехвате этого
	      исключения, так как значение этого параметра может
	      содержать только цифры. Мы знаем об этом, так как
	      регулярное выражение в шаблоне URL &mdash;
	      <token>(\d{1,2})</token> &mdash; получает только
	      цифры. Эта особенность показывает удобство использования
	      схемы URL: они предоставляют некий уровень проверки
	      ввода.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      Следующая строка функции показывает почему мы вызвали
	      <function>int()</function> для <token>offset</token>. В
	      этой строке мы складываем текущее время со смещением и
	      сохраняем результат в <varname>dt</varname>. Функция
	      <function>datetime.timedelta</function> требует, чтобы
	      параметр <token>hours</token> был целым числом.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      Затем мы генерируем вывод HTML для этой функции
	      представления, как мы делали это для
	      <token>current_datetime</token>. С той разницей, что
	      теперь в форматируемую строку передаётся два значения, а
	      не одно. Таким образом, в строке есть две подстановки с
	      помощью символов <token>%s</token> и кортеж со
	      значениями: <token>(offset, dt)</token>.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      Наконец, мы возвращаем объект
	      <classname>HttpResponse</classname>.
	    </para>
	  </listitem>
	</itemizedlist>
      </para>
      
      <para>
	Имея в наличии функцию представления и её определение в схеме
	URL, запускаем сервер разработки Django (если он ещё не
	запущен) и переходим в браузере на страницу <ulink
	url="http://127.0.0.1:8000/time/plus/3/"/> для проверки её
	работы. Затем переходим на <ulink
	url="http://127.0.0.1:8000/time/plus/5/"/>. Затем на <ulink
	url="http://127.0.0.1:8000/time/plus/24/"/>. Наконец,
	переходим на <ulink
	url="http://127.0.0.1:8000/time/plus/100/"/> для того, чтобы
	проверить, что шаблон принимает только одно- и двух-цифирные
	числа. Django должен выдать ошибку <quote>Page not
	found</quote>. Переход по ссылке <ulink
	url="http://127.0.0.1:8000/time/plus/"/>
	(<emphasis>без</emphasis> указания часа) должен приводить к
	ошибке 404.
      </para>

      <para>
	Если вы изменяли код по мере чтения этой главы, то вы можете
	отметить что файл <filename>views.py</filename> теперь
	содержит два представления. (Мы опустили представление
	<token>current_datetime</token> из последнего набора примеров
	для простоты изложения.) Таким образом, файл
	<filename>views.py</filename> должен выглядеть так:
	<screen>
from django.http import HttpResponse
import datetime

def current_datetime(request):
    now = datetime.datetime.now()
    html = "&lt;html&gt;&lt;body&gt;It is now %s.&lt;/body&gt;&lt;/html&gt;" % now
    return HttpResponse(html)

def hours_ahead(request, offset):
    offset = int(offset)
    dt = datetime.datetime.now() + datetime.timedelta(hours=offset)
    html = "&lt;html&gt;&lt;body&gt;In %s hour(s), it will be %s.&lt;/body&gt;&lt;/html&gt;" % (offset, dt)
    return HttpResponse(html)
	</screen>
      </para>

    </section>

    <section id="&BASEID;.prettyerrors">

      <title id="&BASEID;.prettyerrors.title">
	Красивое отображение ошибок
      </title>
    
      <para>
	Подождите секунду, смотрите какое отличное приложение мы
	только что создали ... теперь давайте сломаем его! Мы
	предумышленно внесём ошибку в код нашего
	<filename>views.py</filename>, закомментировав строку
	<quote>offset = int(offset)</quote> в представлении
	<token>hours_ahead</token>:
	<screen>
def hours_ahead(request, offset):
    #offset = int(offset)
    dt = datetime.datetime.now() + datetime.timedelta(hours=offset)
    html = "&lt;html&gt;&lt;body&gt;In %s hour(s), it will be %s.&lt;/body&gt;&lt;/html&gt;" % (offset, dt)
    return HttpResponse(html)
	</screen>
      </para>

      <para>
	Запускаем сервер разработки Django и переходим в браузере на
	страницу <token>/time/plus/3/</token>. Вы увидите страницу с
	сообщением об ошибке, содержащую значительный объём информации,
	включая сообщение <token>TypeError</token> на самом верху:
	<screen>
"unsupported type for timedelta hours component: str"
	</screen>
      </para>

      <para>
	Что случилось? Функция <function>datetime.timedelta</function>
	ожидает, что параметр hours будет целым числом, а мы
	закомментировали тот кусок кода, который отвечает за
	конвертирование <token>offset</token> в целое число. Это
	привело к тому, что функция
	<function>datetime.timedelta</function> вызвала исключение
	<token>TypeError</token>. Это пример небольшой ошибки, которую
	каждый разработчик получает время от времени.
      </para>

      <para>
	Цель данного примера &mdash; продемонстрировать страницы
	Django с сообщениями об ошибках. Уделите время, прочитав
	сообщение об ошибке, и получите информацию, которая может
	помочь решить проблему.
      </para>

      <para>
	Следует знать несколько моментов:
	<itemizedlist>
	  <listitem><para>На самом верху страницы вы получаете
	  основную информацию об исключении: тип исключения, любые
	  параметры для исключения (в данном случае сообщение
	  <quote>unsupported type</quote>), имя файла в котором
	  произошло исключение и номер строки в
	  файле.</para></listitem>

	  <listitem>
	    <para>
	      Далее расположен полный трейс для этого
	      исключения. Вывод аналогичен стандартному трейсу,
	      который выдаёт интерпретатор Python, разве что этот
	      вариант более интерактивен. Для каждого кадра на стеке,
	      Django отображает имя файла, имя функции/метода, номер
	      строки и исходный код из этой строки.
	    </para>

	    <para>
	      Щёлкните мышью на исходном коде (на тёмно-сером) и вы
	      увидите несколько строк сверху и снизу строки с ошибкой,
	      это даст вам информацию о контексте ошибки.
	    </para>

	    <para>
	      Щёлкните на <quote>Local vars</quote> под любым кадром
	      на стеке, для получения таблицы всех локальных
	      переменных и их значений, в точке в которой произошёл
	      вызов исключения. Эта отладочная информация бесценна.
	    </para>
	  </listitem>

	  <listitem><para>Обратите внимание на текст <quote>Switch to
	  copy-and-paste view</quote> после заголовка
	  <quote>Traceback</quote>. Щёлкните на этот текст и трейс
	  отобразится в альтернативном варианте, который можно легко
	  выделить и вставить. Используйте эту особенность при
	  необходимости передать информацию об исключении в поддержку
	  &mdash; мы говорим о людях на канале Django в IRC или в
	  списке рассылки Django.</para></listitem>

	  <listitem>
	    <para>
	      Далее, секция <quote>Request information</quote>
	      включает в себя обилие информации о входящем запросе,
	      который вызвал ошибку: GET и POST информация, значение
	      cookie, мета-информация, такая как CGI
	      заголовок. Приложение <quote><xref
	      linkend="djangobook.appendix_h"
	      endterm="djangobook.appendix_h.title"/></quote> содержит
	      полный справочник по всей информации, которую содержит
	      объект запроса.
	    </para>

	    <para>
	      Ниже секции <quote>Request information</quote>
	      расположена секция <quote>Settings</quote>, которая
	      содержит все настройки для этого экземпляра Django. Все
	      возможные настройки приведены в приложении <quote><xref
	      linkend="djangobook.appendix_e"
	      endterm="djangobook.appendix_e.title"/></quote>. Теперь
	      глянем на настройки, чтобы понять, что нам
	      предоставляется.
	    </para>
	  </listitem>
	</itemizedlist>
      </para>

      <para>
	Страница с ошибкой, генерируемая Django имеет возможность
	отображать больше информации в определённых случаях, например,
	в случае синтаксической ошибки в шаблоне. Мы вернёмся к этому
	позже, во время обсуждения системы шаблонов Django. Теперь
	раскомментируем строку <quote>offset = int(offset)</quote>,
	чтобы функция представления стала работать правильно.
      </para>

      <para>
	Вы &mdash; разработчик, который предпочитает отлаживать свой
	код с помощью аккуратно расставленных операторов
	<function>print</function>? Вы также можете использовать для
	этого страницы с ошибками Django. В любой точке кода функции
	представления можно временно вставить <token>assert
	False</token> для вызова страницы с ошибкой. После этого вы
	можете просмотреть локальные переменные и состояние
	программы. (Существует более продвинутый способ отладки
	представлений Django, мы расскажем о нём позже, но этот метод
	быстрый и простой.)
      </para>

      <para>
	Наконец, очевидно, что большая часть, приводимой на странице с
	ошибкой, информации не должна попасть к посторонним &mdash;
	она рассказывает о вашем коде на языке Python и о конфигурации
	Django &mdash; глупо распространять такую информацию в
	Интернет. Какая-нибудь злобная личность может использовать эту
	информацию, пытаясь разобраться в коде вашего приложения и
	сделать что-нибудь плохое. По этой причине, Django отображает
	сообщения об ошибках, только если этот экземпляр приложения
	находится в режиме отладки. Мы расскажем как отключить режим
	отладки немного позже. Просто имейте в виду, что любой проект
	Django после его создания находится в режиме
	отладки. (По-моему уже это было. Ошибки <quote>Page not
	found</quote>, описанные в главе <quote><xref
	linkend="&BASEID;.404errors"
	endterm="&BASEID;.404errors.title"/></quote>, обрабатываются
	подобным образом.)
      </para>

    </section>

  </section>

</chapter>
