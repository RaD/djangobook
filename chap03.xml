<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
"http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd"
[
<!ENTITY BASEID "djangobook.chap03">
]>

<chapter lang="ru" id="&BASEID;">

  <title id="&BASEID;.title">
    Представления и привязки URL
  </title>

  <para>
    Перевод &copy; Попов Руслан &lt;ruslan.popov &bull; gmail&gt;
  </para>

  <para>
    В предыдущей главе мы объяснили как настроить проект и запустить
    сервер разработки. В этой главе вы изучите основы создания
    динамических страниц с помощью Django.
  </para>

  <section id="&BASEID;.first-page">

    <title id="&BASEID;.first-page.title">
      Ваша первая страница на Django: Привет, Мир
    </title>

    <para>
      В качестве вашего первого задания, давайте создадим страницу,
      которая будет выводить знаменитое сообщение: <quote>Здравствуй,
      Мир</quote>.
    </para>

    <para>
      Если бы вы создавали обычную страницу с текстом
      <quote>Здравствуй, Мир</quote> без использования Django, то
      достаточно было бы создать файл с таким текстом, дать ему имя
      <filename>hello.html</filename> и загрузить в каталог на веб
      сервере. Следует отметить, что в этом случае, вы определяете два
      ключевых параметра страницы: её содержимое (строка
      <quote>Здравствуй, Мир</quote>) и её URL (<ulink
      url="http://www.example.com/hello.html/"/>).
    </para>

    <para>
      Используя Django, вы указываете те же самые параметры, но другим
      способом. Содержимое страницы создаётся с помощью
      <emphasis>функции представления</emphasis>, а URL определяется в
      <emphasis>файле привязок URL</emphasis>. Сначала давайте напишем
      нашу функцию представления.
    </para>

    <section id="&BASEID;.first-page.first-view">

      <title id="&BASEID;.first-page.first-view.title">
	    Ваше первое представление
      </title>

      <para>
	    Внутри каталога <filename>mysite</filename>, который был
	    создан с помощью команды <command>django-admin.py
	    startproject</command> в предыдущей главе, создайте пустой
	    файл с именем <filename>views.py</filename>. Этот файл будет
	    содержать представления, описываемые в данной главе. Следует
	    отметить, что нет ничего особенного в выбранном нами имени
	    файла. Django нет никакой разницы как он называется и вы
	    убедитесь в этом сами. Но, назвать так файл &mdash; это
	    хорошая идея, другим разработчикам будет проще ориентироваться
	    в вашем коде.
      </para>

      <para>
	    Наше представление простое, оно состоит из кода функции и
	    оператора импорта. Вот содержимое файла
	    <filename>views.py</filename>:
	    <screen>
	      <![CDATA[
# -*- coding: utf-8 -*-
from django.http import HttpResponse

def hello(request):
    return HttpResponse("Здравствуй, Мир")
          ]]>
	    </screen>
      </para>

      <para>
        Пройдёмся по коду, строчка за строчкой:
        <itemizedlist>
          <listitem>
            <para>
              Сначала мы импортируем класс
              <classname>HttpResponse</classname>, который определён в
              модуле <token>django.http</token>. Нам необходимо
              импортировать этот класс, так как он используется в
              нашем коде.
            </para>
          </listitem>

          <listitem>
            <para>
              Затем, мы определяем функцию <function>hello</function>
              &mdash; функцию представления.
            </para>

            <para>
              Каждая функция представления принимает как минимум один
              параметр, который для удобства называют
              <token>request</token>. Это объект, который содержит
              информацию об обрабатываемом запросе, который привёл к
              вызову данной функции представления. Объект является
              экземпляром класса
              <classname>django.http.HttpRequest</classname>. В данном
              примере, мы ничего не делаем с этим объектом, но не
              смотря ни на что, он всегда должен быть первым
              параметром функции представления.
            </para>

            <para>
              Следует отметить, что имя функции представления несёт
              только смысловую нагрузку для разработчика. Мы дали
              функции имя <function>hello</function>, так как такое
              имя явно определяет назначение функции, но мы могли бы
              её назвать и так
              <function>hello_wonderful_beautiful_world</function> и
              так далее.  Следующий раздел, <quote><xref
              linkend="&BASEID;.first-page.first-urls"
              endterm="&BASEID;.first-page.first-urls.title"/></quote>,
              проливает свет на то, как Django находит функцию.
            </para>
          </listitem>

          <listitem>
            <para>
              Функция является однострочной. Она просто возвращает
              <classname>HttpResponse</classname> объект, который был
              создан с текстом <quote>Здравствуй, мир</quote>.
            </para>
          </listitem>
        </itemizedlist>
      </para>

      <para>
        Основная идея в том, что представление является функцией языка
        Python, которая принимает <classname>HttpRequest</classname> в
        качестве первого параметра и возвращает экземпляр
        <classname>HttpResponse</classname>. Для того, чтобы функция
        языка Python стала функцией представления Django, он должен
        соответствовать этим двум правилам. Есть исключения из этих
        правил, но мы рассмотрим их позже.
      </para>

    </section>

    <section id="&BASEID;.first-page.first-urls">

      <title id="&BASEID;.first-page.first-urls.title">
        Ваша первая привязка URL
      </title>

      <para>
        Если в этот момент вы бы запустили снова команду
        <command>python manage.py runserver</command>, то вы бы
        увидели сообщение <quote>Welcome to Django</quote> без единого
        следа нашего представления. Так происходит потому, что наш
        проект <token>mysite</token> ещё не знает о представлении
        <function>hello</function>. Нам потребуется явно указать
        Django, что мы активируем данное представление для конкретного
        URL. (Продолжая нашу аналогию с публикацией статичных HTML
        файлов, как будто бы мы создали HTML файл, но ещё не закачали
        его в каталог на сервере.) Для привязки функции представления
        к конкретному URL в Django используются файлы привязки URL.
      </para>

      <para>
        <emphasis>Файл привязки URL</emphasis> можно рассматривать как
        таблицу с содержанием вашего сайта. Проще говоря, этот файл
        определяет соответствие между URL и функциями представления,
        которые должны быть вызваны для этих URL. Именно так вы
        указываете Django: <quote>Для данного URL, вызывай этот код, а
        для этого URL вызывай вот этот код.</quote> Например,
        <quote>Если кто-нибудь посетит URL <token>/foo/</token>,
        вызывай функцию представления <function>foo_view()</function>,
        которая расположена в модуле
        <filename>views.py</filename>.</quote>
      </para>

      <para>
        Когда вы запустили <command>django-admin.py
        startproject</command> в предыдущей главе, скрипт
        автоматически создал для вас файл привязки:
        <filename>urls.py</filename>. По-умолчанию, он выглядит
        примерно так:
        <screen>
          <![CDATA[
from django.conf.urls.defaults import *

# Uncomment the next two lines to enable the admin:
# from django.contrib import admin
# admin.autodiscover()

urlpatterns = patterns('',
    # Example:
    # (r'^mysite/', include('mysite.foo.urls')),

    # Uncomment the admin/doc line below and add 'django.contrib.admindocs'
    # to INSTALLED_APPS to enable admin documentation:
    # (r'^admin/doc/', include('django.contrib.admindocs.urls')),

    # Uncomment the next line to enable the admin:
    # (r'^admin/', include(admin.site.urls)),
)
          ]]>
        </screen>
      </para>

      <para>
        Этот стандартный файл привязки включает несколько
        закомментированных блоков, просто раскомментируйте их, если
        вам нужен соответствующий функционал. Если проигнорировать
        закомментированные строки, то останется только это:
        <screen>
          <![CDATA[
from django.conf.urls.defaults import *

urlpatterns = patterns('',
)
          ]]>
        </screen>
      </para>

      <para>
        Давайте пройдём по каждой строчке этого кода:
        <itemizedlist>
          <listitem>
            <para>
              Первая строка импортирует все объекты из модуля
              <token>django.conf.urls.defaults</token>, который
              содержит всю инфраструктуру для работы с файлами
              привязки. Там же находится функция
              <function>patterns</function>.
            </para>
          </listitem>

          <listitem>
            <para>
              Вторая строка вызывает функцию
              <function>patterns</function> и сохраняет результат в
              переменную <varname>urlpatterns</varname>. Фунцкия
              <function>patterns</function> принимает единственный
              аргумент &mdash; пустую строку. (Эта строка может быть
              использована для передачи общего префикса для функций
              представления, эта особенность будет описана в главе
              <quote><xref linkend="djangobook.chap08"
              endterm="djangobook.chap08.title"/></quote>.)
            </para>
          </listitem>
        </itemizedlist>
      </para>

      <para>
        Основным элементом данного кода является переменная
        <varname>urlpatterns</varname>, которую Django ожидает найти в
        вашем файле привязки. Эта переменная определяет соответствие
        между списком URL и кодом, который обрабатывает данные
        URL. По-умолчанию, как вы можете видеть, файл привязки пуст
        &mdash; ваше Django приложение ещё не настроено. (Именно так
        Django определяет, что следует показывать страницу
        <quote>Welcome to Django</quote>. Если ваш файл привязки пуст,
        Django предполагает, что вы только что начали новый проект и,
        следовательно, отображает данное сообщение.)
      </para>

      <para>
        Для того, чтобы добавить URL и представление в файл привязки,
        просто добавьте кортеж, объединяющий URL и функцию
        представления. Ниже показана привязка для нашего представления
        <function>hello</function>:
        <screen>
          <![CDATA[
from django.conf.urls.defaults import *
from mysite.views import hello

urlpatterns = patterns('',
    ('^hello/$', hello),
)
          ]]>
        </screen>
      </para>

      <para>
        (Следует отметить, что мы убрали закомментированные строчки
        для ясности. Вы можете оставить эти строки, если вам
        захочется.)
      </para>

      <para>
        Мы сделали следующие изменения:
        <itemizedlist>
          <listitem>
            <para>
              Сначала мы проимпортировали представление
              <function>hello</function> из его модуля &mdash;
              <filename>mysite/views.py</filename>, которое
              преобразовалось в <token>mysite.views</token>.
            </para>
          </listitem>

          <listitem>
            <para>
              Затем, мы добавили строку <token>('^hello/$',
              hello)</token> в <varname>urlpatterns</varname>. Такая
              строка известна как <emphasis>шаблон URL</emphasis>. Это
              обычный кортеж языка Python, в котором первый элемент
              является шаблоном регулярного выражения, а второй
              элемент &mdash; функция представления, которая должна
              использоваться при совпадении данного шаблона.
            </para>
          </listitem>
        </itemizedlist>
      </para>

      <para>
        В двух словах, мы просто указали Django, что любой запрос к
        URL <token>/hello/</token> должен быть обработан с помощью
        функции представления <function>hello</function>.
      </para>

      <para>
        <note>
          <title>
            Ваш PYTHONPATH
          </title>

          <para>
            Ваш <emphasis>PYTHONPATH</emphasis> является списком
            каталогов вашей системы, где интерпретатор Python
            производит поиск модулей в момент когда вы используете
            оператор <token>import</token>.
          </para>

          <para>
            Например, допустим, что путь имеет следующее значение:
            <screen>
              <![CDATA[
['', '/usr/lib/python2.4/site-packages', '/home/username/djcode/']
              ]]>
            </screen>
          </para>

          <para>
            При выполнении кода:
            <screen>
              <![CDATA[
from foo import bar
              ]]>
            </screen>
            интерпретатор сначала проверит наличие файла
            <filename>foo.py</filename> в текущем каталоге. (Первым
            элементом списка идёт пустая строка, которая означает
            <quote>текущий каталог</quote>.) Если такого файла там
            нет, то интерпретатор ищет файл в каталоге
            <filename>/usr/lib/python2.4/site-packages</filename>,
            затем в каталоге
            <filename>/home/username/djcode/</filename>. Наконец, если
            файл всё ещё не найден, интерпретатор возвращает
            <token>ImportError</token>.
          </para>

          <para>
            Если вам интересно посмотреть на значения пути, запустите
            интерпретатор и выполните следующие команды:
            <screen>
              <![CDATA[
>>> import sys
>>> print sys.path
              ]]>
            </screen>
          </para>

          <para>
            В общем случае вам не требуется беспокоиться о настройке
            пути. Это задача Python и Django, они сами об этом
            позаботятся. (Настройка пути, это одна из задач, которыми
            занимается скрипт <filename>manage.py</filename>.)
          </para>
        </note>
      </para>

      <para>
        Стоит обсудить синтаксис данного шаблона URL, так как он может
        быть не совсем очевиден. Несмотря на то, что шаблон должен
        совпадать с <token>/hello/</token>, он выглядит немного не
        так. Объясним почему:
        <itemizedlist>
          <listitem>
            <para>
              Django удаляет слеш вначале каждого URL, перед его
              проверкой относительно шаблонов. Это означает, что наш
              шаблон не включает ведущего слеша в
              <token>/hello/</token>. (Во-первых, это может показаться
              запутанным, но данное требование всё упрощает &mdash;
              например, включение одного файла привязок в другой,
              которое мы рассмотрим в главе <quote><xref
              linkend="djangobook.chap08"
              endterm="djangobook.chap08.title"/></quote>.)
            </para>
          </listitem>

          <listitem>
            <para>
              Шаблон включает в себя символы <token>^</token> и
              <token>$</token>. Они являются символами регулярного
              выражения, которые имеют особое значение:
              <token>^</token> означает <quote>требовать, чтобы шаблон
              совпадал с начала строки</quote>, а <token>$</token>
              означает <quote>требовать, чтобы шаблон совпадал до
              конца строки</quote>.
            </para>

            <para>
              Данный подход лучше объяснять на примере. Если бы мы
              использовали шаблон <token>'^hello/'</token> (без
              завершающего <token>$</token>), тогда
              <emphasis>любой</emphasis> URL, начинающийся с
              <token>/hello/</token> совпадал бы с шаблоном. Например,
              такие как <token>/hello/foo</token> и
              <token>hello/bar</token>, а не только
              <token>/hello/</token>. Аналогично, если бы мы опустили
              начальный <token>^</token> (т.е.,
              <token>'hello/$'</token>), Django будет обрабатывать
              <emphasis>любой</emphasis> URL, который оканчивается на
              <token>hello/</token>. Например, такой как
              <token>foo/bar/hello/</token>. Если бы мы просто указали
              в качестве шаблона <token>'hello/'</token>, без символов
              <token>^</token> и <token>$</token>, тогда шаблону бы
              соответствувал любой URL, содержащий
              <token>hello/</token>. Например, такой как
              <token>/foo/hello/bar</token>. Следовательно, мы
              используем оба этих специальных символа для точного
              определения нашего шаблона. Он должен совпадать только с
              <token>/hello/</token>, не больше и не меньше.
            </para>

            <para>
              Большинство ваших шаблонов для URL будут соответствовать
              вышеописанному правилу. Но неплохо было бы иметь больше
              гибкости для выполнения более изощрённых проверок.
            </para>

            <para>
              Вы можете удивиться тому, что произойдёт, если
              кто-нибудь запросит страницу по URL
              <token>/hello</token> (то есть, <emphasis>без</emphasis>
              завершающего слеша). Так как наш шаблон требует наличие
              завершающего слеша, этот URL не будет распознан. Тем не
              менее, по умолчанию, любой запрос к URL, который
              <emphasis>не</emphasis> совпадает с шаблоном и
              <emphasis>не</emphasis> завершается слешом,
              перенаправляется на тот же URL с добавленным завершающем
              слешом. (Это поведение регулируется параметром
              конфигурации Django <varname>APPEND_SLASH</varname>,
              который описан в приложении D FIXME.)
            </para>

            <para>
              Если вы относитесь к той группе людей, которые
              предпочитают URL с завершающими слешами (таких
              большинство среди разработчиков Django), всё, что вам
              потребуется сделать &mdash; добавить завершающий слеш в
              каждый шаблон URL и установить значение переменной
              <varname>APPEND_SLASH</varname> в
              <token>True</token>. Если вы предпочитаете иной вариант
              (по той или иной причине), установите
              <varname>APPEND_SLASH</varname> в <token>False</token>.
            </para>
          </listitem>
        </itemizedlist>
      </para>

      <para>
        Следует отметить ещё один важный момент. В шаблоне URL мы
        передаём функцию представления <function>hello</function> в
        виде объекта, без его вызова. Это возможно благодаря ключевой
        особенности языка Python (и любого другого динамического
        языка): функции являются объектами первого рода, это означает,
        что вы можете передавать их в другие объекты аналогично
        переменным. Прикольно, не так ли?
      </para>

      <para>
        Для того, чтобы протестировать наши изменения внесённые в файл
        привязок, запустите тестовый сервер, как это было показано в
        главе <quote><xref linkend="djangobook.chap02"
        endterm="djangobook.chap02.title"/></quote>, выполнив команду
        <command>python manage.py runserver</command>. (Если вы не
        останавливали его работу, это тоже неплохо. Тестовый сервер
        автоматически обнаруживает изменения в вашем коде и выполняет
        его перезагрузку по необходимости, таким образом, вам не надо
        делать это вручную.) Сервер привязывается к адресу <ulink
        url="http://127.0.0.1:8000/"/>, так что откройте браузер и
        пройдите по ссылке <ulink
        url="http://127.0.0.1:8000/hello/"/>. Вы должны увидеть текст
        <quote>Здравствуй, Мир</quote> &mdash; результат работы вашего
        представления.
      </para>

      <para>
        Ура! Вы создали вашу первую страницу с помощью Django.
      </para>

      <para>
        <note>
          <title>
            Регулярные выражения
          </title>

          <para>
            <emphasis>Регулярные
            выражения</emphasis><footnote><para>Для информации по
            регулярным выражениям обращайтесь на <ulink
            url="http://www.djangoproject.com/r/python/re-module/"/> и
            на <ulink
            url="http://docs.python.org/lib/re-syntax.html"/>.</para></footnote>
            &mdash; компактный метод определения шаблонов в тексте. В
            то время как схема URL Django позволяет использование
            определённых регулярных выражений для работы с URL,
            вероятно на практике вы будете использовать не так много
            регулярных выражений для шаблонов. В таблице <quote><xref
            linkend="&BASEID;.tbl1"
            endterm="&BASEID;.tbl1.title"/></quote> приведена выборка
            наиболее используемых шаблонов.
          </para>
        </note>
      </para>

      <para>
        <table id="&BASEID;.tbl1" frame="all" pgwide="1">

          <title id="&BASEID;.tbl1.title">
            Выборка наиболее используемых шаблонов
          </title>

          <tgroup cols="2" align="left" colsep="1" rowsep="1">

            <colspec colname="c1" colwidth="2cm"/>
            <colspec colname="c2" colwidth="12cm"/>

            <thead>
              <row>
                <entry>Символ</entry>
                <entry>Совпадает</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><token>.</token> (точка)</entry>
                <entry>Любой символ</entry>
              </row>

              <row>
                <entry><token>\d</token></entry>
                <entry>Любая цифра</entry>
              </row>

              <row>
                <entry><token>[A-Z]</token></entry>
                <entry>Любая буква (верхний регистр)</entry>
              </row>

              <row>
                <entry><token>[a-z]</token></entry>
                <entry>Любая буква (нижний регистр)</entry>
              </row>

              <row>
                <entry><token>[A-Za-z]</token></entry>
                <entry>Любая буква (любой регистр)</entry>
              </row>

              <row>
                <entry><token>+</token></entry>
                <entry>Один или более символов предыдущего выражения,
                т.е. <token>\d+</token> совпадает с одной или более
                цифрами</entry>
              </row>

              <row>
                <entry><token>[^/]+</token></entry>
                <entry>Все символы подряд, кроме слэша</entry>
              </row>

              <row>
                <entry><token>?</token></entry>
                <entry>Наличие или отсутствие предыдущего выражения,
                т.е. <token>\d?</token> описывает возможное наличие
                одной цифры</entry>
              </row>

              <row>
                <entry><token>{1, 3}</token></entry>
                <entry>Между одним или тремя (включая) предыдущими
                выражениями</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </para>

    </section>

    <section id="&BASEID;.first-page.error404">

      <title id="&BASEID;.first-page.error404.title">
        Кратко об ошибках 404
      </title>

      <para>
        В текущий момент наш файл привязок определяет единственный
        шаблон: тот, который обрабатывает запросы по URL
        <token>URL</token>. Что произойдёт при запросе другого URL?
      </para>

      <para>
        Чтобы узнать это запустите тестовый сервер и посетите страницу
        такую как <ulink url="http://127.0.0.1:8000/goodbye/"/> или
        <ulink url="http://127.0.0.1:8000/hello/subdirectory/"/>, или
        даже такую <ulink url="http://127.0.0.1:8000/"/> (корень
        сайта). Вы должны увидеть сообщение <quote>Страница не
        найдена</quote> (см. картинку FIXME). Django отображает это
        сообщение, потому что вы запросили URL, который не был
        определён в файле привязок.
      </para>

      <para>
        Назначение данной страницы идёт значительно дальше простого
        отображения сообщения об ошибке 404. Она также точно вам
        указывает какой файл привязки использовало Django и показывает
        каждый шаблон из этого файла. Из этой информации вы получаете
        возможность понять, почему была вызвана ошибка 404.
      </para>

      <para>
        Обычно, эта информация предназначена только для вас, для
        разработчика. В случае боевого сайта, выставленного в
        Интернет, врядли вы пожелаете показывать такую информацию
        неизвестным людям. По этой причине страница с подробностями об
        ошибке 404 отображается только в том случае, когда ваш проект
        находится в <emphasis>режиме отладки</emphasis>. Мы расскажем
        как деактивировать режим отладки позже. Сейчас просто
        запомните, что новый проект Django всегда создаётся со
        включенным режимом отладки, и что когда проект не находится в
        этом режиме, Django показывает совсем другое сообщение об
        ошибке 404.
      </para>

    </section>

    <section id="&BASEID;.first-page.siteroot">

      <title id="&BASEID;.first-page.siteroot.title">
        Кратко о корне сайта
      </title>

      <para>
        Как было описано в последнем разделе, вы увидите сообщение об
        ошибке 404 в случае, если вы перейдёте в корень сайта &mdash;
        по URL <ulink url="http://127.0.0.1:8000/"/>. Django ничего не
        добавляет к корню сайта. Данный URL ни коим образом не
        является чем-то особенным. Назначить корню сайта
        соответствующий шаблон &mdash; это целиком ваша задача, как и
        всё остальное в вашем файле привязки.
      </para>

      <para>
        Шаблон для корня сайта не совсем очевиден, наверное стоит это
        отметить. Когда вы будете готовы реализовать представление для
        корня сайта, используйте шаблон <token>'^$'</token>, который
        соответствует пустой строке. Например:
        <screen>
          <![CDATA[
from mysite.views import hello, my_homepage_view

urlpatterns = patterns('',
    ('^$', my_homepage_view),
    # ...
)
          ]]>
        </screen>
      </para>

    </section>

  </section>

  <section id="&BASEID;.process-request">

    <title id="&BASEID;.process-request.title">
      Как Django обрабатывает запрос
    </title>

    <para>
      Перед тем как приняться за вторую функцию представления, давайте
      изучим немного подробнее то, как работает Django. Конкретно, что
      делает Django в тот момент, когда вы запрашиваете страницу через
      <ulink url="http://127.0.0.1:8000/hello/"/>?
    </para>

    <para>
      Всё начинается с <emphasis>файла конфигурации</emphasis>. Когда
      вы запускаете <command>python manage.py runserver</command>,
      скрипт ищет файл с именем <filename>settings.py</filename> в том
      же каталоге, в котором находится файл
      <filename>manage.py</filename>. Данный файл содержит всю
      информацию о конфигурации конкретного проекта Django, все
      параметры указаны большими буквами:
      <token>TEMPLATE_DIRS</token>, <token>DATABASE_NAME</token> и так
      далее. Самый главный параметр называется
      <token>ROOT_URLCONF</token>. Этот параметр указывает Django
      какой модуль Python следует использовать в качестве файла
      привязки для данного сайта.
    </para>

    <para>
      Запомните, что <command>django-admin.py startproject</command>
      создаёт файлы <filename>settings.py</filename> и
      <filename>urls.py</filename>. Параметр
      <token>ROOT_URLCONF</token> созданного файла настроек указывает
      на созданный файл привязок. Откройте
      <filename>settings.py</filename> и удостоверьтесь сами. Там
      должны быть строчка:
      <screen>
        <![CDATA[
ROOT_URLCONF = 'mysite.urls'
        ]]>
      </screen>
    </para>

    <para>
      Она соответствует файлу <filename>mysite/urls.py</filename>.
    </para>

    <para>
      Когда приходит запрос на определённый URL &mdash; скажем, на
      <token>/hello/</token> &mdash; Django загружает файл привязок,
      указанный параметром <token>ROOT_URLCONF</token>. Затем
      проверяет каждый шаблон этого файла, по-порядку, сравнивая
      запрошенный URL с шаблонами, пока не найдёт подходящий. Если
      совпадение найдено, Django вызывает функцию представления,
      ассоциированную с данным шаблоном, передавая ей объект
      <classname>HttpRequest</classname> в качестве первого
      аргумента. (Мы рассмотрим особенности
      <classname>HttpRequest</classname> позже.)
    </para>

    <para>
      Как мы видели в нашем первом примере представления, функция
      представления должна возвращать
      <classname>HttpResponse</classname>. После того как она это
      сделала, Django делает всё остальное: преобразовывает объект
      Python в соответствующий отклик с необходимыми HTTP заголовками
      и телом (т.е., содержимым страницы).
    </para>

    <para>
      В общем:
      <itemizedlist>
        <listitem>
          <para>
            Приходит запрос к <token>/hello/</token>.
          </para>
        </listitem>

        <listitem>
          <para>
            Django определяет корневой файл привязки, с помощью
            параметра конфигурации <token>ROOT_URLCONF</token>.
          </para>
        </listitem>

        <listitem>
          <para>
            Django просматривает файл привязки в поисках первого
            шаблона, который совпадёт с запрошенным URL.
          </para>
        </listitem>

        <listitem>
          <para>
            Если такой шаблон найден, Django вызывает ассоциированную
            с ним функцию представления.
          </para>
        </listitem>

        <listitem>
          <para>
            Функция представления возвращает
            <classname>HttpResponse</classname>.
          </para>
        </listitem>

        <listitem>
          <para>
            Django преобразовывает <classname>HttpResponse</classname>
            в соответствующий HTTP отклик, который реализует страницу.
          </para>
        </listitem>
      </itemizedlist>
    </para>

    <para>
      Теперь вы знаете основы создания страниц с помощью Django. Это
      несложно &mdash; просто напишите функции представления и
      ассоциируйте их с шаблонами через файл привязки.
    </para>

  </section>

  <section id="&BASEID;.second-view">

    <title id="&BASEID;.second-view.title">
      Ваше второе представление: Динамическое содержимое
    </title>

    <para>
      Наше представление <quote>Здравствуй, Мир</quote> было
      поучительным с точки зрения основ использования Django, но оно
      не было примером <emphasis>динамического</emphasis> создания
      страниц, так как содержимое страницы не изменялось. Каждый раз,
      посещая эту страницу, вы видели одно и тоже. То же самое
      достигается и с помощью статического HTML файла.
    </para>

    <para>
      Для нашего второго представления давайте создадим что-нибудь
      динамическое &mdash; страницу, которая будет отображать текущую
      дату и время. Это хороший и одновременно простой пример, потому
      что он не требует ни использования базы данных, ни обработки
      пользовательского ввода &mdash; просто выводит значение
      даты/времени, ориентируясь на внутренние часы сервера. Это лишь
      чуть более интересно, чем предыдущее представление, но оно
      продемонстрирует несколько новых концепций.
    </para>

    <para>
      Данное представление должно делать две вещи: вычислять текущую
      дату и время и возвращать <classname>HttpResponse</classname>,
      содержащий это значение. Если у вас был опыт работы с Python, вы
      знаете, что он предоставляет модуль <token>datetime</token> для
      работы с датой и временем. Покажем как его можно использовать:
      <screen>
        <![CDATA[
>>> import datetime
>>> now = datetime.datetime.now()
>>> now
datetime.datetime(2008, 12, 13, 14, 9, 39, 2731)
>>> print now
2008-12-13 14:09:39.002731
        ]]>
      </screen>
    </para>

    <para>
      Это достаточно просто и не требует наличия Django. Это просто
      код на языке Python. (Мы хотели бы подчеркнуть, что вы должны
      знать различия между <quote>просто Python</quote> и кодом,
      который относится к Django. После того, как вы изучите Django,
      мы хотим, чтобы вы могли применить свои знания в других Python
      проектах, которые не обязательно бы использовали Django.)
    </para>

    <para>
      Для того, чтобы создать представление, которое отображает
      текущую дату и время, необходимо добавить вызов
      <function>datetime.datetime.now()</function> в представление и
      возвратить <classname>HttpResponse</classname>. Вот так это
      выглядит:
      <screen>
        <![CDATA[
from django.http import HttpResponse
import datetime

def current_datetime(request):
    now = datetime.datetime.now()
    html = "<html><body>It is now %s.</body></html>" % now
    return HttpResponse(html)
        ]]>
      </screen>
    </para>

    <para>
      Аналогично функции представления <function>hello</function>,
      данная функция должна располагаться в
      <filename>views.py</filename>. Следует отметить, что мы спрятали
      функцию <function>hello</function> из этого примера для
      краткости, но весь файл будет выглядеть так:
      <screen>
        <![CDATA[
from django.http import HttpResponse
import datetime

def hello(request):
    return HttpResponse("Hello world")

def current_datetime(request):
    now = datetime.datetime.now()
    html = "<html><body>It is now %s.</body></html>" % now
    return HttpResponse(html)
        ]]>
      </screen>
    </para>

    <para>
      (Начиная с этого места, мы больше не будем показывать предыдущий
      код в примерах, кроме моментов, когда это действительно
      необходимо. У вас будет возможность понять из контекста, какая
      часть кода новая, а какая &mdash; старая.)
    </para>

    <para>
      Пройдёмся по изменениям, которые мы сделали в
      <filename>views.py</filename> при создании представления
      <function>current_datetime</function>:

      <itemizedlist>
        <listitem>
          <para>
            Мы добавили <token>import datetime</token> в начало
            модуля, теперь мы можем работать с датами.
          </para>
        </listitem>

        <listitem>
          <para>
            Новая функция <function>current_datetime</function>
            возвращает текущую дату и время, в виде объекта
            <classname>datetime.datetime</classname>, и сохраняет его
            в локальной переменной <varname>now</varname>.
          </para>
        </listitem>

        <listitem>
          <para>
            Вторая строка кода внутри представления создаёт HTML
            отклик, используя возможности Python для форматирования
            строк. Элемент <token>%s</token> внутри строки является
            подстановкой, а знак процента после строки означает
            <quote>Замени <token>%s</token> в предыдущей строке на
            значение переменной <varname>now</varname>.</quote>
            Переменная <varname>now</varname> технически является
            объектом <classname>datetime.datetime</classname>, не
            строкой, но подстановка <token>%s</token> преобразовывает
            его в строковое представление, подобное <token>"2008-12-13
            14:09:39.002731"</token>. Всё это выражается в виде HTML
            строки <token>"<![CDATA[<html><body>It is now 2008-12-13
            14:09:39.002731.</body></html>]]>"</token>.
          </para>

          <para>
            (Да, наш HTML некорректен, но мы стараемся сделать наш
            пример простым и коротким.)
          </para>
        </listitem>

        <listitem>
          <para>
            Наконец, представление возвращает объект
            <classname>HttpResponse</classname>, который содержит
            сгенерированный отклик &mdash; точно так же, как и в
            случае с <function>hello</function>.
          </para>
        </listitem>
      </itemizedlist>
    </para>

    <para>
      После добавления новой функции в <filename>views.py</filename>,
      следует добавить шаблон в <filename>urls.py</filename>, чтобы
      указать Django какой именно URL должен обрабатываться с помощью
      этой функции представления. Подойдёт что-нибудь подобное
      <token>/time/</token>:
      <screen>
        <![CDATA[
from django.conf.urls.defaults import *
from mysite.views import hello, current_datetime

urlpatterns = patterns('',
    ('^hello/$', hello),
    ('^time/$', current_datetime),
)
        ]]>
      </screen>
    </para>

    <para>
      Здесь мы сделали два изменения. Сначала мы проимпортировли
      функцию <function>current_datetime</function> в начале
      модуля. Затем, и это самое главное, мы добавили шаблон URL
      <token>/time/</token>, ассоциированный с этим новым
      представлением.
    </para>

    <para>
      После всех этих действий можно запустить
      <token>runserver</token> и посетите <ulink
      url="http://127.0.0.1:8000/time/"/> с помощью браузера. Вы
      должны увидеть текущую дату и время.

      <note>
        <title>
          Временная зона в Django
        </title>

        <para>
          Время на вашем компьютере может отличаться на несколько
          часов. Всё потому, что Django обращает внимание на временные
          зоны, а по умолчанию Django настроен на зону
          <token>America/Chicago</token>. (Она должна быть установлена
          по-умолчанию, вот разработчики Django и выбрали в качестве
          таковой свою временную зону.) Если вы живёте не рядом с
          ними, укажите свою зону в
          <filename>settings.py</filename>. Обратите внимание на
          комментарий в этом файле, там указана ссылка с актуальным
          списком мировых временных зон.
        </para>
      </note>
    </para>

  </section>

  <section id="&BASEID;.loose-coupling">

    <title id="&BASEID;.loose-coupling.title">
      Схема URL и свободное связывание
    </title>

    <para>
      Настало время указать на ключевой момент схемы URL и Django в
      целом: принцип <emphasis>свободного
      связывания</emphasis>. Просто примем, что свободное связывание
      является неким подходом к разработке программного обеспечения,
      который отражает важность создания связываемых компонентов. Если
      два компонента кода свободно связаны, тогда изменения, сделанные
      в одном компоненте отразятся незначительно или совсем не
      отразятся на коде другого компонента.
    </para>

    <para>
      Схема URL Django является хорошим примером применения такого
      принципа на практике. В Django-приложении определения URL и
      функций представления, которые они вызывают связаны
      свободно. Следовательно, решение о том, какой URL должен
      соответствовать данной функции и реализация самой функции
      располагаются в двух разных местах. Это позволяет вам отключать
      один компонент приложения без влияния на остальные.
    </para>

    <para>
      Для примера рассмотрим наше представление
      <function>current_datetime</function>. Если нам потребуется
      изменить URL в приложении, скажем, переименовать его из
      <token>/time/</token> в <token>/current-time/</token>, нам
      достаточно будет сделать быстрое изменение в файле привязок, не
      беспокоясь о самом представлении. Аналогично, если нам
      потребуется изменить функцию представления &mdash; как-то
      изменить логику её работы &mdash; мы можем сделать это без
      внесения изменений в URL, к которому привязана данная функция.
    </para>

    <para>
      Продолжая, если нам потребуется разделить функционал данного
      представления между <emphasis>несколькими</emphasis> URL, мы
      сможем легко реализовать это, отредактировав схему URL, не внося
      изменений в код представления. В данном примере, наше
      представление <function>current_datetime</function> доступно по
      двум URL:
      <screen>
        <![CDATA[
urlpatterns = patterns('',
    ('^hello/$', hello),
    ('^time/$', current_datetime),
    ('^another-time-page/$', current_datetime),
)
        ]]>
      </screen>
    </para>

    <para>
      Схема URL и представления являются примером свободного
      связывания в действии. Мы продолжим рассматривать на примерах
      этот важный подход в течение всей книги.
    </para>

  </section>

  <section id="&BASEID;.third-view">

    <title id="&BASEID;.third-view.title">
      Ваше третье представление: Динамические URL
    </title>

    <para>
      В нашем представлении <function>current_datetime</function>
      содержимое страницы &mdash; текущая дата и время &mdash; были
      динамическими, но URL оставался статическим. В большинстве
      динамических web-приложений URL содержат параметры, которые
      влияют на генерацию страницы. Например, онлайн магазин может
      отображать книгу по её собственному URL, таким как
      <token>/books/243/</token> и <token>/books/81196/</token>.
    </para>

    <para>
      Давайте создадим третье представление, которое отображает
      текущую дату и время со смещением на указанное количество
      часов. Цель &mdash; реализовать функциональность, с помощью
      которой сайт будет по URL <token>/time/plus/1/</token> отдавать
      текущее время сдвинутое на час вперёд, а по URL
      <token>/time/plus/2/</token> &mdash; на два часа вперёд и так
      далее.
    </para>

    <para>
      Новичок может подумать, что потребуется создавать функцию
      представления для каждого смещения часа, что может выразится в
      следующей схеме URL:
      <screen>
        <![CDATA[
urlpatterns = patterns('',
    ('^time/$', current_datetime),
    ('^time/plus/1/$', one_hour_ahead),
    ('^time/plus/2/$', two_hours_ahead),
    ('^time/plus/3/$', three_hours_ahead),
    ('^time/plus/4/$', four_hours_ahead),
)
        ]]>
      </screen>
    </para>

    <para>
      Очевидно, это направление мысли является ущербным. Такой подход
      не только приведёт к избыточности функций представления, но и к
      тому, что приложение будет явно ограничено заранее заданным
      диапазоном смещений &mdash; один, два, три или четыре часа. Если
      мы решим создать страницу, которая отображает текущее время со
      смещением на <emphasis>пять</emphasis> часов вперёд, нам
      потребуется создать отдельное представление и внести
      дополнительную строчку в схему URL, продолжая создавать
      избыточность. Нам потребуется немного окунуться в теорию.

      <note>
        <title>
          Слово о красивых URL
        </title>

        <para>
          Если вы работали с другими платформами разработки
          web-приложения, такими как PHP или Java, вы можете подумать:
          <quote>Эй, давайте использовать параметр строки
          запроса!</quote> &mdash; что-нибудь аналогичное
          <token>/time/plus?hours=3</token>, в котором смещение будет
          указано через параметр <varname>hours</varname> в URL.
        </para>

        <para>
          Вы <emphasis>можете</emphasis> сделать так и с Django (и мы
          расскажем об этом в главе 7 FIXME), но Django пропагандирует
          философию использования красивых URL. URL
          <token>/time/plus/3/</token> гораздо яснее, проще, более
          читаемое, его проще сказать кому-нибудь вслух и ... просто
          проще, чем его оппонент. Красивый URL являются
          характеристикой качества web-приложения.
        </para>

        <para>
          Система схемы URL Django поощряет создание красивых URL,
          упрощая использование таких URL, в
          <emphasis>отличие</emphasis> от других.
        </para>
      </note>
    </para>

    <para>
      Как же мы должны спроектировать наше приложение для обработки
      соответствующих смещений времени? Ответ лежит в использовании
      <emphasis>шаблонов подстановки</emphasis>. Как мы упоминали
      ранее, шаблон URL является регулярным выражением. Следовательно,
      мы можем использовать шаблон <token>\d+</token> для выделения
      одной или более цифр:
      <screen>
        <![CDATA[
urlpatterns = patterns('',
    # ...
    (r'^time/plus/\d+/$', hours_ahead),
    # ...
)
        ]]>
      </screen>
    </para>

    <para>
      (Мы используем <token>#...</token>, чтобы показать, что здесь
      могут быть другие шаблоны, которые мы временно исключили из
      данного примера.)
    </para>

    <para>
      Новый шаблон схемы URL будет соответствовать любому URL,
      подобному <token>/time/plus/2/</token>,
      <token>/time/plus/25/</token> и даже
      <token>/time/plus/100000000000/</token>. Давайте ограничим
      смещение 99-ю часами. Это означает, что мы разрешаем только
      одно- или двухзначиные числа. На языке регулярных выражений это
      преобразовывается в <token>\d{1,2}</token>:
      <screen>
        <![CDATA[
(r'^time/plus/\d{1,2}/$', hours_ahead),
        ]]>
      </screen>

      <note>
        <para>
          При разработке web-приложения, важно всегда рассматривать
          наиболее диковинные варианты ввода данных и решать должно
          или нет приложение обрабатывать такой ввод. Мы ограничили
          здесь возможности ввода смещения 99-ю часами.
        </para>
      </note>
    </para>

    <para>
      Ещё одной важной деталью, которую мы ввели здесь, является
      символ <token>r</token> в начале строки регулярного
      выражения. Он указывает Python, что строка является
      <quote>сырой</quote> &mdash; в её содержимом не следует
      интерпретировать обратные слеши. В обычной строке Python,
      обратные слеши используются для экранирования особых символов,
      например, <token>\n</token> &mdash; односимвольная строка. Если
      предварить её символом <token>r</token>, сделав её
      <quote>сырой</quote>, Python не будет выполнять экранирование
      &mdash; таким образом, <token>r'\n'</token> станет
      двухсимвольной строкой, содержащей обратный слеш и символ
      <token>n</token>. Существует естественная коллизия между
      обычными обратными слешами и используемыми в регулярных
      выражениях. Крайне рекомендуется всегда использовать сырые
      строки при определении регулярных выражений в Python. С этого
      момента следует считать, что все шаблоны URL, показанные в этой
      книге, будут представлены сырыми строками.
    </para>

    <para>
      После применения символов подстановки в URL необходим способ
      передачи выделенных подстановкой данных в функцию представления,
      это позволит нам использовать единственную функцию представления
      для любого разрешённого смещения часов. Мы осуществляем это с
      помощью установки скобок вокруг интересующей нас части шаблона
      URL. В рамках нашего примера, это будет любое число в URL, таким
      образом, надо расположить скобки вокруг выражения
      <token>\d{1,2}</token>, например:
      <screen>
        <![CDATA[
(r'^time/plus/(\d{1,2})/$', hours_ahead),
        ]]>
      </screen>
    </para>

    <para>
      Если у вас уже есть опыт работы с регулярными выражениями, то
      вам будет легко. Мы используем скобки для
      <emphasis>выделения</emphasis> данных из совпавшего текста.
    </para>

    <para>
      В итоге схема URL будет выглядеть так:
      <screen>
        <![CDATA[
from django.conf.urls.defaults import *
from mysite.views import hello, current_datetime, hours_ahead

urlpatterns = patterns('',
    (r'^hello/$', hello),
    (r'^time/$', current_datetime),
    (r'^time/plus/(\d{1,2})/$', hours_ahead),
)
        ]]>
      </screen>
    </para>

    <para>
      Теперь напишем представление <function>hours_ahead</function>.

      <note>
        <title>
          Порядок разработки
        </title>

        <para>
          В данном примере мы сначала создали шаблон URL, а затем
          представление. Но в предыдущих примерах, мы сначала
          создавали представление, а затем &mdash; шаблон URL. Какой
          подход лучше?
        </para>

        <para>
          Хорошо, каждый разработчик уникален.
        </para>

        <para>
          Если вам комфортно видеть весь проект целиком, может быть
          вам будет проще создать схему URL для всего функционала
          сайта за один раз, в начале проекта, а затем реализовать
          каждую функцию представления. Такой подход имеет
          преимущество, так как предоставляет ясный список работ и, по
          сути, определяет требования к параметрам функций
          представления, которые вам потребуется реализовать.
        </para>

        <para>
          Если вам комфортно разрабатывать проект, начиная с небольших
          компонентов, может быть вы предпочтёте сначала реализовать
          представления, а затем ассоциировать их с URL. Такой подход
          тоже имеет право на жизнь.
        </para>

        <para>
          В конце концов, не важно какой из подходов лучше или
          хуже. Они оба правильные.
        </para>
      </note>
    </para>

    <para>
      Представление <function>hours_ahead</function> очень похоже на
      представление <function>current_datetime</function>, которое мы
      написали ранее, с одним только отличием: оно принимает
      дополнительный аргумент &mdash; количество часов смещения. Вот
      его код:
      <screen>
        <![CDATA[
from django.http import Http404, HttpResponse
import datetime

def hours_ahead(request, offset):
    try:
        offset = int(offset)
    except ValueError:
        raise Http404()
    dt = datetime.datetime.now() + datetime.timedelta(hours=offset)
    html = "<html><body>In %s hour(s), it will be %s.</body></html>" % (offset, dt)
    return HttpResponse(html)
        ]]>
      </screen>
    </para>

    <para>
      Рассмотрим каждую строчку этого кода:

      <itemizedlist>
        <listitem>
          <para>
            Функция представления, <function>hours_ahead</function>,
            принимает <emphasis>два параметра</emphasis>:
            <varname>request</varname> и <varname>offset</varname>.

            <itemizedlist>
              <listitem>
                <para>
                  Параметр <varname>request</varname> является
                  объектом <classname>HttpRequest</classname>,
                  аналогичным используемому в представлениях
                  <function>hello</function> и
                  <function>current_datetime</function>. Мы повторим
                  ещё раз: каждое представление
                  <emphasis>всегда</emphasis> принимает объект
                  <classname>HttpRequest</classname> в качестве
                  первого аргумента.
                </para>
              </listitem>

              <listitem>
                <para>
                  Параметр <varname>offset</varname> является строкой,
                  выделенной скобками в шаблоне URL. Например, если
                  запрошенный URL был <token>/time/plus/3/</token>,
                  тогда <varname>offset</varname> будет содержать
                  строку <token>'3'</token>. Если
                  <token>/time/plus/21/</token> &mdash; строка
                  <token>'21'</token>. Следует отметить, что
                  выделенные значения всегда будут
                  <emphasis>строками</emphasis>, не целыми, даже если
                  строка составлена только из цифр.
                </para>

                <para>
                  (Технически, захваченные значения всегда будут
                  <emphasis>объектами
                  <classname>Unicode</classname></emphasis>, а не
                  простыми строками Python, но пока об этом
                  беспокоиться не следует.)
                </para>

                <para>
                  Мы решили назвать данный параметр
                  <varname>offset</varname>, но вы можете дать ему
                  любое другое имя, главное, чтобы оно соответствовало
                  требованиям языка Python для идентификаторов. Имя
                  переменной само по себе ничего не означает. Имеет
                  значение только то, что переменная является вторым
                  аргументом функции, после
                  <varname>request</varname>. (Также можно
                  использовать ключевые параметры в схеме URL вместо
                  позиционных. Мы расскажем об этом в главе 8 FIXME.)
                </para>
              </listitem>
            </itemizedlist>

          </para>
        </listitem>

        <listitem>
          <para>
            Первое, что мы делаем в функции &mdash; вызываем
            <function>int()</function> для
            <varname>offset</varname>. Данная функция преобразовывает
            строковое значение в целое.
          </para>

          <para>
            Следует отметить, что Python вызывет исключение
            <classname>ValueError</classname>, если в процессе вызова
            <function>int()</function> данная функция не сможет
            осуществить конвертацию, например, для строки
            <token>'foo'</token>. В данном примере, если мы получим
            <classname>ValueError</classname>, мы вызовем исключение
            <classname>django.http.Http404</classname>, которое, как
            вы можете представить, возвратит страницу с ошибкой 404
            &mdash; <quote>Страница не найдена</quote>
          </para>

          <para>
            Проницательному читателю будет интересно: как мы сможем
            попасть в ветку с <classname>ValueError</classname>,
            учитывая то, что регулярное выражение в нашем шаблоне
            &mdash; <token>(\d{1,2})</token> &mdash; принимает только
            цифры и, следовательно, <varname>offset</varname> всегда
            будет состоять из строки цифр? Ответ заключается в том,
            что мы и не рассчитываем на это, так как шаблон URL
            предоставляет простой, но достаточный уровень проверки,
            <emphasis>но</emphasis> мы попрежнему проверяем значение
            на случай, если данная функция представления будет вызвана
            каким-либо другим способом. Это хороший подход &mdash;
            реализация функций представления так, как-будто им в
            параметрах может передаваться всё что угодно. Помните про
            свободное связывание?
          </para>
        </listitem>

        <listitem>
          <para>
            На следующей строке функции мы вычисляем текущую дату и
            время, а затем добавляем соответствующее число к часам. Мы
            уже встречались с
            <function>datetime.datetime.now()</function> в
            представлении
            <function>current_datetime</function>. Разница лишь в том,
            что здесь мы выполняем арифметические операции, создав
            объект <classname>datetime.timedelta</classname> и
            прибавив его к объекту
            <classname>datetime.datetime</classname>. Результат
            операции сохраняется в переменной <varname>dt</varname>.
          </para>

          <para>
            Данная строка также показывает почему мы вызываем
            <function>int()</function> для <varname>offset</varname>
            &mdash; функция <function>datetime.timedelta</function>
            требует, чтобы параметр <varname>hours</varname> содержал
            целое число.
          </para>
        </listitem>

        <listitem>
          <para>
            Затем мы создаём HTML документ для данного представления,
            аналогично тому, как это делалось в представлении
            <function>current_datetime</function>. Есть небольшое
            отличие в этой строке, от предыдущей &mdash; здесь
            используется строка форматирования с
            <emphasis>двумя</emphasis> подстановками, а не
            одной. Следовательно, строка содержит две подстановки
            <token>%s</token> и кортеж, содержащий значения:
            <token>(offset, dt)</token>..
          </para>
        </listitem>

        <listitem>
          <para>
            Наконец, мы возвращаем
            <classname>HttpResponse</classname>. Вот и всё.
          </para>
        </listitem>
      </itemizedlist>
    </para>

    <para>
      Реализовав данную функцию представления и привязав её к URL,
      запустите тестовый сервер Django (если он ещё не запущен) и
      посетите <ulink url="http://127.0.0.1:8000/time/plus/3/"/> для
      проверки работы функции. Затем попробуйте <ulink
      url="http://127.0.0.1:8000/time/plus/5/"/>. Затем <ulink
      url="http://127.0.0.1:8000/time/plus/24/"/>. Наконец, посетите
      <ulink url="http://127.0.0.1:8000/time/plus/100/"/>, чтобы
      проверить, что шаблон URL принимает только одно- или
      двухсимвольные числа. Django должна отобразить <quote>Страница
      не найдена</quote> в этом случае. <ulink
      url="http://127.0.0.1:8000/time/plus/"/>
      (<emphasis>без</emphasis> указания часов) также должен вызвать
      ошибку 404.
    </para>

  </section>

  <section id="&BASEID;.pretty-error">

    <title id="&BASEID;.pretty-error.title">
      Красивые страницы об ошибке
    </title>

    <para>
      Восхититесь созданным вами web-приложением, а теперь давайте
      сломаем его. Умышленно внесём ошибку в код представления
      <function>hours_ahead</function>, закомментировав строки
      <token>offset = int(offset)</token>:
      <screen>
        <![CDATA[
def hours_ahead(request, offset):
    # try:
    #     offset = int(offset)
    # except ValueError:
    #     raise Http404()
    dt = datetime.datetime.now() + datetime.timedelta(hours=offset)
    html = "<html><body>In %s hour(s), it will be %s.</body></html>" % (offset, dt)
    return HttpResponse(html)
        ]]>
      </screen>
    </para>

    <para>
      Запустите тестовый сервер и перейдите по ссылке <ulink
      url="http://127.0.0.1:8000/time/plus/3/"/>. Вы увидите страницу
      с ошибкой, которая будет содержать значительный объём
      информации, включая <classname>TypeError</classname> сообщение
      на самом верху:
      <screen>
        <![CDATA[
"unsupported type for timedelta hours component: unicode"
        ]]>
      </screen>
    </para>

    <para>
      Что же случилось? Как мы говорили функция
      <function>datetime.timedelta</function> ожидает, что параметр
      <varname>hours</varname> является целым числом, а мы
      закомментировали кусок кода, который выполняет это
      преобразование для <varname>offset</varname>. Это привело к
      вызову <classname>TypeError</classname> функцией
      <function>datetime.timedelta</function>. Это типичная ошибка.
    </para>

    <para>
      Целью данного примера было продемонстрировать как Django
      отображает страницы с ошибкой. Потратьте немного времени на
      изучение этой страницы и вы увидите, как много информации она
      предоставляет.
    </para>

    <para>
      Отметим следующее:
      <itemizedlist>
        <listitem>
          <para>
            Наверху страницы отображается ключевая информации об
            исключении: тип исключения; любой параметр, вызвавший его
            (в данном случае это <token>"unsupported type"</token>);
            имя файла, в котором произошло исключение и номер
            соответствующей строки в файле.
          </para>
        </listitem>

        <listitem>
          <para>
            Чуть ниже отображается полный трейс для данного
            исключения. Он аналогичен стандартному трейсу, который вы
            получаете при работе с интерпретатором командной строки,
            только этот более интерактивен. Для каждого уровня (кадра)
            стека Django отображает имя файла и имя функции/метода,
            номер строки и исходный код данной строки.
          </para>

          <para>
            Если кликнуть на строку с исходным кодом, то вы увидите
            несколько строк выше и ниже данной строки, это даст вам
            контекст ошибки.
          </para>

          <para>
            Кликните на <quote>Local vars</quote> под любым кадром
            стека для того, чтобы получить таблицу всех локальных
            переменных и их значения именно в этой точке кода. Эта
            отладочная информация бывает очень полезна.
          </para>
        </listitem>

        <listitem>
          <para>
            Обратите внимание на текст <quote>Switch to copy-and-paste
            view</quote> под заголовком
            <quote>Traceback</quote>. Нажмите на эти слова и трейс
            переключится в альтернативный вид, который может быть
            легко скопирован. Используйте эту возможность когда вам
            необходимо поделиться информацией об ошибке с другими
            разработчиками для получения технической поддержки &mdash;
            например с людьми с канала
            <token>djangobook@conference.jabber.ru</token> или в
            списке рассылки.
          </para>

          <para>
            Ниже расположенная кнопка <guibutton>Share this traceback
            on a public Web site</guibutton> сделает эту работу за
            вас. Она отправляет информацию об ошибке на сервис <ulink
            url="http://www.dpaste.com/"/>, вы получаете точный URL с
            текстом ошибки и можете передавать его другим
            разработчикам.
          </para>
        </listitem>

        <listitem>
          <para>
            Секция <quote>Request information</quote> содержит
            информацию о пришедшем web-запросе, который вызвал ошибку:
            GET и POST информация, значения cookie и такая мета
            информация, как CGI заголовки.
          </para>

          <para>
            Под секцией <quote>Request information</quote> расположена
            секция <quote>Settings</quote> со списком всех настроек
            для данного проекта. (Мы уже упоминали
            <token>ROOT_URLCONF</token> и мы покажем различные
            параметры в течение книги.)
          </para>
        </listitem>
      </itemizedlist>
    </para>

    <para>
      Страница с ошибкой имеет возможность отображать ещё больше
      информации в особых случаях, например, в случаях ошибки в
      синтаксисе шаблона. Мы рассмотрим это позже, когда будем
      обсуждать шаблонную систему Django. А сейчас, раскомментируйте
      строки представления <function>hours_ahead</function>, чтобы она
      смогла работать правильно.
    </para>

    <para>
      Вы являетесь разработчиком, которому нравится производить
      отладку кода с помощью оператора <token>print</token>? Вы можете
      использовать для этого страницу ошибки Django &mdash; без всяких
      <token>print</token>. Вставьте на время в любой точке вашего
      представления оператор <token>assert False</token> &mdash; это
      вызовет отображение ошибки. Затем, вы можете просмотреть
      локальные переменные и состояние программ. Ниже дан пример
      использования этого подхода в представлении
      <function>hours_ahead</function>:
      <screen>
        <![CDATA[
def hours_ahead(request, offset):
    try:
        offset = int(offset)
    except ValueError:
        raise Http404()
    dt = datetime.datetime.now() + datetime.timedelta(hours=offset)
    assert False
    html = "<html><body>In %s hour(s), it will be %s.</body></html>" % (offset, dt)
    return HttpResponse(html)
        ]]>
      </screen>
    </para>

    <para>
      Очевидно, что большая часть данной информации не стоит
      показывать всем &mdash; она рассказывает о вашем коде и
      настройках Django &mdash; будет глупо отображать её всему
      Internet. Какой-нибудь отрицательный персонаж может
      воспользоваться ей для изучения вашего web-приложения и
      осуществления своих зловредных планов. По этой причине Django
      отображает страницу с ошибкой только когда находится в режиме
      отладки. Мы объясним позже как деактивировать отладочный режим в
      главе <quote><xref linkend="djangobook.chap12"
      endterm="djangobook.chap12.title"/></quote>. Просто запомните,
      что после создания проект находится в режиме отладки.
    </para>

  </section>

</chapter>
