<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
"http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd"
[
<!ENTITY BASEID "djangobook.chap06">
]>

<chapter lang="ru" id="&BASEID;">

  <title id="&BASEID;.title">
    Интерфейс администратора Django
  </title>

  <para>
    Перевод &copy; Дмитрий aka Alerion &lt;alerion.um &bull; gmail&gt;
  </para>

  <para>
    Корректура &copy; Попов Руслан &lt;ruslan.popov &bull; gmail&gt;
  </para>

  <para>
    Для определённого класса веб-сайтов <emphasis>интерфейс
    администратора</emphasis> является важной частью проекта. Это
    веб-интерфейс, доступный администраторам сайта, который
    предоставляет возможность добавления, редактирования и удаления
    содержимого сайта. Приведём типичные примеры: интерфейс для
    создания сообщений в Вашем блоге; интерфейс менеджера для
    модерирования комментариев посетителей сайта; инструмент, который
    используют ваши клиенты для обновления пресс-релизов на сайте,
    который вы для них создали.
  </para>

  <para>
    Есть небольшая проблема с интерфейсами администратора &mdash; их
    скучно создавать. Веб-разработка интересна, когда вы создаёте
    внешнюю функциональность, а в интерфейсе администратора всё
    однообразно. Вы должны авторизировать пользователя, отображать и
    обрабатывать формы, проверять входящие данные и так далее. Это
    скучно и однообразно.
  </para>

  <para>
    Как Django предлагает решать эти скучные и однообразные задачи?
    Она делает всё за вас &mdash; всего несколькими строками кода, не
    более. С Django создание интерфейса администратора &mdash; решёная
    проблема.
  </para>

  <para>
    Данная глава посвящена автоматическому интерфейсу администратора.
    Получая метаданные из ваших моделей, он предоставляет мощный
    интерфейс промышленного уровня, который может быть немедленно
    использован для наполнения сайта информацией. Далее, мы рассмотрим
    как активировать, использовать и настраивать интерфейс
    администратора.
  </para>

  <para>
    Мы рекомендуем прочитать этот раздел, даже если вы не намерены
    использовать интерфейс администратора Django, потому что мы вводим
    несколько концепций, которые применимы ко всем компонентам Django.
  </para>

  <section id="&BASEID;.django_contrib">

    <title id="&BASEID;.django_contrib.title">
      Пакеты django.contrib
    </title>

    <para>
      Автоматический интерфейс администратора является частью большой
      библиотеки кода, называемой <token>django.contrib</token>
      &mdash; часть кода Django, включающего различные полезные
      дополнения к ядру Django. Рассматривайте
      <token>django.contrib</token> для Django в качестве аналога
      стандартных библиотек Python &mdash; необязательный, но очень
      полезный функционал для решения общих задач. Он поставляется в
      комплекте с Django, поэтому вам не нужно заново <quote>создавать
      велосипед</quote> в ваших приложениях.
    </para>

    <para>
      Интерфейс администратора является первой частью
      <token>django.contrib</token>, которую мы рассмотрим в книге. В
      общем, она называется <token>django.contrib.admin</token>.
      Другими частями <token>django.contrib</token> являются система
      авторизации (<token>django.contrib.auth</token>), поддержка
      анонимных сессий (<token>django.contrib.sessions</token>), а
      также систему пользовательских комментариев
      (<token>django.contrib.comments</token>).  Изучая различные
      возможности <token>django.contrib</token>, вы становитесь
      экспертом в Django. Более подробно данный пакет будет рассмотрен
      в главе <xref linkend="djangobook.chap16"
      endterm="djangobook.chap16.title"/>. Просто имейте в виду, что
      Django поставляется со множеством интересных дополнений, которые
      в основном находятся в <token>django.contrib</token>.
    </para>

  </section>

  <section id="&BASEID;.activate">

    <title id="&BASEID;.activate.title">
      Активация интерфейса администратора
    </title>

    <para>
      Интерфейс администратора Django совсем не обязателен, потому что
      только определённые типы сайтов требуют наличия данной
      функциональности. Поэтому вы должны выполнить несколько шагов
      для активации интерфейса для вашего проекта.
    </para>

    <para>
      Сначала внесите изменения в файле настроек:

      <orderedlist>
	    <listitem>
	      <para>
	        Добавим <token>django.contrib.admin</token> в параметр
	        <varname>INSTALLED_APPS</varname>. (Порядок элементов в
	        <varname>INSTALLED_APPS</varname> не имеет значения, но мы
	        советуем содержать их в алфавитном порядке, для удобства
	        чтения.)
          </para>
        </listitem>

        <listitem>
          <para>
            Убедитесь, что <varname>INSTALLED_APPS</varname> содержит
            <token>django.contrib.auth</token>,
            <token>django.contrib.sessions</token> и
            <token>django.contrib.contenttypes</token>. Интерфейс
            администратора требует подключение этих трёх
            пакетов. (Если вы следуете нашим инструкциям относительно
            проекта <token>mysite</token>, вспомните, что мы
            закомментировали эти три пакета в главе <quote><xref
            linkend="djangobook.chap05"
            endterm="djangobook.chap05.title"/></quote>. Раскомментируйте
            их сейчас.)
          </para>
        </listitem>

        <listitem>
          <para>
            Убедитесь, что <varname>MIDDLEWARE_CLASSES</varname>
            содержит
            <token>django.middleware.common.CommonMiddleware</token> и
            <token>django.contrib.sessions.middleware.SessionMiddleware</token>
            а также
            <token>django.contrib.auth.middleware.AuthenticationMiddleware</token>. (И
            снова вам потребуется расскомментировать эти строчки для
            проекта <token>mysite</token>.)
          </para>
        </listitem>
      </orderedlist>
    </para>

    <para>
      Теперь выполните команду <command>python manage.py
      syncdb</command>.  Она установит дополнительные таблицы в базу
      данных, которые будет использовать интерфейс администратора. При
      первом запуске <command>syncdb</command> при наличии
      <token>django.contrib.auth</token> в
      <varname>INSTALLED_APPS</varname>, у вас спросят о необходимости
      создания суперпользователя. Если вы его не создадите, то позже
      для его создания вам потребуется выполнить <command>python
      manage.py createsuperuser</command>.  В противном случае вы не
      сможете войти в интерфейс администратора.
    </para>

    <para>
      Теперь добавим административную часть в схему URL (в файл
      <filename>urls.py</filename>, помните?).  По-умолчанию,
      <filename>urls.py</filename> созданый с помощью
      <command>django-admin.py startproject</command>, содержит
      закомментированный код для административного интерфейса Django,
      и вам потребуется раскомментировать его. Вот, что там должно
      быть:
      <screen>
        <![CDATA[
# Include these import statements...
from django.contrib import admin
admin.autodiscover()

# And include this URLpattern...
urlpatterns = patterns('',
    # ...
    (r'^admin/', include(admin.site.urls)),
    # ...
)
        ]]>
      </screen>
    </para>

    <para>
      После этих несложных настроек, вы можете увидеть интерфейс
      администратора в действии. Запустите тестовый сервер
      (<command>python manage.py runserver</command>, как и в
      предыдущих главах) и перейдите по ссылке <ulink
      url="http://127.0.0.1:8000/admin/"/>.
    </para>

  </section>

  <section id="&BASEID;.use">

    <title id="&BASEID;.use.title">
      Использование интерфейса администратора
    </title>

    <para>
      Интерфейс администратора предназначен для использования
      неквалифицированными пользователями и, следовательно, он должен
      быть самодостаточным. Тем не менее, сделаем несколько замечаний
      по свойствам интерфейса.
    </para>

    <para>
      Первым, что вы увидите, будет экран с формой аутентификации,
      показанный на рисунке <quote><xref linkend="&BASEID;.pic1"
      endterm="&BASEID;.pic1.title"/></quote>.
    </para>

    <para>
      <figure id="&BASEID;.pic1" float="0">
        <title id="&BASEID;.pic1.title">
          Форма аутентификации администратора
        </title>
        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="pics/login.png" format="PNG"/>
            </imageobject>
          </mediaobject>
        </screenshot>
      </figure>
    </para>

    <para>
      Следует использовать логин и пароль, которые вы указали при
      создании администратора. Если вы не можете войти, убедитесь что
      вы на самом деле создали суперпользователя &mdash; попробуйте
      выполнить <command>python manage.py createsuperuser</command>.
    </para>

    <para>
      После того, как вы войдёте в систему, вы увидите домашнюю
      страницу административного интерфейса. Эта страница отображает
      все возможные типы объектов, с которыми вы можете работать.  Так
      как мы не активировали ни одной собственной модели, список
      выглядит пустым &mdash; он содержит только <quote>Группы</quote> и
      <quote>Пользователей</quote>, которые по-умолчанию доступны для
      редактирования.
    </para>

    <para>
      <figure id="&BASEID;.pic2" float="0">
        <title id="&BASEID;.pic2.title">
          Главная страница интерфейса администратора
        </title>
        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="pics/admin_index.png" format="PNG"/>
            </imageobject>
          </mediaobject>
        </screenshot>
      </figure>
    </para>

    <para>
      Каждый тип обьектов в интерфейсе администратора обладает
      <emphasis>формой редактирования</emphasis> и <emphasis>списком
      обьектов</emphasis>. Список объектов отображает все доступные
      обьекты в базе данных, а форма редактирования позволяет
      добавлять, изменять и удалять конкретные записи.

      <note>
        <title>
          Прочие языки
        </title>

        <para>
          Если английский не является вашим основным языком, вы можете
          легко настроить интерфейс администратора на отображение
          информации на нужном вам языке. Для это в конфигурационном
          файле добавьте
          <token>django.middleware.locale.LocaleMiddleware</token> в
          <varname> MIDDLEWARE_CLASSES</varname>. Убедитесь что оно
          следует <emphasis>после</emphasis>
          <token>django.contrib.sessions.middleware.SessionMiddleware</token>.
        </para>

        <para>
          После этого перегрузите главную страницу административного
          интерфейса.  Если присутствует перевод для вашего языка,
          различные части интерфейса &mdash; от названий ссылок
          <quote>Сменить пароль</quote> и <quote>Выйти</quote> в
          верхней части страницы до <quote>Группы</quote> и
          <quote>Пользователи</quote> &mdash; отобразятся на вашем
          языке вместо английского. Django поставляется с переводом
          интерфейса на десятки языков.
        </para>

        <para>
          Подробнее многоязычность в Django рассмотрена в главе
          <quote><xref linkend="djangobook.chap19"
          endterm="djangobook.chap19.title"/></quote>.
        </para>
      </note>
    </para>

    <para>
      Нажмите на ссылку <quote>Изменить</quote> в строке
      <quote>Пользователи</quote>, чтобы загрузить страницу со списком
      пользователей.
    </para>

    <para>
      <figure id="&BASEID;.pic3" float="0">
        <title id="&BASEID;.pic3.title">
          Стандартный вид списка изменений
        </title>
        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="pics/changelist.png" format="PNG"/>
            </imageobject>
          </mediaobject>
        </screenshot>
      </figure>
    </para>

    <para>
      Эта страница отображает всех пользователей в базе данных. Можно
      рассматривать этот список в качестве красивого аналога
      SQL-запроса <token>SELECT * FROM auth_user;</token>. Если вы
      следовали нашим указаниям, вы увидите только одного
      пользователя, но при добавлении новых, все они будут
      отображаться на этой странице. На странице вы найдёте такие
      полезные вещи как: фильтрация, сортировка и поиск.  Варианты
      фильтрации находятся справа, сортировка доступна при нажатии на
      заголовок столбца, а поле поиска вверху позволяет искать
      пользователей по имени.
    </para>

    <para>
      Нажмите на имя пользователя, которого вы создали, и вы увидете
      страницу редактирования.
    </para>

    <para>
      <figure id="&BASEID;.pic4" float="0">
        <title id="&BASEID;.pic4.title">
          Форма редактирования пользователя
        </title>
        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="pics/editform.png" format="PNG"/>
            </imageobject>
          </mediaobject>
        </screenshot>
      </figure>
    </para>

    <para>
      Эта страница позволяет изменять параметры пользователя, такие
      как имя, фамилия, права и другие. (Для редактирования пароля вам
      следует перейти по ссылке <quote>Изменить пароль</quote> под
      полем пароля, вместо того, чтобы редактировать хэш). Следует
      отметить, что разные типы полей имеют разное отображение
      (виджеты) &mdash; например, поля даты/времени будут управляться
      через календарь, булево поле &mdash; чекбокс, текстовое поле
      &mdash; обычное поле ввода.
    </para>

    <para>
      Вы можете удалить запись, нажав на кнопку <quote>Удалить</quote>
      в левом нижем углу на странице редактирования этой записи. Вы
      перейдёте на страницу подтверждения удаления, которая, в
      некоторых случаях, отобразит связанные обьекты, которые также
      будут удалены. (Например, если вы удалите издателя, книги этого
      издателя также будут удалены!).
    </para>

    <para>
      Вы можете добавить запись нажав на кнопку
      <quote>Добавить</quote> в надлежашей колонке на главной странице
      административного интрефейса. Вы увидите пустой вариант страницы
      для редактирования, готовой для заполнения данными.
    </para>

    <para>
      Вы увидите, что интерфейс администратора выполняет проверку
      пользовательского ввода. Попробуйте оставить пустыми поля,
      которые требуется заполнять, или введите неверное время в поле
      времени и вы увидите соответствующие сообщения об ошибках при
      попытке сохранить форму.
    </para>

    <para>
      <figure id="&BASEID;.pic5" float="0">
        <title id="&BASEID;.pic5.title">
          Форма редактирования с ошибками
        </title>
        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="pics/editform_errors.png" format="PNG"/>
            </imageobject>
          </mediaobject>
        </screenshot>
      </figure>
    </para>

    <para>
      При редактировании существующего объекта обратите внимание на
      ссылку <quote>История</quote> в верхнем правом углу окна. Каждое
      изменение, произведённое через интерфейс администратора,
      сохраняется в журнале. Доступ к журналу изменений производится
      нажатием на ссылку <quote>История</quote>.
    </para>

    <para>
      <figure id="&BASEID;.pic6" float="0">
        <title id="&BASEID;.pic6.title">
          Страница изменений объекта
        </title>
        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="pics/history.png" format="PNG"/>
            </imageobject>
          </mediaobject>
        </screenshot>
      </figure>
    </para>

  </section>

  <section id="&BASEID;.addmodel">

    <title id="&BASEID;.addmodel.title">
      Добавление ваших моделей на интерфейс администратора
    </title>

    <para>
      Есть одна важная часть, которую мы ещё не сделали. Давайте
      добавим наши модели в интерфейс администратора, что бы мы могли
      добавлять, редактировать и удалять объекты в наших таблицах с
      помощью этого изящного интерфейса. Продолжим наш пример с
      книгами из главы <quote><xref linkend="djangobook.chap05"
      endterm="djangobook.chap05.title"/></quote>, в которой мы создали
      три модели: <token>Publisher</token>, <token>Author</token> и
      <token>Book</token>.
    </para>

    <para>
      В каталоге <filename>books</filename>
      (<token>mysite/books</token>) создайте файл
      <filename>admin.py</filename> и добавьте в него следущие строки:
      <screen>
        <![CDATA[
from django.contrib import admin
from mysite.books.models import Publisher, Author, Book

admin.site.register(Publisher)
admin.site.register(Author)
admin.site.register(Book)
        ]]>
      </screen>
      Этот код указывает Django предоставлять интерфейс для каждой из
      перечисленных моделей.
    </para>

    <para>
      После этого перейдите на домашнюю страницу административной
      части (<ulink url="http://127.0.0.1:8000/admin/"/>), вы должны
      увидеть раздел <quote>Books</quote> с ссылками на
      <token>Authors</token>, <token>Books</token> и
      <token>Publishers</token>. (Возможно потребуется остановить и
      запустить тестовый сервер, чтобы сделанные изменения вступили в
      силу.)
    </para>

    <para>
      Теперь у вас есть полнофункциональный интерфейс администратора
      для этих моделей. Это было не так сложно!
    </para>

    <para>
      Добавьте и отредактируйте записи для наполнения вашей базы
      данных данными.  Если вы следовали примерам создания объектов
      <token>Publisher</token>, которые были даны в главе <quote><xref
      linkend="djangobook.chap05"
      endterm="djangobook.chap05.title"/></quote> (и не удалили их), вы
      увидите их записи на странице списка объектов модели.
    </para>

    <para>
      Следует упомянуть то, что интерфейс администратора обрабатывает
      внешние ключи и связь многие-ко-многим, которые присутствуют в
      модели <classname> Book</classname>. Вспомним как выглядит
      модель <classname>Book</classname>:
      <screen>
        <![CDATA[
class Book(models.Model):
    title = models.CharField(max_length=100)
    authors = models.ManyToManyField(Author)
    publisher = models.ForeignKey(Publisher)
    publication_date = models.DateField()

    def __unicode__(self):
        return self.title
        ]]>
      </screen>
    </para>

    <para>
      На странице <quote>Добавить книгу</quote>
      (<ulink url="http://127.0.0.1:8000/admin/books/book/add/"/>),
      издатель (<token>ForeignKey</token>) представлен выпадающим
      списком, а автор (<token>ManyToManyField</token>) представлен
      выпадающим списком с множественным выбором. Рядом с этими полями
      находится иконка зелёного цвета с изображением плюса, которая
      позволяет добавлять связаные обьекты соответствующего
      типа. Например, если нажать на иконку возле
      поля <quote>Издатель</quote>, появится дополнительное окно,
      позволяющее добавить издателя. После того, как вы успешно
      добавите издателя в этом окне, в форме добавления книги
      добавится созданый издатель. Красиво.
    </para>

  </section>

  <section id="&BASEID;.how-does-it-work">

    <title id="&BASEID;.how-does-it-work.title">
      Как работает интерфейс администратора
    </title>

    <para>
      Как же работает интерфейс администратора? Всё очень просто.
    </para>

    <para>
      Когда Django загружает схему URL из <filename>urls.py</filename>
      при старте сервера, выполняется функция
      <token>admin.autodiscover()</token>, которую мы добавили для
      активации интерфейса администрации. Эта функция проходит по
      элементам параметра <varname>INSTALLED_APPS</varname> и
      проверяет наличие <filename>admin.py</filename> в каждом
      установленом приложении.  Если <filename>admin.py</filename>
      присутствует, выполняется его код.
    </para>

    <para>
      В <filename>admin.py</filename> нашего приложения
      <token>books</token>, каждый вызов
      <token>admin.site.register()</token> регистрирует указаную
      модель в интерфейсе администратора, предоставляя возможность
      управлять содержимым модели.
    </para>

    <para>
      Приложение <token>django.contrib.auth</token> имеет свой
      собственный файл <token>admin.py</token> &mdash; именно поэтому
      <quote>Пользователи</quote> и <quote>Группы</quote>
      автоматически отображаются на интерфейсе администратора. Другие
      приложения <token>django.contrib</token>, например
      <token>django.contrib.redirects</token> также автоматически
      добавляют свои модели в интерфейс администратора, так же как и
      множество сторонних приложений Django, которые вы можете
      загрузить из интернета.
    </para>

    <para>
      Несмотря на всё это, административный интерфейс является всего
      навсего простым приложением Django, со своими собственными
      моделями, шаблонами, представлениями и схемой URL. Вы добавляете
      его в свой проект через подключение в схему URL, аналогично
      добавлению своих представлений. Вы можете изучить его шаблоны,
      представления и схему URL, просмотрев в каталог
      <filename>django/contrib/admin</filename> вашей копии кода
      Django, но не пытайтесь поменять что-то непосредственно там,
      есть много возможностей настроить интерфейс
      администратора. (Если вы решили изучить приложение
      административного интерфейса, учтите, что оно производит
      достаточно сложные операции с метаданными моделей, поэтому
      понадобится много времени, чтобы разобраться в нём.)
    </para>

  </section>

  <section id="&BASEID;.optional-field">

    <title id="&BASEID;.optional-field.title">
      Делаем поля необязательными
    </title>

    <para>
      После того, как вы познакомились с интерфейсом администратора,
      вы наверное заметили ограничение &mdash; форма редактирования
      требует, что бы каждое поле было заполнено, тогда как вы хотели,
      чтобы некоторые поля были необязательными. Например, мы желаем,
      чтобы поле <token>email</token> модели
      <classname>Author</classname> было необязательным, то есть оно
      могло принимать пустую строку. В реальности, возможно, вам не
      потребуется хранить адреса электронной почты всех авторов.
    </para>

    <para>
      Чтобы указать, что поле <token>email</token> является
      необязательным нужно изменить модель
      <classname>Author</classname> (которая, как вы помните из главы
      <quote><xref linkend="djangobook.chap05"
      endterm="djangobook.chap05.title"/></quote>, находится в
      <token>mysite/books/models.py</token>). Просто добавьте
      <token>blank=True</token> к полю <token>email</token>:
      <screen>
        <![CDATA[
class Author(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=40)
    email = models.EmailField(blank=True)
        ]]>
      </screen>
      Это указывает Django, что поле адреса электронной почты может
      быть пустым. По-умолчанию, все поля имеют
      <token>blank=False</token> &mdash; это означает, что поля не
      могут быть пустыми.
    </para>

    <para>
      Здесь происходит кое что интересное. До сих пор, за исключением
      метода <function>__unicode__</function>, модели рассматривались
      в качестве представления таблиц в базе данных &mdash;
      по-существу отображением SQL-запроса <token>CREATE
      TABLE</token>. Добавив <token>blank=True</token> мы приступили
      к расширению нашей модели за рамки простого представления
      таблицы в базе данных. Теперь наша модель начала превращаться в
      более сложное представление о структуре данных модели
      <classname>Author</classname> и о том, что она может
      делать. Теперь поле <token>email</token> является не только
      полем типа <token>VARCHAR</token> в базе данных, но и
      необязательным в контексте административного интерфейса.
    </para>

    <para>
      После того, как вы добавили <token>blank=True</token>, обновите
      страницу <quote>Добавить автора</quote> (<ulink
      url="http://127.0.0.1:8000/admin/books/author/add/"/>) и вы
      заметите, что поле <quote>Email</quote>, больше не выделено
      жирным шрифтом. Это означает, что оно является
      необязательным. Теперь вы можете добавить автора, оставив поле
      <quote>Email</quote> пустым, и вы больше не увидите
      ярко-красного сообщения <quote>Поле обязательно</quote>.
    </para>

    <section id="&BASEID;;.optional-field.date">

      <title id="&BASEID;;.optional-field.date.title">
        Необязательные числовые поля и поля с датой
      </title>

      <para>
        Особо надо отметить использование <token>blank=True</token>
        совместно с полями даты/времени и численными. Погрузимся в
        теорию.
      </para>

      <para>
        SQL обладает собственным способом представления пустых
        значений &mdash; специальное значение <token>NULL</token>.
        <token>NULL</token> может обозначать
        <quote>неизвестное</quote> или <quote>неверное</quote>, или
        какое-то другое конкретное значение.
      </para>

      <para>
        В SQL значение <token>NULL</token> отличается от пустой
        строки, так же как и в Python специальный объект
        <token>None</token> отличается от пустой строки
        (<token><quote></quote></token>). Это значит, что некоторые
        типы полей (например, <token>VARCHAR</token>) могут содержать
        как <token>NULL</token>, так и пустые строки.
      </para>

      <para>
        Это может вызвать нежелательную путаницу и неопределённость:
        <quote>Почему эта запись содержит <token>NULL</token>, а
        следующая пустую строку? В чём разница? Или данные просто были
        ошибочно введены?</quote> И: <quote>Как мне получить все
        записи с пустым полем &mdash; следует ли искать записи с
        пустой строкой и с <token>NULL</token>, или учитывать только
        пустую строку?</quote>
      </para>

      <para>
        Что бы избежать подобной путаницы, Django автоматически
        создает операторы <token>CREATE TABLE</token> (которые
        рассматривались в главе <quote><xref
        linkend="djangobook.chap05"
        endterm="djangobook.chap05.title"/></quote>), добавляя явно
        <token>NOT NULL</token> к каждому поля. Например,
        сгенерированый запрос создания таблицы для модели
        <classname>Author</classname>:
        <screen>
          <![CDATA[
CREATE TABLE "books_author" (
    "id" serial NOT NULL PRIMARY KEY,
    "first_name" varchar(30) NOT NULL,
    "last_name" varchar(40) NOT NULL,
    "email" varchar(75) NOT NULL
);
          ]]>
        </screen>
      </para>

      <para>
        В большинстве случаев, такое стандартное поведение является
        оптимальным для вашего приложения и избавит вас от проблем,
        вызванных несоответствием данных. И оно отлично работает с
        остальными компонентами Django: такими как административный
        интерфейс, который вставляет пустую строку (а
        <emphasis>не</emphasis> значение <token>NULL</token>), если вы
        оставляете символьное поле пустым.
      </para>

      <para>
        Исключением являются поля базы данных, для которых пустая
        строка является недопустимым значением &mdash; например, поля
        даты, времени, числовые. Если вы попытаетесь добавить пустую
        строку в поле даты или целочисленное поле, скорее всего вы
        получите ошибку, в зависимости от типа базы данных, которую вы
        используете. (PostgreSQL, являясь строгим, вернет исключение;
        MySQL может принять или нет, в зависимости от используемой
        версии, времени дня и фазы луны.) В таких случаях,
        <token>NULL</token> является единственным вариантом
        определения пустого значения. В моделях Django, вы можете
        указать, что поле допускает значения <token>NULL</token>,
        добавив параметр <token>null=True</token> в определение поля.
      </para>

      <para>
        Так вот к чему мы ведём: если вы хотите разрешить пустые
        значения для полей даты(таких как,
        <classname>DateField</classname>,
        <classname>TimeField</classname>,
        <classname>DateTimeField</classname>) или числовых полей(
        <classname>IntegerField</classname>,
        <classname>DecimalField</classname>,
        <classname>FloatField</classname>), вы должны использовать и
        <token>blank=True</token>, <emphasis>и</emphasis>
        <token>null=True</token>.
      </para>

      <para>
        Для примера, изменим модель <classname>Book</classname>,
        разрешив пустое значение для поля
        <token>publication_date</token>. Вот так вот будет выглядеть
        наша модель:
        <screen>
          <![CDATA[
class Book(models.Model):
    title = models.CharField(max_length=100)
    authors = models.ManyToManyField(Author)
    publisher = models.ForeignKey(Publisher)
    publication_date = models.DateField(blank=True, null=True)
          ]]>
        </screen>
      </para>

      <para>
        Добавление <token>null=True</token> является более сложным,
        чем добавление <token>blank=True</token>, потому что
        <token>null=True</token> изменяет структуру базы данных
        &mdash; то есть, изменяет оператор <token>CREATE
        TABLE</token>, убирая <token>NOT NULL</token> у поля
        <token>publication_date</token>. Чтобы завершить изменение, вы
        должны обновить структуру таблицы в базе данных.
      </para>

      <para>
        По ряду причин Django не пытается автоматизировать изменение
        структуры базы данных, так что ответственность за выполнение
        соответствующих запросов <token>ALTER TABLE</token> ложится на
        вас всякий раз, когда вы вносите подобные изменения в
        модель. Напомним, что вы можете использовать команду
        <command>manage.py dbshell</command>, чтобы войти в оболочку
        сервера базы данных. Вот запрос для внесения изменений,
        которые мы совершили:
        <screen>
          <![CDATA[
ALTER TABLE books_book ALTER COLUMN publication_date DROP NOT NULL;
          ]]>
        </screen>
        (Обратите внимание, что такой синтаксис специфичен для
        PostgreSQL.)
      </para>

      <para>
        Изменения структуры базы данных более детально мы рассмотрим в
        главе <quote><xref linkend="djangobook.chap10"
        endterm="djangobook.chap10.title"/></quote>.
      </para>

      <para>
        Завершив изменения, вернёмся к интерфейсу
        администратора. Теперь форма редактирования книги позволяет
        оставляеть пустой дату публикации.
      </para>

    </section>

  </section>

  <section id="&BASEID;.labels">

    <title id="&BASEID;.labels.title">
      Настройка меток полей
    </title>

    <para>
      На форме редактирования в интерфейсе администратора каждая метка
      поля создаётся на основе имён полей модели. Алгоритм простой:
      Django просто заменяет символы подчеркивания на пробелы и делает
      первую букву заглавной, например, поле
      <token>publication_date</token> модели
      <classname>Book</classname> будет иметь метку <quote>Publication
      date</quote>.
    </para>

    <para>
      Тем не менее, автоматическое преобразование имени поля в текст
      метки не всегда приводит к удовлетворительному результату,
      поэтому хотелось бы иметь возможность настраивать их
      самостоятельно. Вы можете это сделать, указав параметр
      <token>verbose_name</token> для соответствующего поля модели.
    </para>

    <para>
      Например, ниже показано как мы можем изменить метку для поля
      <varname>Author.email</varname> на <quote>e-mail</quote>:
      <screen>
        <![CDATA[
class Author(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=40)
    email = models.EmailField(blank=True, verbose_name='e-mail')
        ]]>
      </screen>
      Сделав это изменение и перезапустив сервер, вы увидите новую
      метку на форме редактирования автора.
    </para>

    <para>
      Следует отметить, что не нужно делать первую букву заглавной,
      если слово не пишется <emphasis>всегда</emphasis> с
      заглавной (например, <quote>USA state</quote>). Django при
      необходимости самостоятельно сделает первую букву заглавной, и
      оставит <varname>verbose_name</varname> без изменения, где
      заглавная буква не нужна.
    </para>

    <para>
      Наконец, отметим, что вы можете передавать <varname>verbose_name
      </varname> как позиционный аргумент &mdash; более компактный
      синтаксис. Этот пример эквивалентен предыдущему:
      <screen>
        <![CDATA[
class Author(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=40)
    email = models.EmailField('e-mail', blank=True)
        ]]>
      </screen>
      Такой вариант не подходит для полей
      <classname>ManyToManyField</classname> и
      <classname>ForeignKey</classname>, потому что для них первым
      аргументом должна быть модель. Для этих случаев следует явно
      указывать аргумент <token>verbose_name</token>.
    </para>

  </section>

  <section id="&BASEID;.modeladmin">

    <title id="&BASEID;.modeladmin.title">
      Собственные классы ModelAdmin
    </title>

    <para>
      Изменения, которые мы сделали ранее &mdash;
      <token>null=True</token>, <token>blank=True</token> и
      <varname>verbose_name</varname> &mdash; являются изменениями на
      уровне модели, а не на уровне интерфейса администратора. То
      есть, эти изменения являются фундаментальной частью модели,
      интерфейс администратора Django просто использует их, и в них
      ничего специфического для административного интерфейса нет.
    </para>

    <para>
      Помимо этого, интерфейс администратора предоставляет множество
      возможностей настроить его работу для конкретной модели. Эти
      настройки реализуются с помощью классов
      <classname>ModelAdmin</classname>.
    </para>

    <section id="&BASEID;.modeladmin.changelist">

      <title id="&BASEID;.modeladmin.changelist.title">
        Настройка списка редактирования
      </title>

      <para>
        Давайте погрузимся в настройку интерфейса, определив поля,
        которые будут отображатся в списке редактирования для нашей
        модели <classname>Author</classname>.  По-умолчанию, в списке
        изменения отображается результат выполнения метода
        <token>__unicode__()</token> для каждого объекта модели. В
        главе <quote><xref linkend="djangobook.chap05"
        endterm="djangobook.chap05.title"/></quote> мы определили
        метод <token>__unicode__()</token> для модели
        <classname>Author</classname> так, чтобы он возвращал имя и
        фамилию:
        <screen>
          <![CDATA[
class Author(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=40)
    email = models.EmailField(blank=True, verbose_name='e-mail')

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)
          ]]>
        </screen>
        В результате список изменения обьектов
        <classname>Author</classname> отображает имя и фамилию вместе,
        вы можете это увидеть на рисунке <quote><xref
        linkend="&BASEID;.pic7"
        endterm="&BASEID;.pic7.title"/></quote>:
      </para>

      <para>
        <figure id="&BASEID;.pic7" float="0">
          <title id="&BASEID;.pic7.title">
            Страница списка редактирования авторов
          </title>
          <screenshot>
            <mediaobject>
              <imageobject>
                <imagedata fileref="pics/waiting_for.png" format="PNG"/>
              </imageobject>
            </mediaobject>
          </screenshot>
        </figure>
      </para>

      <para>
        Мы можем изменить это стандартное поведение, добавив в список
        дополнительные поля. Было бы удобно, например, если бы на этой
        странице отображался адрес электронной почты автора и можно
        было сортировать по имени и фамилии.
      </para>

      <para>
        Чтобы это реализовать определим класс
        <classname>ModelAdmin</classname> для модели
        <classname>Author</classname>. Этот класс является ключём к
        настройке интерфейса администратора и самое простое, что он
        может &mdash; это определить список полей, которые будут
        отображаться на странице списка редактирования. Приведём
        <filename>admin.py</filename> к следующему виду:
        <screen>
          <![CDATA[
from django.contrib import admin
from mysite.books.models import Publisher, Author, Book

class AuthorAdmin(admin.ModelAdmin):
    list_display = ('first_name', 'last_name', 'email')

admin.site.register(Publisher)
admin.site.register(Author, AuthorAdmin)
admin.site.register(Book)
          ]]>
        </screen>
      </para>

      <para>
        Вот, что мы сделали:

        <orderedlist>
          <listitem>
            <para>
              Мы создали класс <classname>AuthorAdmin</classname>.
              Этот класс, унаследованый от
              <token>django.contrib.admin.ModelAdmin</token>, содержит
              настройки для конкретной модели в интерфейсе
              администратора. Мы изменили только одну настройку
              &mdash; <token>list_display</token>, назначив ей кортеж
              с именами полей, которые будут отображаться на странице
              списка редактирования. Естественно, модель должна
              содержать перечисленные поля.
            </para>
          </listitem>

          <listitem>
            <para>
              Мы изменили вызов <token>admin.site.register()</token>,
              добавив <classname>AuthorAdmin</classname> после
              <classname>Author</classname>. Это можно прочитать как:
              <quote>Зарегистрировать модель
              <classname>Author</classname> с настройками
              <classname>AuthorAdmin</classname></quote>.
            </para>

            <para>
              Функция <function>admin.site.register()</function>
              принимает унаследованый от
              <classname>ModelAdmin</classname> класс, как
              необязательный аргумент. Если вы не указали второй
              аргумент(как в случае с <classname>Book</classname> и
              <classname>Publisher</classname>), Django будет
              использовать настройки по-умолчанию для этой модели.
            </para>
          </listitem>
        </orderedlist>
      </para>

      <para>
        Внеся новые настройки, обновляем страницу списка
        редактирования авторов, и вы увидите, что на странице теперь
        отображается три колонки &mdash; имя, фамилия и
        email-адресс. К тому же, можно производить сортировку по
        колонкам с помощью нажатия на их заголовок. (См. рисунок
        <quote><xref linkend="&BASEID;.pic8"
        endterm="&BASEID;.pic8.title"/></quote>):
      </para>

      <para>
        <figure id="&BASEID;.pic8" float="0">
          <title id="&BASEID;.pic8.title">
            Страница списка редактирования авторов с опцией
            list_display
          </title>
          <screenshot>
            <mediaobject>
              <imageobject>
                <imagedata fileref="pics/waiting_for.png" format="PNG"/>
              </imageobject>
            </mediaobject>
          </screenshot>
        </figure>
      </para>

      <para>
        Теперь добавим простую панель поиска. Добавьте
        <varname>search_fields</varname> в
        <classname>AuthorAdmin</classname>, вот так:
        <screen>
          <![CDATA[
class AuthorAdmin(admin.ModelAdmin):
    list_display = ('first_name', 'last_name', 'email')
    search_fields = ('first_name', 'last_name')
          ]]>
        </screen>
        Обновите страницу и вы увидите панель поиска
        вверху. (См. рисунок <quote><xref linkend="&BASEID;.pic9"
        endterm="&BASEID;.pic9.title"/></quote>.) Мы просто указали
        странице со списком редактирования, чтобы она отобразила
        панель поиска, которая производит поиск по полям
        <varname>first_name</varname> и
        <varname>last_name</varname>. Как можно ожидать, поиск
        регистронезависимый и работает с обоими полями. То есть при
        поиске строки <token><quote>bar</quote></token>, будет найдет
        как автор с именем Barney, так и автор с фамилией Hobarson.
      </para>

      <para>
        <figure id="&BASEID;.pic9" float="0">
          <title id="&BASEID;.pic9.title">
            Страница списка редактирования авторов с опцией search_fields
          </title>
          <screenshot>
            <mediaobject>
              <imageobject>
                <imagedata fileref="pics/waiting_for.png" format="PNG"/>
              </imageobject>
            </mediaobject>
          </screenshot>
        </figure>
      </para>

      <para>
        Теперь добавим фильтр по дате к странице списка редактирования
        модели <classname>Book</classname>:
        <screen>
          <![CDATA[
from django.contrib import admin
from mysite.books.models import Publisher, Author, Book

class AuthorAdmin(admin.ModelAdmin):
    list_display = ('first_name', 'last_name', 'email')
    search_fields = ('first_name', 'last_name')

class BookAdmin(admin.ModelAdmin):
    list_display = ('title', 'publisher', 'publication_date')
    list_filter = ('publication_date',)

admin.site.register(Publisher)
admin.site.register(Author, AuthorAdmin)
admin.site.register(Book, BookAdmin)
          ]]>
        </screen>
      </para>

      <para>
        Так как мы работаем с другим набором настроек, мы создали
        отдельный класс <classname>ModelAdmin</classname> &mdash;
        <classname>BookAdmin</classname>. Сначала мы определили
        <varname>list_display</varname> для более приемлимого
        отображения списка редактирования. Затем установили
        <varname>list_filter</varname>, указав кортеж полей для
        фильтра, который отобразится в правой части страницы. Для поля
        даты, Django предоставляет готовые варианты фильтрации списка:
        <quote>Сегодня</quote>, <quote>Последние 7 дней</quote>,
        <quote>Этот месяц</quote>, <quote>Этот год</quote> &mdash;
        разработчики Django нашли их самыми популярными вариантами
        условий фильтрации. Рисунок <quote><xref
        linkend="&BASEID;.pic10"
        endterm="&BASEID;.pic10.title"/></quote> показывает, как это
        выглядит:
      </para>

      <para>
        <figure id="&BASEID;.pic10" float="0">
          <title id="&BASEID;.pic10.title">
            Страница списка редактирования книг с опцией list_filter
          </title>
          <screenshot>
            <mediaobject>
              <imageobject>
                <imagedata fileref="pics/waiting_for.png" format="PNG"/>
              </imageobject>
            </mediaobject>
          </screenshot>
        </figure>
      </para>

      <para>
        Параметр <varname>list_filter</varname> работает с полями
        разных типов, не только
        <classname>DateField</classname>. (Попробуйте, например, с
        полями <classname>BooleanField</classname> и
        <classname>ForeignKey</classname>.) Фильтры отображаются, если
        есть хотя бы два значения для фильтрации.
      </para>

      <para>
        Ещё одним способом фильтрации по дате является использование
        опции <varname>date_hierarchy</varname>:
        <screen>
          <![CDATA[
class BookAdmin(admin.ModelAdmin):
    list_display = ('title', 'publisher', 'publication_date')
    list_filter = ('publication_date',)
    date_hierarchy = 'publication_date'
          ]]>
        </screen>
        К странице списка редактирования сверху добавляется
        развернутая панель навигации по дате, как показано на рисунке
        <quote><xref linkend="&BASEID;.pic11"
        endterm="&BASEID;.pic11.title"/></quote>. Она начинается со
        списка доступных годов, затем месяцев и дней.
      </para>

      <para>
        <figure id="&BASEID;.pic11" float="0">
          <title id="&BASEID;.pic11.title">
            Страница списка редактирования книг с опцией date_hierarchy
          </title>
          <screenshot>
            <mediaobject>
              <imageobject>
                <imagedata fileref="pics/waiting_for.png" format="PNG"/>
              </imageobject>
            </mediaobject>
          </screenshot>
        </figure>
      </para>

      <para>
        Обратите внимание, опция <varname>date_hierarchy</varname> в
        качестве параметра принимает <emphasis>строку</emphasis>, а не
        кортеж, потому что только одно поле даты может быть
        использована для иерархии.
      </para>

      <para>
        Теперь изменим сортировку по-умолчанию, чтобы на странице
        списка редактирования, книги сортировались по дате публикации
        в направлении убывания.  По-умолчанию, объекты сортируются в
        соответствии с атрибутом <varname>ordering</varname> класса
        <classname>Meta</classname> (См. главу <quote><xref
        linkend="djangobook.chap05"
        endterm="djangobook.chap05.title"/></quote>), но если
        <varname>ordering</varname> там не указан, то сортировка не
        определена.
        <screen>
          <![CDATA[
class BookAdmin(admin.ModelAdmin):
    list_display = ('title', 'publisher', 'publication_date')
    list_filter = ('publication_date',)
    date_hierarchy = 'publication_date'
    ordering = ('-publication_date',)
          ]]>
        </screen>
      </para>

      <para>
        Опция <varname>ordering</varname> административного интерфейса
        работает так же, как и для класса <classname>Meta</classname>,
        за исключением того, что использует только первое поле
        указанное в списке. Чтобы указать тип сортировки по-убыванию,
        необходимо поставить минус перед названием поля.
      </para>

      <para>
        Обновим страницу списка редактирования. Обратите внимание, что
        возле заголовка поля даты публикации появилась стрелка,
        указывающая на направление сортировки. (См. рисунок
        <quote><xref linkend="&BASEID;.pic12"
        endterm="&BASEID;.pic12.title"/></quote>.)
      </para>

      <para>
        <figure id="&BASEID;.pic12" float="0">
          <title id="&BASEID;.pic12.title">
            Страница списка редактирования книг с сортировкой
          </title>
          <screenshot>
            <mediaobject>
              <imageobject>
                <imagedata fileref="pics/waiting_for.png" format="PNG"/>
              </imageobject>
            </mediaobject>
          </screenshot>
        </figure>
      </para>

      <para>
        Мы рассмотрели основные настройки. Используя их, можно создать
        функциональный и удобный интерфейс администратора всего парой
        строк кода.
      </para>

    </section>

    <section id="&BASEID;.modeladmin.editform">

      <title id="&BASEID;.modeladmin.editform.title">
        Настройка форм редактирования
      </title>

      <para>
        Так же, как и со списками редактирования, форма редактирования
        может быть настроена множеством способов.
      </para>

      <para>
        Сначала определим порядок отображения полей. По-умолчанию,
        поля отображаются в том же порядке, в каком они были
        определены в модели. Мы можем изменить этот порядок с помощью
        опции <varname>fields</varname> в нашем классе, унаследованом
        от <classname>ModelAdmin</classname>:
        <screen>
          <![CDATA[
class BookAdmin(admin.ModelAdmin):
    list_display = ('title', 'publisher', 'publication_date')
    list_filter = ('publication_date',)
    date_hierarchy = 'publication_date'
    ordering = ('-publication_date',)
    fields = ('title', 'authors', 'publisher', 'publication_date')
          ]]>
        </screen>
      </para>

      <para>
        Теперь форма редактирования для книг будет использовать
        указаный порядок полей. Более естественно, если название книги
        будет идти перед автором. Конечно, порядок полей зависит от
        вашего способа работы с данными. Все формы разные.
      </para>

      <para>
        Другой полезной особенностью, которую предоставляет опция
        <token>fields</token> является <emphasis>исключение</emphasis>
        определённых полей из списка редактирования. Просто уберите из
        списка поля, которые требуется исключить. Вы можете
        использовать это в случае, когда вашим административным
        пользователям позволено редактировать только определённые
        части данных или если часть полей изменяется с помощью
        внешнего автоматизированного процесса. Например, в нашей базе
        с книгами, мы можем спрятать поле
        <token>publication_date</token>:
        <screen>
          <![CDATA[
class BookAdmin(admin.ModelAdmin):
    list_display = ('title', 'publisher', 'publication_date')
    list_filter = ('publication_date',)
    date_hierarchy = 'publication_date'
    ordering = ('-publication_date',)
    fields = ('title', 'authors', 'publisher')
          ]]>
        </screen>
        В результате, форма редактирование книг не предоставляет
        возможности изменения даты публикации. Это может быть полезно
        в случае, если вы издатель, которые предпочитает, чтобы его
        авторы не отодвигали даты публикаций. (Естественно, это чисто
        гипотетический пример.)
      </para>

      <para>
        Когда пользователь использует эту неполную форму для
        добавления книги, Django устанавливает
        <token>publication_date</token> в <token>None</token> &mdash;
        поэтому убедитесь, что поле имеет свойство
        <token>null=True</token>.
      </para>

      <para>
        Другая часто используемая настройка формы редактирования
        используется для полей типа многие-ко-многим. Как можно было
        увидеть на форме редактирования для книг, интерфейс
        администратора представляет каждое поле типа
        <classname>ManyToManyField</classname> в виде списка с
        возможностью выбора нескольких элементов, который является
        самым логичным методом отображения в формате HTML &mdash; но
        такие списки не всегда удобно использовать. Если вам требуется
        отметить несколько элементов, вы должны удерживать клавишу
        <token>Ctrl</token> для этого. Интерфейс администратора
        добавляет текст, который напоминает об этом, но представьте
        ситуацию когда надо выделить сотню элементов.
      </para>

      <para>
        Интенфейс администратора предоставляет решение &mdash;
        <token>filter_horizontal</token>.  Добавим его в
        <classname>BookAdmin</classname> и посмотрим что получилось:
        <screen>
          <![CDATA[
class BookAdmin(admin.ModelAdmin):
    list_display = ('title', 'publisher', 'publication_date')
    list_filter = ('publication_date',)
    date_hierarchy = 'publication_date'
    ordering = ('-publication_date',)
    filter_horizontal = ('authors',)
          ]]>
        </screen>
        (Обратите внимание, что мы удалили параметр
        <token>fields</token>.)
      </para>

      <para>
        Обновите страницу и вы заметите, что поле <quote>Автор</quote>
        теперь использует удобный javascript-интерфейс фильтрации,
        который позволяет искать среди элементов и перемещать
        выбранных авторов в поле выбранных и наоборот.
      </para>

      <para>
        <figure id="&BASEID;.pic13" float="0">
          <title id="&BASEID;.pic13.title">
            Страница списка редактирования книг с опцией filter_horizontal.
          </title>
          <screenshot>
            <mediaobject>
              <imageobject>
                <imagedata fileref="pics/waiting_for.png" format="PNG"/>
              </imageobject>
            </mediaobject>
          </screenshot>
        </figure>
      </para>

      <para>
        Мы настоятельно рекомендуем использовать
        <token>filter_horizontal</token> для полей
        <classname>ManyToManyField</classname> у которых более 10
        элементов. Также вы можете использовать
        <token>filter_horizontal</token> для нескольких полей, указав
        их имена в кортеже.
      </para>

      <para>
        Классы <classname>ModelAdmin</classname> так же поддерживает
        опцию <token>filter_vertical</token>. Она работает так же, как
        и <token>filter_horizontal</token>, но поля располагаются
        вертикально. Используйте то, что вам больше нравится.
      </para>

      <para>
        Опции <token>filter_horizontal</token> и
        <token>filter_vertical</token> работают только с полями
        <classname>ManyToManyField</classname>, не с
        <classname>ForeignKey</classname>. По-умолчанию, интерфейс
        администратора использует <token>&lt;select&gt;</token> для
        полей <classname>ForeignKey</classname>, но, так же как и для
        поля <classname>ManyToManyField</classname>, иногда вы не
        хотите видеть все объекты в выпадающем списке. Например, если
        в вашей базе книг будут тысячи авторов, форма добавления книг
        будет вынуждена загружать всех авторов в выпадающий список.
      </para>

      <para>
        Методом для решения этой задачи является использование опции
        <token>raw_id_fields</token>. Укажите для неё кортеж с именами
        полей <classname>ForeignKey</classname> и эти поля будут
        отображаться простым текстовым полем (<token>&lt;input
        type="text"&gt;</token>) вместо
        <token>&lt;select&gt;</token>. (См. рисунок <quote><xref
        linkend="&BASEID;.pic14"
        endterm="&BASEID;.pic14.title"/></quote>.)
        <screen>
          <![CDATA[
class BookAdmin(admin.ModelAdmin):
    list_display = ('title', 'publisher', 'publication_date')
    list_filter = ('publication_date',)
    date_hierarchy = 'publication_date'
    ordering = ('-publication_date',)
    filter_horizontal = ('authors',)
    raw_id_fields = ('publisher',)
          ]]>
        </screen>
      </para>

      <para>
        <figure id="&BASEID;.pic14" float="0">
          <title id="&BASEID;.pic14.title">
            Страница списка редактирования книг с опцией raw_id_fields.
          </title>
          <screenshot>
            <mediaobject>
              <imageobject>
                <imagedata fileref="pics/waiting_for.png" format="PNG"/>
              </imageobject>
            </mediaobject>
          </screenshot>
        </figure>
      </para>

      <para>
        Что вы будете вводить в это поле? Идентификатор
        издателя. Учитывая то, что люди не могут запомнить
        идентификаторы из базы данных, рядом находится иконка с
        увеличительным стеклом, которую вы можете нажать для
        отображения окна, на котором вы можете выбрать требуемого
        издателя.
      </para>

    </section>

  </section>

  <section id="&BASEID;.ugp">

    <title id="&BASEID;.ugp.title">
      Пользователи, группы и права
    </title>

    <para>
      После входа в интерфейс администратора в качестве
      суперпользователя, вы имеете права на создание, изменение и
      удаление любого объекта. Обычно, различные среды требуют
      различные системы назначения прав &mdash; не каждый может или
      должен быть суперпользователем. Интерфейс администратора
      использует систему управления правами, которую вы можете
      применять для предоставления определённым пользователям права
      доступа к ограниченному объёму информации.
    </para>

    <para>
      Такие учётные записи являются достаточно общими для
      использования вне интерфейса администратора, но в данный момент
      мы будем их рассматривать в качестве учётных записей
      административных пользователей. В главе <quote><xref
      linkend="djangobook.chap14"
      endterm="djangobook.chap14.title"/></quote> мы рассмотрим, как
      интегрировать учетные записи пользователей с остальной частью
      вашего сайта (т.е., использовать их не только в интерфейсе
      администратора).
    </para>

    <para>
      Вы можете управлять пользователями и правами через интерфейс
      администратора, аналогично управлению любым другим объектом. Мы
      рассматривали это ранее в данной главе, когда мы изучали разделы
      пользователей и групп. Пользовательские объекты обладают
      стандартными полями логина, пароля, адреса электронной почты и
      так далее, дополнительно прилагается набор полей, которые
      определяют, что именно разрешено делать пользователю на
      интерфейсе администратора. Существует набор из трёх флагов:

      <itemizedlist>
        <listitem>
          <para>
            Флаг <quote>is active</quote> (активен) управляет
            активностью пользователя в общем смысле. Если флаг
            отключен, пользователь не пройдёт аутентификацию даже при
            указании правильного пароля.
          </para>
        </listitem>

        <listitem>
          <para>
            Флаг <quote>is staff</quote> (сотрудник) управляет
            доступом пользователя к интерфейсу администратора (т.е.,
            является ли пользователь штатным сотрудником вашей
            организации). Так как, тот же самый пользователь системы
            может управлять доступом к публичной, не административной,
            части сайтов (обратитесь к главе <quote><xref
            linkend="djangobook.chap14"
            endterm="djangobook.chap14.title"/></quote>), значение
            этого флага разделяет обычных пользователей от
            администраторов.
          </para>
        </listitem>

        <listitem>
          <para>
            Флаг <quote>is superuser</quote> (суперпользователь)
            предоставляет пользователю полные права на добавление,
            создание и удаление любого элемента на интерфейсе
            администратора. Обычные правила доступа игнорируются.
          </para>
        </listitem>
      </itemizedlist>
    </para>

    <para>
      <quote>Обычные</quote> административные пользователи &mdash;
      т.е., сотрудники &mdash; имеют ограниченный набор прав для
      работы с интерфейсом администратора. Каждый объект, который
      можно отредактировать через интерфейс (т.е., книги, авторы)
      обладает тремя правами: право на <emphasis>создание</emphasis>,
      право на <emphasis>редактирование</emphasis> и право на
      <emphasis>удаление</emphasis>. Наделение правами пользователя
      позволяет ему выполнять эти действия.
    </para>

    <para>
      Когда вы создаёте пользователя, он не обладает никакими правами
      и задача наделения пользователя ими лежит целиком на
      вас. Например, вы можете дать пользователю право на добавление и
      изменение издателей, но не дать права на их удаление. Следует
      отметить, что права выдаются на каждую модель в отдельности, а
      не на каждый объект модели. Таким образом, это позволяет вам
      сказать <quote>Иван может изменять любую книгу</quote>, но не
      позволяет сказать <quote>Иван может изменять любую книгу
      изданную Apress</quote>. Такая функциональность, как права на
      каждый объект лежит вне данной книги, но хорошо освещена в
      официальной документации на Django.

      <note>
        <para>
          Доступ к редактированию пользователей и их прав также
          управляется этой системой. Если вы разрешили кому-нибудь
          редактировать пользователей, то он сможет изменять свои
          собственные права, а это может выходить за рамки того, что
          вы желали! Предоставление пользователю права релактировать
          пользователей явно превращает его в суперпользователя.
        </para>
      </note>
    </para>

    <para>
      Также вы можете добавлять пользователей в
      группы. <emphasis>Группой</emphasis> &mdash; это просто набор
      прав, которыми наделяются все члены группы. Группы полезны при
      назначении одинаковых прав на большое количество пользователей.
    </para>

  </section>

  <section id="&BASEID;.when-why">

    <title id="&BASEID;.when-why.title">
      Когда и почему надо использовать интерфейс администратора, а
      когда не надо
    </title>

    <para>
      Изучив эту главу, вы должны иметь хорошее представление о том,
      как использовать интерфейс администратора. Но мы хотим
      рассмотреть подробнее, <emphasis>когда</emphasis> и
      <emphasis>почему</emphasis> вы можете использовать его, и когда
      это делать <emphasis>не следует</emphasis>.
    </para>

    <para>
      Интерфейс администратора Django особенно полезен в ситуации,
      когда его использует неискушённый пользователь для ввода данных,
      что является основной задачей этого компонента системы. В
      редакции газеты, где Django был разработан, взаимодействие
      журналиста и разработчика при выдаче, например, специального
      репортажа о качестве воды в муниципальной сети, происходит
      как-то так:

      <itemizedlist>
        <listitem>
          <para>
            Журналист, ответственный за репортаж, встречается с одним
            из разработчиков и обсуждает с ним возможность публикации
            имеющихся у него данных.
          </para>
        </listitem>

        <listitem>
          <para>
            Разработчик создаёт модель для этих данных и затем
            открывает доступ репортёру к интерфейсу администратора.
          </para>
        </listitem>

        <listitem>
          <para>
            Корреспондент осматривает интерфейс администратора,
            указать на недостающие или лишние поля - лучше сейчас, чем
            позже. Разработчик оперативно изменяет модели.
          </para>
        </listitem>

        <listitem>
          <para>
            Пока журналист вводит данные в Django, разработчик может
            сфокусироваться на работе над публичной частью интерфейса
            (прикольная часть!).
          </para>
        </listitem>
      </itemizedlist>
    </para>

    <para>
      Другими словами, смысл существования (raison d'être) интерфейса
      администратора Django &mdash; способствовать одновременной
      работе журналиста (наполнение сайта) и разработчика (создание
      функционала).
    </para>

    <para>
      Тем не менее, кроме очевидных задач по вводу данных, мы находим
      интерфейс администратора полезным в некоторых других случаях:

      <itemizedlist>
        <listitem>
          <para>
            <emphasis>Проверка моделей данных</emphasis>: После
            определение нескольких моделей, будет полезно открыть их в
            интерфейсе и ввести некоторое количество данных. Обычно на
            этом этапе находятся ошибки в схеме базы данных.
          </para>
        </listitem>

        <listitem>
          <para>
            <emphasis>Управление полученными данными</emphasis>: Для
            приложения, которые построены на данных, получаемых из
            внешних источников (например, от пользователей или
            поисковых роботов), интерфейс администратора предоставляет
            простой способ изучения и редактирования этих данных. Вы
            можете рассматривать его как не самую мощную, но
            достаточно удобную версию утилиты командной строки для
            работы с базой данных.
          </para>
        </listitem>

        <listitem>
          <para>
            <emphasis>RAD приложения для управления
            данными</emphasis>: Вы можете использовать интерфейс
            администратора для создания на его основе простого
            приложения для управления данными &mdash; скажем, для
            отслеживания своих трат. Если вы разрабатываете что-то для
            собственного использования, не для публики, интерфейс
            администратора может помогать вам достаточно
            продолжительное время. С этой стороны, вы можете
            рассматривать его как реляционную версию электронных
            таблиц.
          </para>
        </listitem>
      </itemizedlist>
    </para>

    <para>
      На последок хотим сказать, что интерфейс администратора не
      <quote>такой как есть и все</quote>. За многие годы мы видели,
      как его улучшали и модернизировали, чтобы он выполнял функции,
      на которые не был расчитан. Он не предназначен для общего
      использования, сложной сортировки и поиска данных. Как мы
      упоминали в этой главе, он предназначен для довереных
      администраторов сайта. Знание этого &mdash; ключ к эффективному
      использованию интерфейса администратора.
    </para>

  </section>

  <section id="&BASEID;.what-is-next">

    <title id="&BASEID;.what-is-next.title">
      Что дальше?
    </title>

    <para>
      Мы создали несколько моделей и настроили первоклассный интерфейс
      для редактирования данных. В следующей главе мы перейдём к
      внутренностям веб-разработки: созданию форм и их обработке.
    </para>

  </section>

</chapter>
