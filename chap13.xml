<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
"http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd"
[
<!ENTITY BASEID "djangobook.chap13">
]>

<chapter lang="ru" id="&BASEID;">

  <title id="&BASEID;.title">
    Кэширование
  </title>

  <para>
    Перевод &copy; Попов Руслан &lt;radz &bull; yandex &bull; ru&gt;
  </para>

  <para>
    Статические веб сайты, которые являются простыми файлами
    отсылаемыми по сети, растут как сумасшедшие. Но важное
    преимуществу динамических сайтов заключается в их динамике. При
    каждом пользовательском запросе страницы, веб сервер выполняет
    необходимые действия &mdash; от выполнения запросов над базой
    данных, до обработки шаблона по имеющейся бизнес-логике &mdash;
    для создания этой страницы. С точки зрения экономии ресурсов, это
    весьма расточительная работа.
  </para>

  <para>
    Для большинства веб приложений такое расточительство не является
    критичным. Большинство веб приложений не похожи на <ulink
    url="http://washingtonpost.com/"/> или на SlashDot, это небольшие
    сайты со скромным трафиком. Но для более серьёзных сайтов
    желательно внимательно относится к экономии ресурсов. Этому
    поможет кэширование.
  </para>

  <para>
    Процесс <emphasis>кэширования</emphasis> &mdash; это процесс
    сохранения результата ресурсоёмкого вычисления, для исключения
    повторной траты ресурсов на такое же действие в будущем. Ниже
    представлен некий псевдокод, который объясняет как это будет
    работать для динамически созданной веб страницы:
    <screen>
      <![CDATA[
получен URL, пытаемся найти такую страницу в кэше
если страница есть в кэше:
    возвращаем закэшированную страницу
иначе:
    создаём страницу
    сохраняем её в кэше на будущее
    возвращаем созданную страницу
      ]]>
    </screen>
  </para>

  <para>
    Django поставляется с надёжной системой кэширования, которая
    позволяет вам сохранять динамические страницы, что помогает
    сэкономить ресурсы при повторных запросах. Для удобства Django
    предоставляет различные уровни детализации кэша. Вы можете
    кэшировать отклики определённых представлений, либо только
    трудновоспроизводимые части, или вы можете кэшировать весь сайт.
  </para>

  <para>
    Django хорошо работает с кэшами высокого уровня, такими как Squid
    (<ulink url="http://www.squid-cache.org/"/> и кэши
    браузеров. Существуют типы кэшей, которые вы не можете
    контролировать напрямую, но которым можно отсылать инструкции
    (через HTTP заголовки), указывая какая часть вашего сайта должна
    быть закэширована и как.
  </para>

  <para>
    Продолжайте читать, чтобы узнать как использовать систему
    кэширования в Django. Когда ваш сайт станет подобным Slashdot'у,
    вы похвалите себя за то, что поняли этот материал.
  </para>

  <section id="&BASEID;.setup">

    <title id="&BASEID;.setup.title">
      Настройка кэша
    </title>

    <para>
      Система кэширования практически не нуждается в настройке. А
      именно, следует указать где должен располагаться кэш: в базе
      данных, на файловой системе или прямо в оперативной памяти. Это
      важное решение, которое повлияет на производительность кэша (да,
      некоторые типы кэша значительно быстрее работают чем
      другие). Производительность кэширования в памяти обычно
      значительно выше, чем в случае базы данных или файловой системы,
      так как в этом случае исключаются затраты на взаимодействие с
      базой данных или файловой системой.
    </para>

    <para>
      Настройка кэша производится через параметр
      <token>CACHE_BACKEND</token> файла конфигурации. Если вы
      используете кэширование и не указали
      <token>CACHE_BACKEND</token>, Django будет по умолчанию
      использовать <token>simple:///</token>. Следующие секции
      расскажут о всех возможных значениях данного параметра.
    </para>

    <section id="&BASEID;.setup.memcached">

      <title id="&BASEID;.setup.memcached.title">
	Memcached
      </title>
      
      <para>
	Безусловно самый быстрый и самый эффективный тип кэша
	доступный Django &mdash; Memcached &mdash; является средой
	кэширования в оперативной памяти, разработанной для управления
	высокой нагрузкой на сервис LiveJournal (<ulink
	url="http://www.livejournal.com/"/> и впоследствии открытый
	компанией Danga Interactive (<ulink
	url="http://danga.com/"/>). Он используется такими сайтами как
	Slashdot и Wikipedia для снижения количества запросов к базе
	данных и значительно увеличивает производительность сайтов.
      </para>

      <para>
	Memcached доступен бесплатно на <ulink
	url="http://danga.com/memcached/"/>. Он запускается в виде
	сервиса и выделяет себе указанный объём оперативной
	памяти. Его главной особенностью является интерфейс &mdash;
	<emphasis>супер-быстрый-и-лёгкий</emphasis> интерфейс &mdash;
	используемый для добавления, получения и удаления определённых
	данных из кэша. Все данные хранятся только в оперативной
	памяти, таким образом нет излишних затрат ресурсов на работу с
	файловой системой или базой данных.
      </para>

      <para>
	После установки Memcached потребуется установить библиотеку с
	интерфейсом для языка Python, которая не поставляется вместе с
	Django. Эта библиотека доступна в виде одного модуля
	<token>memcache.py</token>, который доступен по адресу <ulink
	url="http://www.tummy.com/Community/software/python-memcached/"/>.
      </para>

      <para>
	Для использование Memcached совместно с Django установите для
	параметра <token>CACHE_BACKEND</token> значение
	<token>memcached://ip:port/</token>, где <token>ip</token>
	&mdash; это IP адрес сервера на котором работает сервис
	Memcached, а <token>port</token> &mdash; соответственно, порт.
      </para>

      <para>
	В данном примере Memcached запущен на локальной машине
	(127.0.0.1) на порту 11211:
	<screen>
CACHE_BACKEND = 'memcached://127.0.0.1:11211/'
	</screen>
      </para>

      <para>
	Одной из замечательных особенностей Memcached является его
	возможность разделять кэш между множеством серверов. Это
	означает, что вы можете запустить сервисы Memcached на
	нескольких машинах и ваше приложение будет рассматривать эту
	группу компьютеров как <emphasis>единый</emphasis> кэш, без
	необходимости копирования элементов кэша на каждый сервер. Для
	того, чтобы воспользоваться такими возможностями в Django,
	укажите все эти сервера в параметре
	<token>CACHE_BACKEND</token>, разделяя их точкой с запятой.
      </para>

      <para>
	В данном примере кэш разделён между экземплярами Memcached,
	которые работают на машинах с IP адресами 172.19.26.240 и
	172.19.26.242, оба на портах 11211:
	<screen>
CACHE_BACKEND = 'memcached://172.19.26.240:11211;172.19.26.242:11211/'
	</screen>
      </para>

      <para>
	В следующем примере кэш распределён по экземплярам Memcached,
	которые работают на IP адресах 172.19.26.240 (порт 11211),
	172.19.26.242 (порт 11212) и 172.19.26.244 (11213):
	<screen>
CACHE_BACKEND = 'memcached://172.19.26.240:11211;172.19.26.242:11212;172.19.26.244:11213/'
	</screen>
      </para>

      <para>
	В конце следует упомянуть, что кэш работающий в оперативной
	памяти имеет один важный недостаток. Так как все данные кэша
	находятся только в оперативной памяти, данные могут быть
	потеряны при сбое сервера. Очевидно, что оперативная память не
	предназначена для постоянного хранения данных, таким образом
	не следует рассматривать кэш в качестве такого хранилища. Без
	сомнений <emphasis>ни один</emphasis> механизмов Django для
	кэширования информации не должен рассматриваться в качестве
	постоянного хранилища данных. Они предназначены только для
	кэширования. Мы специально упоминаем об этом, потому что все
	данные, хранящиеся в оперативной памяти, носят временный
	характер.
      </para>

    </section>

    <section id="&BASEID;.setup.database">

      <title id="&BASEID;.setup.database.title">
	Кэширование в базу данных
      </title>
      
      <para>
	Для использования таблицы базы данных в виде кэша следует
	создать такую таблицу и указать Django, что надо использовать
	её для кэширования.
      </para>

      <para>
	Сначала, создаём таблицу с помощью команды:
	<screen>
python manage.py createcachetable [cache_table_name]
	</screen>
	где <token>[cache_table_name]</token> &mdash; имя таблицы,
	которая будет создана. Имя может быть любым, главное, чтобы
	оно соответствовало требования базы данных и не было уже
	занято. Эта команда создаёт одну таблицу в базе данных в
	соответствующем для Django формате.
      </para>

      <para>
	После создания таблицы необходимо назначить параметру
	<token>CACHE_BACKEND</token> значение
	<token>db://tablename</token>, где <token>tablename</token>
	&mdash; имя таблицы, которую вы создали. В данном примере, имя
	таблицы будет <token>my_cache_table</token>:
	<screen>
CACHE_BACKEND = 'db://my_cache_table'
	</screen>
      </para>

      <para>
	Система кэширование в базу данных использует ту же базу
	данных, которая указана в файле конфигурации. Вы не можете
	использовать отдельную базу данных для кэша.
      </para>

    </section>

    <section id="&BASEID;.setup.filesystem">

      <title id="&BASEID;.setup.filesystem.title">
	Кэширование на файловую систему
      </title>
      
      <para>
	Для хранения кэшированных элементов на файловой системе
	используйте тип <token>file://</token> в параметре
	<token>CACHE_BACKEND</token>, указав каталог на файловой
	системе, который будет использоваться для кэша.
      </para>

      <para>
	Например, для хранения данных кэша в каталоге
	<filename>/var/tmp/django_cache</filename> используйте это:
	<screen>
CACHE_BACKEND = 'file:///var/tmp/django_cache'
	</screen>
      </para>

      <para>
	Следует отметить использование трёх слэшей. Первые два
	относятся к <token>file://</token>, а третий &mdash; к пути до
	каталога <filename>/var/tmp/django_cache</filename>. Если вы
	используете Windows, следует указывать букву диска после
	<token>file://</token>, вот так:
	<token>file://c:/foo/bar</token>.
      </para>

      <para>
	Путь до каталога должен быть <emphasis>абсолютным</emphasis>,
	т.е. он должен начинаться от корня файловой системы. Наличие
	завершающего слэша не имеет значения.
      </para>

      <para>
	Следует удостовериться, что каталог существует и доступен для
	записи и чтения пользователю, от которого запущен веб
	сервер. Продолжая предыдущий пример, если ваш сервер работает
	от пользователя <token>apache</token>, следует проверить, что
	каталог <filename>/var/tmp/django_cache</filename> доступен
	для записи и чтения этому пользователю.
      </para>

      <para>
	Каждое значение кэша будет храниться в виде отдельного файла,
	содержимое которого будет представлять кэшированную информацию
	в сериализованном с помощью модуля <token>pickle</token>
	виде. Имя файла будет представлять собой ключ кэша в виде
	приемлемом для файловой системы.
      </para>

    </section>

    <section id="&BASEID;.setup.local-memory">

      <title id="&BASEID;.setup.local-memory.title">
	Кэширование в оперативную память
      </title>
      
      <para>
	Если вам требуется использовать скоростные преимущества
	кэширования в оперативную память, но у вас нет возможности
	использовать Memcached, рассмотрите использование локального
	кэша. Такой кэш организовывается для каждого процесса и
	позволяет многократное использование (thread-safe), но он не
	так эффективен как Memcached из-за своего простого механизма
	защёлок и стратегий выделения памяти.
      </para>

      <para>
	Для использование этого типа кэширования установите для
	параметра <token>CACHE_BACKEND</token> значение
	<token>locmem:///</token>, например:
	<screen>
CACHE_BACKEND = 'locmem:///'
	</screen>
      </para>

    </section>	

    <section id="&BASEID;.setup.simple-caching">

      <title id="&BASEID;.setup.simple-caching.title">
	Простое кэширование (для разработки)
      </title>
      
      <para>
	Простой, обслуживающий один процесс, кэш с расположением
	данных в оперативной памяти можно организовать с помощью
	<token>simple:///</token>, например:
	<screen>
CACHE_BACKEND = 'simple:///'
	</screen>
      </para>

      <para>
	Этот кэш просто сохраняет кэшированные данные в процессе,
	таким образом этот тип кэша можно использовать только в
	процессе разработки и тестирования.
      </para>

    </section>

    <section id="&BASEID;.setup.dummy-caching">

      <title id="&BASEID;.setup.dummy-caching.title">
	Фиктивное кэширование (для разработки)
      </title>
      
      <para>
	Наконец, Django поставляется с <quote>фиктивным</quote> кэшем,
	который не производит никакого кэширования.
      </para>

      <para>
	Такой тип кэширование полезен в случае когда у вас есть
	работающий сайт, который мощно использует кэширование, и
	тестовый сайт, который вам не надо кэшировать. В этом случае
	установите для параметра <token>CACHE_BACKEND</token> значение
	<token>dummy:///</token> в файле конфигурации тестового сайта,
	например:
	<screen>
CACHE_BACKEND = 'dummy:///'
	</screen>
      </para>

      <para>
	В результате этих действие тестовый сайт не будет использовать
	кэширование, а основной сайт будет.
      </para>

    </section>

    <section id="&BASEID;.setup.backend-args">

      <title id="&BASEID;.setup.backend-args.title">
	Аргументы CACHE_BACKEND
      </title>
      
      <para>
	Каждый тип кэша может принимать аргументы. Они указываются в
	значении параметра <token>CACHE_BACKEND</token>. Перечислим
	их:
	<itemizedlist>
	  <listitem>
	    <para>
	      <token>timeout</token>: Значение по умолчанию, в
	      секундах, для применения кэширования. Значение по
	      умолчанию &mdash; 300 секунд (5 минут).
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <token>max_entries</token>: Для типов кэширования:
	      простого, локального и базы данных, этот параметр
	      устанавливает максимальное количество элементов
	      кэширования. При превышении этого числа из кэша
	      удаляются самые старые значения. Значение по умолчанию
	      &mdash; 300.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <token>cull_frequency</token>: Процент элементов кэша,
	      которые удаляются при достижении максимального значения
	      аргумента <token>max_entries</token>. Вычисляется так:
	      <token>1/cull_frequency</token>. Таким образом, если
	      установить <token>cull_frequency=2</token>, то при
	      заполнении кэша будет произведено удаление 50% элементов
	      кэша.
	    </para>

	    <para>
	      Значение <token>0</token> для этого аргумента означает,
	      что весь кэш должен быть очищен при заполнении кэша. Это
	      позволяет <emphasis>значительно</emphasis> ускорить
	      очистку кэша, ценой потери закэшированной
	      информации. Значение по умолчанию &mdash;
	      <token>3</token>.
	    </para>
	  </listitem>
	</itemizedlist>
      </para>

      <para>
	В данном примере, аргумент <token>timeout</token> имеет
	значение <token>60</token>:
	<screen>
CACHE_BACKEND = "locmem:///?timeout=60"
	</screen>
      </para>

      <para>
	В данном примере, аргумент <token>timeout</token> имеет
	значение <token>30</token>, аргумент
	<token>max_entries</token> &mdash; <token>400</token>:
	<screen>
	  <![CDATA[
CACHE_BACKEND = "locmem:///?timeout=30&max_entries=400"
	  ]]>
	</screen>
      </para>

      <para>
	Неправильные аргументы по-тихому игнорируются, как и
	неправильные значения поддерживаемых аргументов.
      </para>

    </section>

  </section>
      
  <section id="&BASEID;.cache-per-site">
    
    <title id="&BASEID;.cache-per-site.title">
      Кэширование отдельного сайта
    </title>
      
    <para>
      После того, как вы указали значение для
      <token>CACHE_BACKEND</token>, самым простым способом
      использования кэша будет кэширование всего сайта. Это означает,
      что каждая страница, которая не имеет параметров GET или POST,
      будет помещена в кэш на указанное количество времени при первом
      обращении к ней.
    </para>

    <para>
      Для активации этого способа кэширования необходимо добавить
      <token>django.middleware.cache.CacheMiddleware</token> в
      параметр <token>MIDDLEWARE_CLASSES</token>, как показано на
      примере:
      <screen>
MIDDLEWARE_CLASSES = (
    'django.middleware.cache.CacheMiddleware',
    'django.middleware.common.CommonMiddleware',
)
      </screen>

      <note>
	<para>
	  Порядок указания значений в параметре
	  <token>MIDDLEWARE_CLASSES</token> имеет значение. Обратитесь
	  к секции <quote><xref linkend="&BASEID;.order"
	  endterm="&BASEID;.order.title"/></quote>, описанной в этой
	  главе далее.
	</para>
      </note>
    </para>

    <para>
      Затем добавьте следующие обязательные параметры в файл
      конфигурации Django:
      <itemizedlist>
	<listitem>
	  <para>
	    <token>CACHE_MIDDLEWARE_SECONDS</token>: Количество секунд
	    в течении которых страница должна храниться в кэше.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    <token>CACHE_MIDDLEWARE_KEY_PREFIX</token>: Если кэш
	    распределён между несколькими сайтами под управлением
	    одной инсталляции Django, назначьте этому параметру имя
	    сайта или любую другую строку, которая будет уникальна для
	    этого экземпляра Django, это поможет избежать коллизии
	    ключей. Можете оставить значение пустым, если вас это не
	    волнует.
	  </para>
	</listitem>
      </itemizedlist>
    </para>

    <para>
      Система кэширует каждую страницу, которая не содержит GET или
      POST параметров. Таким образом, если пользователь запрашивает
      страницу и передаёт в запросе параметры GET или POST, система
      <emphasis>не пытается</emphasis> получить закэшированную версию
      страницы. Если вы намереваетесь использовать данный способ
      кэширования, следует помнить эту особенность при проектировании
      своего приложения.
    </para>

    <para>
      Механизм кэширования поддерживает ещё один параметр &mdash;
      <token>CACHE_MIDDLEWARE_ANONYMOUS_ONLY</token>. Если вы
      определили этот параметр и назначили ему значение
      <token>True</token>, то в этом случае механизм будет производить
      кэширование только анонимных запросов. Такое поведение позволяет
      просто и эффективно отключить кэширование для любых
      пользовательских страниц, таких как интерфейс администратора
      Django. Следует отметить, что если вы используете
      <token>CACHE_MIDDLEWARE_ANONYMOUS_ONLY</token>, вам следует
      удостовериться, что вы активировали
      <token>AuthenticationMiddleware</token> и что оно указано до
      <token>CacheMiddleware</token> в параметре
      <token>MIDDLEWARE_CLASSES</token>.
    </para>

    <para>
      Наконец, следует отметить, что <token>CacheMiddleware</token>
      автоматически устанавливает несколько заголовков в каждом
      <classname>HttpResponse</classname>:
      <itemizedlist>
	<listitem>
	  <para>
	    Заголовок <token>Last-Modified</token> указывает дату и
	    время когда была запрошена новая (некэшированная) версия
	    страницы.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Заголовок <token>Expires</token> указывает дату и время
	    плюс значение <token>CACHE_MIDDLEWARE_SECONDS</token> до
	    окончания выдачи закэшированной версии страницы.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Заголовок <token>Cache-Control</token> определяет
	    максимальный срок для страницы, относительно параметра
	    <token>CACHE_MIDDLEWARE_SECONDS</token>.
	  </para>
	</listitem>
      </itemizedlist>
    </para>

  </section>

  <section id="&BASEID;.cache-per-view">
    
    <title id="&BASEID;.cache-per-view.title">
      Кэширование отдельного представления
    </title>
      
    <para>
      Более гранулированный способ использования механизма кэширования
      даёт управление на уровне отдельных представлений. Оно имеет
      эффект, аналогичный кэшированию отдельных сайтов. Данный способ
      кэширования можно применять к любому представлению.
    </para>

    <para>
      Кэширование выполняется с помощью
      <emphasis>декоратора</emphasis>, который оборачивается вокруг
      функции представления и изменяет её поведение для использования
      механизма кэширования. Такой декоратор имеет имя
      <token>cache_page</token> и находится в модуле
      <token>django.views.decorators.cache</token>, например:
      <screen>
	<![CDATA[
from django.views.decorators.cache import cache_page

def my_view(request, param):
    # ...
my_view = cache_page(my_view, 60 * 15)
	]]>
      </screen>
    </para>

    <para>
      Аналогично, если вы используете Python версии 2.4 и выше, вы
      можете использовать особый синтаксис для
      декоратора. Нижеприведённый пример эквивалентен предыдущему:
      <screen>
	<![CDATA[
from django.views.decorators.cache import cache_page

@cache_page(60 * 15)
def my_view(request, param):
    # ...
	]]>
      </screen>
    </para>

    <para>
      Декоратор <token>cache_page</token> принимает один аргумент,
      время жизни страницы в кэше, в секундах. В предыдущем примере,
      результат работы представления <function>my_view()</function>
      будет помещён в кэш на 15 минут. Следует отметить, что мы
      написали <token>60 * 15</token> лишь в целях лучшей
      читаемости. Можно было сразу написать <token>900</token>.
    </para>

    <para>
      Кэш для каждого представления, как и кэш для отдельного сайта,
      зависит от URL. Если несколько URL указывают на одно и то же
      представление, каждый URL будет кэшироваться отдельно. Продолжая
      пример с <function>my_view()</function>, если ваш файл со схемой
      URL выглядит так:
      <screen>
	<![CDATA[
urlpatterns = ('',
    (r'^foo/(\d{1,2})/$', my_view),
)
	]]>
      </screen>
    </para>

    <para>
      то запросы к <token>/foo/1/</token> и <token>/foo/23/</token>
      будут закэшированы отдельно, как вы могли ожидать. Но после того
      как будет произведено кэширование определённого URL, все
      последующие запросы к нему будут использовать кэш.
    </para>
    
    <section id="&BASEID;.cache-per-view.in-url-conf">
    
      <title id="&BASEID;.cache-per-view.in-url-conf.title">
	Определение кэша для отдельного представления в файле со
	схемой URL
      </title>
      
      <para>
	Примеры из предыдущей секции имели жёстко определённый факт
	кэширования представления, потому что
	<function>cache_page()</function> изменяет функцию
	<function>my_view()</function>. Этот подход связывает ваше
	представление с механизмом кэширования, который не идеален по
	нескольким причинам. Например, вам может потребоваться
	повторно использовать функции представлений в другом сайте,
	который не имеет механизма кэширования, или может
	потребоваться передать представления людям, которые пожелают
	использовать их без применения кэширования. Решением таких
	проблем является указание кэширования для определённых
	представления прямо в файле со схемой URL.
      </para>

      <para>
	Это сделать легко: просто оберните функцию представления с
	помощью <function>cache_page()</function>. Ниже приведён
	старый пример файла со схемой URL:
	<screen>
	  <![CDATA[
urlpatterns = ('',
    (r'^foo/(\d{1,2})/$', my_view),
)
	  ]]>
	</screen>
      </para>

      <para>
	Здесь приведён тот же пример, но уже с функцией
	<function>cache_page()</function>:
	<screen>
	  <![CDATA[
from django.views.decorators.cache import cache_page

urlpatterns = ('',
    (r'^foo/(\d{1,2})/$', cache_page(my_view, 60 * 15)),
)
	  ]]>
	</screen>
      </para>

      <para>
	При использовании этого подхода не следует забывать об импорте
	функции <function>cache_page()</function> в файле со схемой
	URL.
      </para>

    </section>

  </section>

  <section id="&BASEID;.cache-api-low-level">
    
    <title id="&BASEID;.cache-api-low-level.title">
      API низкого уровня
    </title>
    
    <para>
      Изредка кэширование всей страницы не даёт ожидаемой пользы и,
      если честно, является неудобным.
    </para>

    <para>
      Возможно, к примеру, ваш сайт содержит представление, чей
      результат зависит от нескольких сложных запросов и постоянно
      меняется. В таком случае, использование кэширования для всей
      страницы будет всё портить, так как некоторая часть данных будет
      постоянно меняться, но вам всё ещё необходимо использовать
      механизм кэширования.
    </para>

    <para>
      Для случаев подобных этому, Django предоставляет простой
      интерфейс низкого уровня к механизму кэширования, который
      располагается в модуле <token>django.core.cache</token>. Вы
      можете использовать API низкого уровня для хранения объектов в
      кэше на любом уровне гранулярности, который вам потребуется. Вы
      можете поместить в кэш любой объект языка Python, который может
      быть сериализован с помощью модуля <token>pickle</token>:
      строки, словари, списки моделей объектов и так далее. (Почти
      каждый объект языка Python может быть сериализован, обратитесь к
      документации Python по модулю <token>pickle</token>.)
    </para>

    <para>
      Вот так происходит импортирование API:
      <screen>
	<![CDATA[
>>> from django.core.cache import cache
	]]>
      </screen>
    </para>

    <para>
      Простые методы <function>set(key, value,
      timeout_seconds)</function> и <function>get(key)</function>:
      <screen>
	<![CDATA[
>>> cache.set('my_key', 'hello, world!', 30)
>>> cache.get('my_key')
'hello, world!'
	]]>
      </screen>
    </para>

    <para>
      Аргумент <token>timeout_seconds</token> является необязательным,
      а его значение по умолчанию было указано ранее.
    </para>

    <para>
      Если объект не существует в кэше или сам кэш недоступен, то
      <function>cache.get()</function> возвращает <token>None</token>:
      <screen>
	<![CDATA[
# Ждём 30 секунд пока 'my_key' "протухнет"...

>>> cache.get('my_key')
None

>>> cache.get('some_unset_key')
None
	]]>
      </screen>
    </para>

    <para>
      Мы не рекомендуем хранить строковое значение <token>None</token>
      в кэше, потому что вы не будете иметь возможность отличить ваше
      сохранённое <token>None</token> от отсутствия значения в кэше,
      которое тоже возвращается как <token>None</token>.
    </para>

    <para>
      Функция <function>cache.get()</function> может принимать
      аргумент <token>default</token>. Он определяет, какое значение
      возвращать в случае отсутствия объекта в кэше:
      <screen>
	<![CDATA[
>>> cache.get('my_key', 'has expired')
'has expired'
	]]>
      </screen>
    </para>

    <para>
      Для получения нескольких значений из кэша за один запрос надо
      использовать метод <function>cache.get_many()</function>. Этот
      метод обратиться к кэшу один раз при получении значений, если
      это позволяет механизм кэша. Метод
      <function>cache.get_many()</function> возвращает словарь с
      запрошенными ключами, теми которые не <quote>протухли</quote>:
      <screen>
	<![CDATA[
>>> cache.set('a', 1)
>>> cache.set('b', 2)
>>> cache.set('c', 3)
>>> cache.get_many(['a', 'b', 'c'])
{'a': 1, 'b': 2, 'c': 3}
	]]>
      </screen>
    </para>

    <para>
      Если запрашиваемое значение не существует или
      <quote>протухло</quote>, то оно не будет включено в словарь:
      <screen>
	<![CDATA[
>>> cache.get_many(['a', 'b', 'c', 'd'])
{'a': 1, 'b': 2, 'c': 3}
	]]>
      </screen>
    </para>

    <para>
      Наконец, вы можете явно удалять значения из кэша с помощью
      метода <function>delete()</function>. Это простой способ
      исключения определённого объекта из кэша:
      <screen>
	<![CDATA[
>>> cache.delete('a')
	]]>
      </screen>
    </para>

    <para>
      Метод <function>delete()</function> не возвращает никакого
      значения и работает вне зависимости от существования указанного
      объекта в кэше.
    </para>

  </section>

  <section id="&BASEID;.upstream-caches">
    
    <title id="&BASEID;.upstream-caches.title">
      Кэши верхнего уровня
    </title>
    
    <para>
      До этого момента мы рассказывали о кэшировании
      <emphasis>ваших</emphasis> данных. Другим типом кэширования
      также относящимся к веб разработке является кэширование
      выполняемое механизмами более высокого уровня. Это такие
      системы, которые кэшируют пользовательские страницы даже до
      того, как запрос достигнет вашего сайта.
    </para>

    <para>
      Приведём несколько примеров:
      <itemizedlist>
	<listitem>
	  <para>
	    Ваш провайдер может кэшировать определённые страницы, таким
	    образом, если вы обращаетесь к странице сайта
	    <token>http://example.com/</token>, ваш провайдер отдаст
	    вам страницу, не выполняя запрос к сайту. Владельца сайта
	    не будут знать об этом механизме кэширования. Провайдер
	    находится между вами и сайтом, прозрачно выполняя все
	    операции по кэшированию.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Ваш сайт может находится за <emphasis>прокси
	    кэшем</emphasis>, таким как Squid (<ulink
	    url="http://www.squid-cache.org/"/>), который кэширует
	    страницы для улучшения производительности сайта. В этом
	    случае, каждый запрос сначала будет обработан прокси и
	    затем, при необходимости, будет передан вашему приложению.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Ваш браузер также может кэшировать страницы. Если страница
	    отправляет определённые заголовки, браузер будет
	    использовать локальную копию для последующих обращений к
	    странице без доступа к сайту даже для проверки обновления
	    страницы.
	  </para>
	</listitem>
      </itemizedlist>
    </para>

    <para>
      Этот вид кэширования имеет достаточную эффективность, но несёт в
      себе опасность. Содержимое страниц многих сайтов различается в
      зависимости от того, авторизован ли посетитель или нет, а также
      от многих других факторов. Механизмы кэширования могут слепо
      сохранять страницы, основываясь на IRL, которые могут содержать
      неверную или секретную информацию от предыдущих посетителей
      запрашиваемых страниц.
    </para>

    <para>
      Например, скажем вы работаете с веб интерфейсом к электронной
      почте и содержимое страницы <quote>Мой почтовый ящик</quote>
      очевидно зависит от авторизованного пользователя. Если провайдер
      слепо закэшироует ваш сайт, то первый же посетитель этой
      страницы получит страницу, которая предназначалась (и была
      помещена в кэш) для вас. Это нехорошо.
    </para>

    <para>
      К счастью, HTTP предоставляет решения для этой
      проблемы. Существует ряд HTTP заголовков, который указывает
      кэшам верхнего уровня, что надо изменять своё содержимое в
      зависимости от указанных переменных и что не следует кэшировать
      определённые страницы. Мы рассмотрим такие заголовки в следующих
      секциях.
    </para>

    <section id="&BASEID;.upstream-caches.vary-headers">
    
      <title id="&BASEID;.upstream-caches.vary-headers.title">
	Использование заголовков Vary
      </title>
      
      <para>
	Заголовок <token>Vary</token> определяет какой из заголовков
	запроса должен рассматриваться механизмом
	кэширования. Например, если содержимое страницы зависит от
	языковой настройки пользователя, страница укажет на это с
	помощью заголовка.
      </para>

      <para>
	По умолчанию механизм кэширования Django создаёт записи в
	кэше, используя заданный путь (т.е.,
	<token>/stories/2005/jun/23/bank_robbed/</token>). Это
	означает, что каждый запрос по этому URL будет использовать
	версию страницы из кэша, независимо от разницы между агентами
	пользователя (<token>user-agent</token>), такими как cookie
	или языковые настройки. Тем не менее, если эта страница
	генерирует различное содержание, основываясь на информации из
	заголовков запроса, таких как cookie или язык или другой агент
	пользователя, вам потребуется использовать заголовок
	<token>Vary</token>, чтобы механизм кэширования знал эту
	зависимость.
      </para>

      <para>
	Для использования этого в Django следует использовать удобный
	декоратор для представления <token>vary_on_headers</token>,
	вот такой:
	<screen>
	  <![CDATA[
from django.views.decorators.vary import vary_on_headers

# Синтаксис для Python 2.3.
def my_view(request):
    # ...
my_view = vary_on_headers(my_view, 'User-Agent')

# Синтаксис для Python 2.4+.
@vary_on_headers('User-Agent')
def my_view(request):
    # ...
	  ]]>
	</screen>
      </para>

      <para>
	В данном случае механизм кэширования (такой как в Django)
	сохраняет отдельную версию страницы для каждого уникального
	агента пользователя.
      </para>

      <para>
	Преимущество в использовании декоратора
	<token>vary_on_headers</token> вместо ручного указания
	заголовка <token>Vary</token> (как-то так
	<token>response['Vary'] = 'user-agent'</token>) в том, что
	декоратор <emphasis>добавляет</emphasis> информацию к
	заголовку <token>Vary</token> (а он может уже существовать), а
	не перезаписывает уже имеющиеся в нём данные.
      </para>

      <para>
	Вы можете передать несколько заголовков в
	<function>vary_on_headers()</function>:
	<screen>
	  <![CDATA[
@vary_on_headers('User-Agent', 'Cookie')
def my_view(request):
    # ...
	  ]]>
	</screen>
      </para>

      <para>
	Это указывает кэшу верхнего уровня, что ему надо учитывать
	<emphasis>оба</emphasis> варианта, что означает любую
	комбинацию агента пользователя и cookie. Например, запрос от
	агента <token>Mozilla</token> с cookie <token>foo=bar</token>
	будет рассматриваться отдельно от запроса агента
	<token>Mozilla</token> и cookie <token>foo=ham</token>.
      </para>

      <para>
	Так как обычно все используют cookie для различения запросов,
	нашлось место и для декоратора
	<token>vary_on_cookie</token>. Представления, приведённые
	ниже, эквивалентны:
	<screen>
	  <![CDATA[
@vary_on_cookie
def my_view(request):
    # ...

@vary_on_headers('Cookie')
def my_view(request):
    # ...
	  ]]>
	</screen>
      </para>

      <para>
	Регистр заголовков, передаваемых в
	<function>vary_on_headers()</function>, не имеет
	значения. Заголовок <token>User-Agent</token> эквивалентен
	<token>user-agent</token>.
      </para>

      <para>
	Вы также можете напрямую использовать вспомогательную функцию
	<token>django.utils.cache.patch_vary_headers</token>. Эта
	функция устанавливает или добавляет заголовок
	<token>Vary</token>, например:
	<screen>
	  <![CDATA[
from django.utils.cache import patch_vary_headers

def my_view(request):
    # ...
    response = render_to_response('template_name', context)
    patch_vary_headers(response, ['Cookie'])
    return response
	  ]]>
	</screen>
      </para>

      <para>
	Метод <function>patch_vary_headers()</function> принимает
	экземпляр <token>HttpResponse</token> в качестве первого
	аргумента и список или кортеж регистронезависимых имён
	заголовков в качестве второго аргумента.
      </para>

    </section>

    <section id="&BASEID;.upstream-caches.other-cache-headers">
    
      <title id="&BASEID;.upstream-caches.other-cache-headers.title">
	Другие заголовки для механизма кэширования
      </title>
      
      <para>
	Другими проблемами при использовании кэширования являются
	секретность данных и вопрос хранения данных в каскадных кэшах.
      </para>

      <para>
	Пользователь обычно сталкивается с двумя видами кэшей: кэш
	браузера (частный кэш) и кэш провайдера (общий кэш). Общий кэш
	используется рядом пользователей и находится под контролем
	третьего лица. Это вызывает проблему надёжности
	данных. Скажем, вам не захочется, чтобы номер вашего
	банковского счета был сохранён в общем кэше. Таким образом веб
	приложения должны иметь способ указать кэшу, какие данные
	являются частными, а какие нет.
      </para>

      <para>
	Решением будет указание кэшу, что страница будет частной. Для
	того, чтобы сделать это в Django следует использовать
	декоратор <token>cache_control</token>:
	<screen>
	  <![CDATA[
from django.views.decorators.cache import cache_control

@cache_control(private=True)
def my_view(request):
    # ...
	  ]]>
	</screen>
      </para>

      <para>
	Этот декоратор заботится об автоматической отправке
	соответствующих HTTP заголовков.
      </para>

      <para>
	Существует несколько способов управления параметрами
	кэша. Например, HTTP позволяет приложения выполнять следующее:
	<itemizedlist>
	  <listitem>
	    <para>
	      Определять максимальное время кэширования для страницы.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      Указывать должен ли кэш всегда проверять наличие новых
	      версий и использовать сохранённые данные, только если не
	      было изменений. (Некоторые кэши могут доставлять
	      сохранённые данные даже в том случае, когда оригинальная
	      страница имеет изменения, просто по той причине, что ещё
	      не истёк срок действия закэшированной копии.)
	    </para>
	  </listitem>
	</itemizedlist>
      </para>

      <para>
	Используйте декоратор <token>cache_control</token> в Django
	для определения этих параметров кэширования. В этом примере
	<token>cache_control</token> указывает, что требуется
	проверять наличие изменений в оригинальной странице при каждом
	доступе к ней и сохранять в кэше копии максимум 3600 секунд:
	<screen>
	  <![CDATA[
from django.views.decorators.cache import cache_control
@cache_control(must_revalidate=True, max_age=3600)
def my_view(request):
    ...
	  ]]>
	</screen>
      </para>

      <para>
	Любая разрешённая HTTP директива для
	<token>Cache-Control</token> разрешена и для
	<function>cache_control()</function>. Приведём полный список:
	<itemizedlist>
	  <listitem>
	    <para>
	      <token>public=True</token>
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <token>private=True</token>
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <token>no_cache=True</token>
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <token>no_transform=True</token>
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <token>must_revalidate=True</token>
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <token>proxy_revalidate=True</token>
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <token>max_age=num_seconds</token>
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <token>s_maxage=num_seconds</token>
	    </para>
	  </listitem>
	</itemizedlist>

	<note>
	  <title>
	    Совет
	  </title>

	  <para>
	    Для более подробной информации о HTTP директивах
	    <token>Cache-Control</token> обратитесь к спецификации на
	    <ulink
	    url="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9"/>.
	  </para>
	</note>

	<note>
	  <para>
	    Механизм кэширования всегда устанавливает элемент
	    <token>max_age</token> заголовка кэша в соответствии со
	    значением из
	    <token>CACHE_MIDDLEWARE_SETTINGS</token>. Если вы
	    используете своё значение для <token>max_age</token> в
	    декораторе <function>cache_control()</function>, декоратор
	    будет иметь преимущество и значения заголовков будут
	    объединены корректно.
	  </para>
	</note>
      </para>

    </section>

  </section>	

  <section id="&BASEID;.optimizing">
    
    <title id="&BASEID;.optimizing.title">
      Оптимизация
    </title>
      
    <para>
      Django поставляется с несколькими другими механизмами, которые
      могут помочь в оптимизации вашего приложения:
      <itemizedlist>
	<listitem>
	  <para>
	    <token>django.middleware.http.ConditionalGetMiddleware</token>
	    добавляет поддержку для современных браузеров для условных
	    GET откликов, основанную на заголовках <token>ETag</token>
	    и <token>Last-Modified</token>.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    <token>django.middleware.gzip.GZipMiddleware</token>
	    сжимает ответ для всех современных браузеров, снижая
	    нагрузку на сеть и время ожидания пользователя.
	  </para>
	</listitem>
      </itemizedlist>
    </para>

  </section>
      
  <section id="&BASEID;.order">
    
    <title id="&BASEID;.order.title">
      Порядок в MIDDLEWARE_CLASSES
    </title>
      
    <para>
      При использовании <token>CacheMiddleware</token> важно
      располагать его в правильном месте в параметре
      <token>MIDDLEWARE_CLASSES</token>, потому что механизм
      кэширования должен получить информацию о заголовке, относительно
      которого ему придётся принимать решение о кэшировании страниц.
    </para>

    <para>
      Следует размещать <token>CacheMiddleware</token> после других
      значений параметра, которые могут добавлять что-то в заголовок
      <token>Vary</token>, включая следующие:
      <itemizedlist>
	<listitem>
	  <para>
	    <token>SessionMiddleware</token>, который добавляет
	    <token>Cookie</token>.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    <token>GZipMiddleware</token>, который добавляет
	    <token>Accept-Encoding</token>.
	  </para>
	</listitem>
      </itemizedlist>
    </para>

  </section>

</chapter>
