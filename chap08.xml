<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
"http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd"
[
<!ENTITY BASEID "djangobook.chap08">
]>

<chapter lang="ru" id="&BASEID;">

  <title id="&BASEID;.title">
    Усовершенствованные представления и схемы URL
  </title>

  <para>
    Перевод &copy; Попов Руслан &lt;ruslan.popov &bull; gmail &bull; com&gt;
  </para>

  <para>
    Перевод &copy; Дмитрий Косточно &lt;alerion.um &bull; gmail &bull; com&gt;
  </para>

  <para>
    В главе <quote><xref linkend="djangobook.chap03"
    endterm="djangobook.chap03.title"/></quote> мы рассказали о
    функциях представлений Django и о схеме URL, в которой определено
    соответствие URL этим функциям. Эта глава остановится на этих
    вопросах более подробно.
  </para>

  <section id="&BASEID;.urlconf-tricks">

    <title id="&BASEID;.urlconf-tricks.title">
      Схема URL: полезные приёмы
    </title>

    <para>
      В схеме URL нет ничего особенного, как и всё остальное в Django
      &mdash; это просто код на языке Python. Вы можете использовать
      это знание различными способами, как показано в разделах главы
      далее.
    </para>

    <section id="&BASEID;.urlconf-tricks.stream-func-import">

      <title id="&BASEID;.urlconf-tricks.stream-func-import.title">
        Упорядочивание функций импорта
      </title>

      <para>
        Рассмотрим нижеприведённый файл со схемой URL, созданой по
        примеру главы <quote><xref linkend="djangobook.chap03"
        endterm="djangobook.chap03.title"/></quote>:
        <screen>
          <![CDATA[
from django.conf.urls.defaults import *
from mysite.views import hello, current_datetime, hours_ahead

urlpatterns = patterns('',
(r'^hello/$', hello),
(r'^time/$', current_datetime),
(r'^time/plus/(\d{1,2})/$', hours_ahead),
)
          ]]>
        </screen>
      </para>

      <para>
        Как объяснялось в
        главе <quote><xref linkend="djangobook.chap03"
        endterm="djangobook.chap03.title"/></quote>, каждый шаблон
        схемы URL ассоциирован с функцией представления, которая
        указывается в виде функционального объекта. Это означает, что
        необходимо импортировать функции представления вначале модуля.
      </para>

      <para>
        Но, по мере усложнения Django приложения, его схема URL также
        растёт, управление этими импортами может быть
        утомительным. (Для каждой новой функции представления вам
        потребуется не забыть об её импорте, это скажется на размере
        оператора импорта.) Есть возможность избежать этого, просто
        импортируя сам модуль <token>views</token> . Следующий пример
        эквивалентен предыдущему:
        <screen>
          <![CDATA[
from django.conf.urls.defaults import *
from mysite import views

urlpatterns = patterns('',
(r'^hello/$', views.hello),
(r'^time/$', views.current_datetime),
(r'^time/plus/(d{1,2})/$', views.hours_ahead),
)
          ]]>
        </screen>
      </para>

      <para>
        Django предоставляет другой способ указания функции
        представления для определённого шаблона в схеме URL. Вы можете
        передать строку, которая содержит имя модуля и имя функции,
        вместо передачи самого объекта. Продолжаем работу над нашим
        примером:
        <screen>
          <![CDATA[
from django.conf.urls.defaults import *

urlpatterns = patterns('',
(r'^hello/$', 'mysite.views.hello'),
(r'^time/$', 'mysite.views.current_datetime'),
(r'^time/plus/(d{1,2})/$', 'mysite.views.hours_ahead'),
)
          ]]>
        </screen>
      </para>

      <para>
        Следует отметить кавычки вокруг имён представления! Мы используем
        <token>'mysite.views.current_datetime'</token> с кавычками
        вместо <token>mysite.views.current_datetime</token>
      </para>

      <para>
        Используя этот метод, больше нет необходимости импортировать
        функции представления. Django автоматически импортирует
        соответствующую функцию представления как только она
        понадобится, в соответствии с текстовым описанием её имени и
        пути.
      </para>

      <para>
        Ещё сильнее код можно сократить, используя общий префикс для
        пути к функциям представления. В нашем примере, каждая строка
        начиналась с <token>mysite.views</token>, т.е. опять
        дублирование. Мы можем исключить этот общий префикс и передать
        его в качестве первого аргумента функции
        <function>patterns()</function>, например так:
        <screen>
          <![CDATA[
from django.conf.urls.defaults import *

urlpatterns = patterns('mysite.views',
(r'^hello/$', 'hello'),
(r'^time/$', 'current_datetime'),
(r'^time/plus/(d{1,2})/$', 'hours_ahead'),
)
          ]]>
        </screen>
      </para>

      <para>
        Следует заметить, что не надо ставить завершающую точку в
        префикс и не надо ставить точку перед именами функций
        представления. Всё это будет автоматически сделано Django.
      </para>

      <para>
        Так какой из этих двух подходов лучше? Это зависит от вашего
        стиля написания кода и ваших нужд.
      </para>

      <para>
        Преимущества использования строк вместо объектов:
        <itemizedlist>
          <listitem>
            <para>
              Краткий код, т.к. не требуется импортировать функции
              представления.
            </para>
          </listitem>

          <listitem>
            <para>
              Более читаемая и управляемая схема URL в случае, если
              ваши функции представления располагаются в нескольких
              различных модулях.
            </para>
          </listitem>
        </itemizedlist>
      </para>

      <para>
        Преимущества использования объектов вместо строк:
        <itemizedlist>
          <listitem>
            <para>
              Простая замена функций представления. Обратитесь к
              разделу <quote><xref
              linkend="&BASEID;.urlconf-tricks.wrapping-view-functions"
              endterm="&BASEID;.urlconf-tricks.wrapping-view-functions.title"/></quote>
              в этой главе.
            </para>
          </listitem>

          <listitem>
            <para>
              Стиль Python, сохраняются его традиции, такие как
              передача функции в виде объекта.
            </para>
          </listitem>
        </itemizedlist>
      </para>

      <para>
        Оба подхода правильные. Вы можете смешивать их в одном файле,
        описывающем схему URL. Это ваш выбор.
      </para>

    </section>

    <section id="&BASEID;.urlconf-tricks.multiple-prefixes">

      <title id="&BASEID;.urlconf-tricks.multiple-prefixes.title">
        Использование множества префиксов для представлений
      </title>

      <para>
        На практике, при использовании строчной методики вы можете
        столкнуться с ситуацией, когда функции представления в схеме
        URL не будут иметь общего префикса. Однако, это не помешает
        вам воспользоваться преимуществами префикса. Просто добавьте
        нужное количество <function>patterns()</function>, вот так:
        <screen>
          <![CDATA[
# Раньше
from django.conf.urls.defaults import *

urlpatterns = patterns('',
    (r'^hello/$', 'mysite.views.hello'),
    (r'^time/$', 'mysite.views.current_datetime'),
    (r'^time/plus/(\d{1,2})/$', 'mysite.views.hours_ahead'),
    (r'^tag/(\w+)/$', 'weblog.views.tag'),
)

# Теперь
from django.conf.urls.defaults import *

urlpatterns = patterns('mysite.views',
    (r'^hello/$', 'hello'),
    (r'^time/$', 'current_datetime'),
    (r'^time/plus/(\d{1,2})/$', 'hours_ahead'),
)

urlpatterns += patterns('weblog.views',
    (r'^tag/(\w+)/$', 'tag'),
)
          ]]>
        </screen>
      </para>

      <para>
        Всё, о чём заботится среда разработки &mdash; это о
        существовании переменной <varname>urlpatterns</varname>. Эта
        переменная может быть создана динамически, как это показано в
        примере. Следует отметить, что объекты, возвращаемые
        <function>patterns()</function>, могут быть объединены
        оператором <quote><token>+</token></quote>.
      </para>

    </section>

    <section id="&BASEID;.urlconf-tricks.debug-mode">

      <title id="&BASEID;.urlconf-tricks.debug-mode.title">
        Специальные URL в режиме отладки
      </title>

      <para>
        Говоря о динамическом построении
        <varname>urlpatterns</varname>, вы можете пожелать
        использовать преимущества этой методики для изменения
        поведения вашей схемы URL при работе Django в режиме
        отладки. Чтобы осуществить это, просто проверяйте значение
        параметра <token>DEBUG</token> во время работы приложения, вот
        так:
        <screen>
          <![CDATA[
from django.conf import settings
from django.conf.urls.defaults import *
from mysite import views

urlpatterns = patterns('',
    (r'^$', views.homepage),
    (r'^(\d{4})/([a-z]{3})/$', views.archive_month),
)

if settings.DEBUG:
    urlpatterns += patterns('',
        (r'^debuginfo/$', views.debug),
    )
          ]]>
        </screen>
      </para>

      <para>
        В этом примере URL <token>/debuginfo/</token> будет работать
        только в том случае, если параметр <token>DEBUG</token>
        установлен в <token>True</token>.
      </para>

    </section>

    <section id="&BASEID;.urlconf-tricks.named-groups">

      <title id="&BASEID;.urlconf-tricks.named-groups.title">
        Использование именованных групп
      </title>

      <para>
        Ранее во всех примерах мы использовали простые,
        <emphasis>неименованные</emphasis> группы регулярных
        выражений. Мы ограничивали части URL круглыми скобками,
        которые требовалось обработать функцией представления, как
        аргументы. Существует возможность использования
        <emphasis>именованных</emphasis> групп регулярных выражений
        для получения кусков URL и последующей их передачи функции
        представления как именованных аргументов.
      </para>

      <para>
        <note>
          <title>
            Именованные аргументы или позиционные аргументы
          </title>

          <para>
            Функция в языке Python может быть вызвана с использованием
            именованных аргументов или с помощью обязательных
            аргументов, а в некоторых случаях, эти аргументы можно
            смешивать. При использовании именованных аргументов вы
            должны указать имена и значения аргументов. В противном
            случае вы просто передаёте значения, они будут назначены
            аргументам по порядку их определения в функции.
          </para>

          <para>
            Например, рассмотрим эту простую функцию:
            <screen>
              <![CDATA[
def sell(item, price, quantity):
    print "Selling %s unit(s) of %s at %s" % (quantity, item, price)
              ]]>
            </screen>
          </para>

          <para>
            Для вызова функции с помощью обязательных аргументов надо
            перечислить их в порядке, в котором они определены в
            функции:
            <screen>
              <![CDATA[
sell('Socks', '$2.50', 6)
              ]]>
            </screen>
          </para>

          <para>
            Для вызова функции с помощью именованных аргументов
            следует указать имена и значения аргументов. Следующие
            операторы эквивалентны предыдущему примеру:
            <screen>
              <![CDATA[
sell(item='Socks', price='$2.50', quantity=6)
sell(item='Socks', quantity=6, price='$2.50')
sell(price='$2.50', item='Socks', quantity=6)
sell(price='$2.50', quantity=6, item='Socks')
sell(quantity=6, item='Socks', price='$2.50')
sell(quantity=6, price='$2.50', item='Socks')
              ]]>
            </screen>
          </para>

          <para>
            Наконец, вы можете смешивать эти два подхода, пока
            обязательные аргументы находятся на своих
            местах. Следующие операторы эквивалентны предыдущим
            примерам:
            <screen>
              <![CDATA[
sell('Socks', '$2.50', quantity=6)
sell('Socks', price='$2.50', quantity=6)
sell('Socks', quantity=6, price='$2.50')
              ]]>
            </screen>
          </para>
        </note>
      </para>

      <para>
        В регулярных выражениях Python синтаксис для именованных групп
        регулярных выражений будет таким:
        <token>(?P&lt;name&gt;pattern)</token>, где
        <token>name</token> является именем группы, а <token>pattern</token>
        &mdash; неким шаблоном.
      </para>

      <para>
        Ниже дан пример файла со схемой URL, в котором используются
        неименованные группы:
        <screen>
          <![CDATA[
from django.conf.urls.defaults import *
from mysite import views

urlpatterns = patterns('',
    (r'^articles/(\d{4})/$', views.year_archive),
    (r'^articles/(\d{4})/(\d{2})/$', views.month_archive),
)
          ]]>
        </screen>
      </para>

      <para>
        Теперь приведём тот же файл, который переписан с
        использованием именованных групп:
        <screen>
          <![CDATA[
from django.conf.urls.defaults import *
from mysite import views

urlpatterns = patterns('',
    (r'^articles/(?P<year>\d{4})/$', views.year_archive),
    (r'^articles/(?P<year>\d{4})/(?P<month>\d{2})/$', views.month_archive),
)
          ]]>
        </screen>
      </para>

      <para>
        Этот пример аналогичен предыдущему за исключением одного
        тонкого различия: полученные значения передаются в функции
        представления в виде именованных аргументов.
      </para>

      <para>
        Например, при использовании не именованныхгрупп запрос к
        <token>/articles/2006/03/</token>
        будет преобразован к такому вызову функции:
        <screen>
          <![CDATA[
month_archive(request, '2006', '03')
          ]]>
        </screen>
      </para>

      <para>
        Однако при использовании именованных групп тот же самый запрос
        будет преобразован к такому вызову функции:
        <screen>
          <![CDATA[
month_archive(request, year='2006', month='03')
          ]]>
        </screen>
      </para>

      <para>
        На практике, использование именованных групп позволяет вашей
        схеме URL быть более очевидной и менее подверженной внесению
        ошибок. Вы можете менять порядок следования аргументов в ваших
        функциях представления. Следуя вышеописанным примерам, если
        нам потребуется так изменить URL, чтобы вставить месяц
        <emphasis>перед</emphasis> годом, при использовании не
        именованных групп, нам потребуется не забыть внести
        соответствующие изменения в порядок аргументов в представлении
        <token>month_archive</token>. При использовании именованных
        групп такое изменение порядка параметров в регулярном
        выражении никак не скажется на работе функции представления.
      </para>

      <para>
        Конечно, выгода от использования именованных групп идёт от
        краткости. Некоторые разработчики найдут синтаксис именованных
        групп ужасным и слишком многословным. Другим преимуществом
        именованных групп является читаемость, особенно для людей,
        незнакомых с регулярными выражениями или с вашим Django
        приложением. Ведь проще всего понять, что происходит в
        приложении, просто заглянув в файл со схемой URL, который
        использует именованные функции.
      </para>

    </section>

    <section id="&BASEID;.urlconf-tricks.algorithm">

      <title id="&BASEID;.urlconf-tricks.algorithm.title">
        Понимание алгоритма совпадения/группировки
      </title>

      <para>
        Недостаток использования именованных групп в схеме URL в том,
        что один шаблон не может содержать не именованные и именованные
        группы. Если вы попробуете так сделать, Django не отобразит
        никакой ошибки, но, вероятно, вы обнаружите, что ваша схема
        перестала работать так как ожидалось. Проще говоря, существует
        алгоритм работы парсера схемы URL в отношении именованных и
        не именованных групп в регулярных выражениях:
        <itemizedlist>
          <listitem>
            <para>
              Если есть хотя бы один именованный аргумент, то
              не именованные аргументы игнорируются.
            </para>
          </listitem>

          <listitem>
            <para>
              Иначе, передаются все не именованные аргументы в качестве
              обязательных.
            </para>
          </listitem>

          <listitem>
            <para>
              В обоих случаях передаётся дополнительная информация в
              виде именованного аргумента. Читайте далее для получения
              подробностей.
            </para>
          </listitem>
        </itemizedlist>
      </para>

    </section>

    <section id="&BASEID;.urlconf-tricks.extra-option">

      <title id="&BASEID;.urlconf-tricks.extra-option.title">
        Передача дополнительных аргументов в функции представления
      </title>

      <para>
        Случается, что иногда приходится писать незначительно
        различающиеся функции представления. Например, скажем у вас
        есть два представления, чьё содержимое идентично, исключая
        шаблоны, которые они используют:
        <screen>
          <![CDATA[
# urls.py

from django.conf.urls.defaults import *
from mysite import views

urlpatterns = patterns('',
    (r'^foo/$', views.foo_view),
    (r'^bar/$', views.bar_view),
)

# views.py

from django.shortcuts import render_to_response
from mysite.models import MyModel

def foo_view(request):
    m_list = MyModel.objects.filter(is_new=True)
    return render_to_response('template1.html', {'m_list': m_list})

def bar_view(request):
    m_list = MyModel.objects.filter(is_new=True)
    return render_to_response('template2.html', {'m_list': m_list})
          ]]>
        </screen>
      </para>

      <para>
        Мы сами дублируем код и это неэлегантно. Сначала вы можете
        решить убрать избыточность просто используя одно и то же
        представления для обоих URL, поставите скобки в URL для того,
        чтобы получить его и проверить, чтобы определить какой шаблон
        надо использовать, например так:
        <screen>
          <![CDATA[
# urls.py

from django.conf.urls.defaults import *
from mysite import views

urlpatterns = patterns('',
    (r'^(foo)/$', views.foobar_view),
    (r'^(bar)/$', views.foobar_view),
)

# views.py

from django.shortcuts import render_to_response
from mysite.models import MyModel

def foobar_view(request, url):
    m_list = MyModel.objects.filter(is_new=True)
    if url == 'foo':
        template_name = 'template1.html'
    elif url == 'bar':
        template_name = 'template2.html'
    return render_to_response(template_name, {'m_list': m_list})
          ]]>
        </screen>
      </para>

      <para>
        Проблема такого решения заключается в том, что URL переносятся
        в код. Если вы решите переименовать <token>/foo/</token> в
        <token>/fooey/</token>, вам потребуется не забыть внести
        изменения в код функции представления.
      </para>

      <para>
        Элегантное решение требует включить необязательный параметр в
        шаблон схемы URL. Каждый шаблон в схеме может включать в себя
        третий элемент: словарь именованных аргументов для передачи
        его в функцию представления.
      </para>

      <para>
        Учитывая это, мы можем переписать наш предыдущий пример так:
        <screen>
          <![CDATA[
# urls.py

from django.conf.urls.defaults import *
from mysite import views

urlpatterns = patterns('',
    (r'^foo/$', views.foobar_view, {'template_name': 'template1.html'}),
    (r'^bar/$', views.foobar_view, {'template_name': 'template2.html'}),
)

# views.py

from django.shortcuts import render_to_response
from mysite.models import MyModel

def foobar_view(request, template_name):
    m_list = MyModel.objects.filter(is_new=True)
    return render_to_response(template_name, {'m_list': m_list})
          ]]>
        </screen>
      </para>

      <para>
        Как можно увидеть, шаблон в схеме URL имеет третий параметр
        <varname>template_name</varname>
      </para>

      <para>
        Такая методика является отличным способом передачи
        дополнительной информации в функции представления с
        минимальными затратами. Эта же методика используется в
        поставляемых с Django приложениях, в основном в его основной
        системе представлений, которую мы рассмотрим в главе
        <quote><xref linkend="djangobook.chap11"
        endterm="djangobook.chap11.title"/></quote>.
      </para>

      <para>
        Следующие секции содержат ряд идей о том как вы можете
        использовать эту методику в своих проектах.
      </para>

      <section id="&BASEID;.urlconf-tricks.extra-option.faking-capture">

        <title id="&BASEID;.urlconf-tricks.extra-option.faking-capture.title">
          Faking Captured URLconf Values
        </title>

        <para>
          Допустим, у вас есть набор представлений, которые
          соответствуют шаблону, наряду с другим URL, который не
          совпадает с шаблоном, но логика его функции представления
          аналогична. В этом случае, вы можете <quote>подделать</quote>
          получение значений из URL с помощью
          дополнительной опции для обработки этого дополнительного URL
          той же функцией представления.
        </para>

        <para>
          Например, у вас может быть приложение, которое отображает
          некие данные для определённого дня, вот с такими URL:
          <screen>
            <![CDATA[
/mydata/jan/01/
/mydata/jan/02/
/mydata/jan/03/
# ...
/mydata/dec/30/
/mydata/dec/31/
            ]]>
          </screen>
        </para>

        <para>
          Довольно просто это обработать, используя синтаксис
          именованных групп:
          <screen>
            <![CDATA[
urlpatterns = patterns('',
    (r'^mydata/(?P<month>\w{3})/(?P<day>\d\d)/$', views.my_view),
)
            ]]>
          </screen>
        </para>

        <para>
          А сигнатура функции представления станет такой:
          <screen>
            <![CDATA[
def my_view(request, month, day):
    # ....
            ]]>
          </screen>
        </para>

        <para>
          Это прямолинейный подход, ничего подобного раньше вы не
          видели. Эта уловка пригодится когда понадобится добавить
          другой URL, который будет использовать
          <token>my_view</token>, но её URL не будет обрабатывать
          <token>month</token> и/или <token>day</token>.
        </para>

        <para>
          Например, вы можете добавить другой URL,
          <token>/mydata/birthday/</token>, который будет аналогичен
          <token>/mydata/jan/06/</token>. В этом случае использование
          дополнительного параметра даст вам преимущество:
          <screen>
            <![CDATA[
urlpatterns = patterns('',
    (r'^mydata/birthday/$', views.my_view, {'month': 'jan', 'day': '06'}),
    (r'^mydata/(?P<month>\w{3})/(?P<day>\d\d)/$', views.my_view),
)
            ]]>
          </screen>
        </para>

        <para>
          Секрет в том, что не требуется вносить какие-либо изменения
          в код функции представления. Функция должна
          <emphasis>обрабатывать</emphasis> параметры
          <varname>month</varname> и <varname>day</varname>, не важно
          получены ли они из URL или через дополнительные параметры.
        </para>

      </section>

      <section id="&BASEID;.urlconf-tricks.extra-option.making-view-generic">

        <title id="&BASEID;.urlconf-tricks.extra-option.making-view-generic.title">
          Переход к обобщённым представлениям
        </title>

        <para>
          Снижение количества дублирующего кода является хорошим тоном
          разработки программного обеспечения. Например, эти функции,
          написанные на языке Python:
          <screen>
          <![CDATA[
def say_hello(person_name):
    print 'Hello, %s' % person_name

def say_goodbye(person_name):
    print 'Goodbye, %s' % person_name
          ]]>
          </screen>
        </para>

        <para>
          мы можем упростить, выделив приветствие в параметр функции:
          <screen>
            <![CDATA[
def greet(person_name, greeting):
    print '%s, %s' % (greeting, person_name)
            ]]>
          </screen>
        </para>

        <para>
          Вы можете использовать эту философию применимо к
          представлениям Django, используя дополнительные параметры
          шаблонов схемы URL.
        </para>

        <para>
          Учитывая это, вы можете начать создание высокоуровневых
          абстракций для ваших представлений. Вместо того, чтобы
          думать <quote>Это представление отображает список объектов
          <classname>Event</classname></quote>
          или <quote>Этопредставление отображает список объектов
          <classname>BlogEntry</classname></quote>, рассматривайте их
          как два особых случая<quote>Представление, которое
          отображает список объектов, где тип объекта является
          переменной</quote>.
        </para>

        <para>
          Для примера рассмотрим следующий код:
          <screen>
            <![CDATA[
# urls.py

from django.conf.urls.defaults import *
from mysite import views

urlpatterns = patterns('',
    (r'^events/$', views.event_list),
    (r'^blog/entries/$', views.entry_list),
)

# views.py

from django.shortcuts import render_to_response
from mysite.models import Event, BlogEntry

def event_list(request):
    obj_list = Event.objects.all()
    return render_to_response('mysite/event_list.html', {'event_list': obj_list})

def entry_list(request):
    obj_list = BlogEntry.objects.all()
    return render_to_response('mysite/blogentry_list.html', {'entry_list': obj_list})
            ]]>
          </screen>
        </para>

        <para>
          Эти два представления делают то же самое: они отображают
          список объектов. Таким образом, можно упростить тип объекта,
          который они отображают:
          <screen>
          <![CDATA[
# urls.py

from django.conf.urls.defaults import *
from mysite import models, views

urlpatterns = patterns('',
    (r'^events/$', views.object_list, {'model': models.Event}),
    (r'^blog/entries/$', views.object_list, {'model': models.BlogEntry}),
)

# views.py

from django.shortcuts import render_to_response

def object_list(request, model):
    obj_list = model.objects.all()
    template_name = 'mysite/%s_list.html' % model.__name__.lower()
    return render_to_response(template_name, {'object_list': obj_list})
          ]]>
          </screen>
        </para>

        <para>
          Внеся небольшие изменения, мы неожиданно получили образцовое
          представление, пригодное для многократного
          использования. Начиная с этого момента, как только нам
          понадобится представление, которое отображает набор объектов
          в виде списка, мы можем просто использовать представление
          <token>object_list</token>, вместо создания ещё одного
          представления. Теперь рассмотрим, что же мы сделали:
          <itemizedlist>
            <listitem>
              <para>
                Мы напрямую передаём классы модели, используя параметр
                <varname>model</varname>. Словарь с дополнительными
                параметрами может передавать в представление объект
                Python любого типа, а не только строки.
              </para>
            </listitem>

            <listitem>
              <para>
                Строка <token>model.objects.all()</token> является
                примером <emphasis>утиного набора FIXME</emphasis>:
                <quote>
                  Если это ходит как утка и разговаривает как
                  утка, мы можем считать это уткой.
                </quote>
                Следует отметить, что код ничего не знает о типе объекта
                <varname>model</varname>, единственное требование
                &mdash; <varname>model</varname>
                должна иметь атрибут <token>objects</token>, у
                которого как раз есть метод <token>all()</token>.
              </para>
            </listitem>

            <listitem>
              <para>
                Мы используем <token>model.__name__.lower()</token>
                для того, чтобы определить имя шаблона. В Python
                каждый класс имеет атрибут <token>__name__</token>,
                который содержит имя класса. Эта особенность полезна в
                подобных случаях, когда мы не знаем имя класса во
                время работы приложения. Например, атрибут
                <token>__name__</token> класса
                <classname>BlogEntry</classname> содержит строку
                <quote>BlogEntry</quote>.
              </para>
            </listitem>

            <listitem>
              <para>
                Разница между примерами в том, что мы передаём
                обобщённую переменную <varname>object_list</varname>
                в шаблон. Мы могли легко изменить имя этой переменной на
                <varname>blogentry_list</varname> или
                <varname>event_list</varname>, но оставим это в
                качестве домашнего задания.
              </para>
            </listitem>
          </itemizedlist>
        </para>

        <para>
          Так как сайты, хранящие свои данные в базах данных,
          используют одинаковые шаблоны, Django поставляется с набором
          <quote>общие представления</quote>, который используется
          вышеописанную методику для сохранения вашего времени. Мы
          рассмотрим встроенные общие представления Django в главе
          <quote><xref linkend="djangobook.chap11"
          endterm="djangobook.chap11.title"/></quote>.
        </para>

      </section>

      <section id="&BASEID;.urlconf-tricks.extra-option.view-options">

        <title id="&BASEID;.urlconf-tricks.extra-option.view-options.title">
          Позволяем настройку представления
        </title>

        <para>
          При распространении приложения для Django может так
          случиться, что ваши пользователи пожелают внести некоторые
          изменения в конфигурацию приложения. В таком случае, хорошей
          идеей будет добавить перехватчики к вашим представлениям для
          любого параметра конфигурации, который может подвергнуться
          такому изменению. Для этого опять надо использовать
          дополнительные параметры шаблона схемы URL.
        </para>

        <para>
          Чаще всего изменению подвергаются имена шаблонов:
          <screen>
            <![CDATA[
def my_view(request, template_name):
    var = do_something()
    return render_to_response(template_name, {'var': var})
            ]]>
          </screen>
        </para>

      </section>

      <section id="&BASEID;.urlconf-tricks.extra-option.precedence">

        <title id="&BASEID;.urlconf-tricks.extra-option.precedence.title">
          Последовательность обработки значений и параметров
        </title>

        <para>
          При наличии конфликта параметров, дополнительные параметры
          шаблона схемы URL получают преимущество над передаваемыми в
          функцию параметрами. Другими словами, если ваш шаблон
          получил переменную с именованной группой, а дополнительный
          параметр включает в себя переменную с таким же именем,
          именно он и будет использован.
        </para>

        <para>
          Например:
          <screen>
            <![CDATA[
from django.conf.urls.defaults import *
from mysite import views

urlpatterns = patterns('',
    (r'^mydata/(?P<id>\d+)/$', views.my_view, {'id': 3}),
)
            ]]>
          </screen>
        </para>

        <para>
          В данном примере параметр <varname>id</varname> находится и
          в регулярном выражении и в словаре дополнительных
          параметров. Параметр из словаря получает преимущество. Это
          означает, что любой запрос (т.е., <token>/mydata/2/</token>
          или <token>/mydata/432432/</token>) будет интерпретирован
          как-будто бы параметр <token>id</token> установлен в
          <token>3</token>, независимо от значения в URL.
        </para>

        <para>
          Проницательные читатели отметят, что в данном случае захват
          переменной <varname>id</varname> с помощью регулярного
          выражения &mdash; это просто трата времени, так как
          полученное значение будет всегда перекрываться значением
          параметра <varname>id</varname> из словаря. Это правильное
          поведение, мы напоминаем об этом лишь для того, чтобы вы не
          сделали ошибку.
        </para>

      </section>

    </section>

    <section id="&BASEID;.urlconf-tricks.defargs">

      <title id="&BASEID;.urlconf-tricks.defargs.title">
        Использование стандартных аргументов для представления
      </title>

      <para>
        Другим удобным способом является указание стандартных значений
        для аргументов представления. Эти значения используются в
        случае, когда соответствующие параметры не определены при
        вызове функций.
      </para>

      <para>
        Пример:
        <screen>
          <![CDATA[
# urls.py

from django.conf.urls.defaults import *

urlpatterns = patterns('',
    (r'^blog/$', views.page),
    (r'^blog/page(?P<num>\d+)/$', views.page),
)

# views.py

def page(request, num="1"):
    # Output the appropriate page of blog entries, according to num.
    # ...
          ]]>
        </screen>
      </para>

      <para>
        В данном примере оба шаблона URL указывают на одно и то же
        представление, <token>views.page</token> , но первый шаблон не
        получает параметров из URL. Если срабатывает первый шаблон, то
        будет выполнена функция <function>page()</function> будет
        использовать стандартные значения
        аргументов(<token>num=1</token>). Если срабатывает второй
        шаблон, функция <function>page()</function> будет использовать
        значение для параметра <varname>num</varname> полученное с
        помощью регулярного выражения.
      </para>

      <para>
        Заметьте, что в качестве значения по-умолчанию мы указали
        <emphasis>строку</emphasis> <token>"1"</token>, а не число
        <token>1</token>. Это для согласованности т.к. любое полученное для
        <varname>num</varname> значение будет строкой.
      </para>

      <para>
        Как объяснялось ранее, обычно используют данную методику
        совместно с параметрами конфигурации. Этот пример немного
        улучшает пример из раздела
        <quote>
          <xref
              linkend="&BASEID;.urlconf-tricks.extra-option.view-options"
              endterm="&BASEID;.urlconf-tricks.extra-option.view-options.title"/>
          </quote>,
          предоставляя стандартное значение для <varname>template_name</varname>:
          <screen>
            <![CDATA[
def my_view(request, template_name='mysite/my_view.html'):
    var = do_something()
    return render_to_response(template_name, {'var': var})
            ]]>
          </screen>
      </para>

    </section>

    <section id="&BASEID;.urlconf-tricks.speccasingviews">

      <title id="&BASEID;.urlconf-tricks.speccasingviews.title">
        Представления для особых случаев
      </title>

      <para>
        Иногда так случается, что есть шаблон в вашей схеме URL,
        который обрабатывает большой набор URL, но вам необходимо
        реализовать для них особые случаи. Для этого надо просто
        описать эти случаи первыми.
      </para>

      <para>
        Например, страницы <quote>добавить объект</quote> на сайте
        администратора Django представлены в схеме URL такой строкой:
        <screen>
          <![CDATA[
urlpatterns = patterns('',
    # ...
    ('^([^/]+)/([^/]+)/add/$', 'django.contrib.admin.views.main.add_stage'),
    # ...
)
          ]]>
        </screen>
      </para>

      <para>
        Эта строка совпадает с URL такими как
        <token>/myblog/entries/add/</token> и
        <token>/auth/groups/add/</token>. Однако страница добавления
        пользователей (<token>/auth/user/add/</token>) является особым
        случаем &mdash; оно не отображает все поля формы, она
        отображает два поля для ввода пароля и так далее. Мы
        <emphasis>можем</emphasis> решить эту проблему реализовав
        особое поведение представления, например так:
        <screen>
          <![CDATA[
def add_stage(request, app_label, model_name):
    if app_label == 'auth' and model_name == 'user':
        # do special-case code
    else:
        # do normal code
          ]]>
        </screen>
      </para>

      <para>
        Но такой подход не элегантен по причинам, которые мы обсуждали
        чуть ранее: этот подход помещает логику обработки URL в
        представление. В качестве элегантного решения мы можем
        воспользоваться тем фактом, что шаблоны URL обрабатываются в
        порядке их определения в файле:
        <screen>
          <![CDATA[
urlpatterns = patterns('',
    # ...
    ('^auth/user/add/$', 'django.contrib.admin.views.auth.user_add_stage'),
    ('^([^/]+)/([^/]+)/add/$', 'django.contrib.admin.views.main.add_stage'),
    # ...
)
          ]]>
        </screen>
      </para>

      <para>
        Теперь вызов <token>/auth/user/add/</token> будет обработан
        представлением <token>user_add_stage</token>. Несмотря на то,
        что этот URL совпадает со вторым шаблоном, он будет обработан
        первым.
      </para>

    </section>

    <section id="&BASEID;.urlconf-tricks.captchatext">

      <title id="&BASEID;.urlconf-tricks.captchatext.title">
        Обработка совпадающего текста
      </title>

      <para>
        Каждый аргумент, полученный из URL с помощью регулярного
        выражения передаётся представлению в виде обычной
        строки. Например:
        <screen>
          <![CDATA[
(r'^articles/(?P<year>\d{4})/$', views.year_archive),
          ]]>
        </screen>
      </para>

      <para>
        Аргумент <varname>year</varname> в этой строке будет передан в
        представление <token>views.year_archive()</token> в виде
        строки, не в виде целого числа, несмотря на то, что выражение
        <token>\d{4}</token> совпадает только со строкой чисел.
      </para>

      <para>
        Эту особенность следует помнить при разработке
        приложения. Множество встроенных функций Python принимают
        объекты строго определённого типа. Общей ошибкой является
        попытка создать объект <classname>datetime.date</classname>,
        используя строковое представление даты, а не целочисленное:
        <screen>
          <![CDATA[
>>> import datetime
>>> datetime.date('1993', '7', '9')
Traceback (most recent call last):
...
TypeError: an integer is required
>>> datetime.date(1993, 7, 9)
datetime.date(1993, 7, 9)
          ]]>
        </screen>
      </para>

      <para>
        С точки зрения схемы URL это ошибка выглядит так:
        <screen>
          <![CDATA[
# urls.py

from django.conf.urls.defaults import *

urlpatterns = patterns('',
    (r'^articles/(\d{4})/(\d{2})/(\d{2})/$', views.day_archive),
)

# views.py

import datetime

def day_archive(request, year, month, day)
    # The following statement raises a TypeError!
    date = datetime.date(year, month, day)
          ]]>
        </screen>
      </para>

      <para>
        А правильно можно написать так:
        <screen>
          <![CDATA[
def day_archive(request, year, month, day):
    date = datetime.date(int(year), int(month), int(day))
          ]]>
        </screen>
      </para>

      <para>
        Следует отметить, что сам метод <function>int()</function>
        вызывает исключение <token>ValueError</token> при передаче ему
        строки, в которой есть не только цифры. Но мы избегаем эту
        ошибку в нашем случае, так как регулярное выражения в шаблоне
        URL обеспечивает передачу только цифр.
      </para>

    </section>

    <section id="&BASEID;.urlconf-tricks.what-to-search">

      <title id="&BASEID;.urlconf-tricks.what-to-search.title">
        Определение того, с чем совпадёт шаблон URL
      </title>

      <para>
        При получении запроса Django пытается найти соответствующий
        шаблон в схеме URL как для обычной строки Python (не как для
        Unicode строки). При этом параметры <token>GET</token> и
        <token>POST</token> или доменное имя не принимаются во
        внимание. Также не рассматривается начальный слэш, потому что
        каждое URL имеет начальный слэш.
      </para>

      <para>
        Например, в запросе <token>http://www.example.com/myapp/</token>
        Django будет искать шаблон URL для <token>myapp/</token>. В запросе
        <token>http://www.example.com/myapp/?page=3</token> Django
        будет искать шаблон для <token>myapp/</token>.
      </para>

      <para>
        Метод запроса (т.е. <token>GET</token>, <token>POST</token>,
        <token>HEAD</token>) <emphasis>не</emphasis> принимается во
        внимание при обработке схемы URL. Другими словами, все методы
        будут обрабатываться теми же функциями. Ветвление обработки
        запроса в зависимости от использованного метода лежит
        полностью на функциях представления.
      </para>

    </section>

    <section id="&BASEID;.urlconf-tricks.higher-level-abstractions">

      <title id="&BASEID;.urlconf-tricks.higher-level-abstractions.title">
        Высокий уровень абстракции в функциях представления
      </title>

      <para>
        Говоря о разветвлении логики в функциях представления основанных
        на методе запроса, давайте посмотрим каким красивым способом мы
        можем это сделать:
        <screen>
          <![CDATA[
# urls.py

from django.conf.urls.defaults import *
from mysite import views

urlpatterns = patterns('',
    # ...
    (r'^somepage/$', views.some_page),
    # ...
)

# views.py

from django.http import Http404, HttpResponseRedirect
from django.shortcuts import render_to_response

def some_page(request):
    if request.method == 'POST':
        do_something_for_post()
        return HttpResponseRedirect('/someurl/')
    elif request.method == 'GET':
        do_something_for_get()
       return render_to_response('page.html')
   else:
       raise Http404()
          ]]>
        </screen>
      </para>

      <para>
        В этом примере, обработка методов <token>POST</token> и
        <token>GET</token> функцией <function>some_page()</function>
        совсем отличается.  Все что у них общего это URL
        <token>/somepage/</token>. Поэтому не очень красиво
        обрабатывать их одной функцией. Было бы на много лучше, если
        бы одна функция обрабатывала запрос <token>GET</token>, а
        другая - <token>POST</token> - и вызывалась только одна,
        которая необходима для данного типа запросов.
      </para>

      <para>
        Мы можем реализовать это создав функцию, которая будет
        вызывать другие функции, руководствуясь определённой
        логикой. Этот пример покажет как этот подход поможет упростить
        нашу функцию <function>some_page()</function>.
        <screen>
          <![CDATA[
# views.py

from django.http import Http404, HttpResponseRedirect
from django.shortcuts import render_to_response

def method_splitter(request, GET=None, POST=None):
    if request.method == 'GET' and GET is not None:
        return GET(request)
    elif request.method == 'POST' and POST is not None:
        return POST(request)
    raise Http404

def some_page_get(request):
    assert request.method == 'GET'
    do_something_for_get()
    return render_to_response('page.html')

def some_page_post(request):
    assert request.method == 'POST'
    do_something_for_post()
    return HttpResponseRedirect('/someurl/')

# urls.py

from django.conf.urls.defaults import *
from mysite import views

urlpatterns = patterns('',
    # ...
    (r'^somepage/$', views.method_splitter, {'GET': views.some_page_get, 'POST': views.some_page_post}),
    # ...
)
          ]]>
        </screen>
      </para>

      <para>
        Давайте рассмотрим что она делает:
        <itemizedlist>

          <listitem>
            <para>
              Мы создали новую функцию представления
              <function>method_splitter()</function>, которая вызывает
              другие функции в соответствии с
              <token>request.method</token>. Она принимает два
              именованных аргумента <varname>GET</varname> и
              <varname>POST</varname>, которые должны быть
              <emphasis>функциями представления</emphasis>.  Если
              <token>request.method</token> равен <token>'GET'</token>
              - вызывается функция <function>GET</function>, если
              <token>'POST'</token> - <function>POST</function>. Если
              <token>request.method</token> равен чему-то
              другому(<token>HEAD</token>, например), или
              <varname>GET</varname> или <varname>POST</varname> не
              указаны, тогда вызывается исключения
              <token>Http404</token>.
            </para>
          </listitem>

          <listitem>
            <para>
              В схеме URL <token>/somepage/</token> указывает на
              <function>method_splitter()</function> и передает ей
              дополнительные параметры - функции представления для
              <varname>GET</varname> и <token>POST</token>.
            </para>
          </listitem>

          <listitem>
            <para>
              Разделяем функцию представления
              <function>some_page()</function> на две функции &mdash;
              <function>some_page_get()</function> и
              <function>some_page_post()</function>. Это на много
              лучше, чем использовать всю эту логику в одной функции.
            </para>

            <para>
              Заметьте что теперь эти функции не должны проверять
              <token>request.method</token>, потому что
              <function>method_splitter()</function> делает это.  (В
              тот момент, когда <function>some_page_post()</function>
              будет вызвана, мы можем быть уверенны, что
              <token>request.method</token> равен
              <token>'POST'</token>.)  Все же, что бы быть уверенными,
              ну и для документирования, мы добавили
              <token>assert</token>, который проверяет что в
              <token>request.method</token> то, что мы ожидаем.
            </para>
          </listitem>

        </itemizedlist>
      </para>

      <para>
        Теперь у нас есть прекрасная общая функция представления,
        которая содержит логику делегирования представления по
        <token>request.method</token>. Представление
        <function>method_splitter()</function> никакне привязано к
        нашему приложению и, следовательноЮ, мы можем использовать его
        в других проектах.
      </para>

      <para>
        Но ещё есть способ улучшить
        <function>method_splitter()</function>. Код представления
        подразумевает, что представления для <token>GET</token> и
        <token>POST</token> не принимают никаких аргументов кроме
        <token>request</token>. Что произойдёт, если нам потребуется
        использовать <function>method_splitter()</function> с
        представлениями, которые получают, например, текст из URL или
        принимают необязательные именованные аргументы?
      </para>

      <para>
        Для решения этой задаче, мы можем воспользоваться интересной
        особенностью языка Python: переменные аргументы со
        звёздочками. Сначала рассмотрим пример, а потом разберёмся с
        ним:
        <screen>
          <![CDATA[
def method_splitter(request, *args, **kwargs):
    get_view = kwargs.pop('GET', None)
    post_view = kwargs.pop('POST', None)
    if request.method == 'GET' and get_view is not None:
        return get_view(request, *args, **kwargs)
    elif request.method == 'POST' and post_view is not None:
        return post_view(request, *args, **kwargs)
    raise Http404
          ]]>
        </screen>
      </para>

      <para>
        Здесь мы переписали <function>method_splitter()</function>
        так, чтобы избавиться от неименованных аргументов в
        представлениях <token>GET</token> и <token>POST</token> в
        пользу <token>*args</token> и <token>**kwargs</token>
        (обратите внимание на звёздочки). Это особенность языка
        Python, которая позволяет функции принимать разное количество
        аргументов, имена которых не известны до момента исполнения
        кода. Если поместить одну звёздочку перед параметром в
        определении функции, то любые
        <emphasis>неименованные</emphasis> аргументы будут развёрнуты
        в единый кортеж. Если поместить две звёздочки &mdash; любые
        <emphasis>именованные</emphasis> аргументы будут развёрнуты в
        словарь.
      </para>

      <para>
        Например, для этой функции:
        <screen>
          <![CDATA[
def foo(*args, **kwargs):
    print "Positional arguments are:"
    print args
    print "Keyword arguments are:"
    print kwargs
          ]]>
        </screen>
      </para>

      <para>
        Вот результаты:
        <screen>
          <![CDATA[
>>> foo(1, 2, 3)
Positional arguments are:
(1, 2, 3)
Keyword arguments are:
{}
>>> foo(1, 2, name='Adrian', framework='Django')
Positional arguments are:
(1, 2)
Keyword arguments are:
{'framework': 'Django', 'name': 'Adrian'}
          ]]>
        </screen>
      </para>

      <para>
        Возвращаясь к <function>method_splitter()</function>, вы
        можете увидить, что мы используем <token>*args</token> и
        <token>**kwargs</token> для приёма <emphasis>любых</emphasis>
        аргументов в функцию и передачи их соответствующему
        представлению. Но перед этим, мы выполняем
        <token>kwargs.pop()</token> дл получения <token>GET</token> и
        <token>POST</token> аргументов, если они есть. (Мы используем
        <function>pop()</function> с значением по-умолчанию
        <token>None</token>, чтобы избежать <token>KeyError</token>
        при отсутствии аргументов.)
      </para>
    </section>

    <section id="&BASEID;.urlconf-tricks.wrapping-view-functions">

      <title id="&BASEID;.urlconf-tricks.wrapping-view-functions.title">
        Оборачивание функций представления
      </title>

      <para>
        Наша последняя уловка также основана на особенностях языка
        Python. Скажем, вы обнаружили, что постоянно повторяете кусок
        кода в своих представлениях, например:
        <screen>
          <![CDATA[
def my_view1(request):
    if not request.user.is_authenticated():
        return HttpResponseRedirect('/accounts/login/')
        # ...
    return render_to_response('template1.html')

def my_view2(request):
    if not request.user.is_authenticated():
        return HttpResponseRedirect('/accounts/login/')
    # ...
    return render_to_response('template2.html')

def my_view3(request):
    if not request.user.is_authenticated():
        return HttpResponseRedirect('/accounts/login/')
    # ...
    return render_to_response('template3.html')
          ]]>
        </screen>
      </para>

      <para>
        Здесь, каждое представление начинается с проверки
        аутентификации <token>request.user</token> (залогинился ли
        пользователь на сайте или нет) и последующего перенаправления
        на <token>/accounts/login/</token>, если аутентификация не
        пройдена. (Следует отметить, что мы ещё не касались
        <token>request.user</token> &mdash; обратитесь к главе
        <quote><xref linkend="djangobook.chap14"
        endterm="djangobook.chap14.title"/></quote>, но как вы можете
        представить, объект <token>request.user</token> представляет
        текущего пользователя (анонимного или аутентифицировавшегося).
      </para>

      <para>
        Будет неплохо убрать этот повторяющийся код из каждого
        представления и просто пометить их как нуждающихся в
        аутентифицировании пользователя. Мы можем реализовать это с
        помощью обёртывания представления. Изучите следующий код:
        <screen>
          <![CDATA[
def requires_login(view):
    def new_view(request, *args, **kwargs):
        if not request.user.is_authenticated():
            return HttpResponseRedirect('/accounts/login/')
        return view(request, *args, **kwargs)
    return new_view
          ]]>
        </screen>
      </para>

      <para>
        Эта функция, <function>requires_login</function>, принимает
        функцию представления (<token>view</token>) и возвращает новую
        функцию представления (<token>new_view</token>). Новая функция
        определена <emphasis>внутри</emphasis>
        <function>requires_login</function> и обрабатывает логику
        проверки <token>request.user.is_authenticated()</token>, а
        затем передаёт управление функции представления
        (<token>view</token>).
      </para>

      <para>
        Теперь мы можем удалить проверку <token>if not
        request.user.is_authenticated()</token> из наших функций
        представления и просто обернуть их с помощью
        <function>requires_login</function> в нашей схеме URL:
        <screen>
          <![CDATA[
from django.conf.urls.defaults import *
from mysite.views import requires_login, my_view1, my_view2, my_view3

urlpatterns = patterns('',
    (r'^view1/$', requires_login(my_view1)),
    (r'^view2/$', requires_login(my_view2)),
    (r'^view3/$', requires_login(my_view3)),
)
          ]]>
        </screen>
      </para>

      <para>
        Всё будет работать как и раньше, но код будет менее
        избыточным. Сейчас мы создали общую функцию &mdash;
        <function>requires_login</function>, с помощью которой мы
        можем легко добавлять функционал проверки аутентификации
        пользователя к любой функции представления.
      </para>
    </section>

  </section>

  <section id="&BASEID;.urlconf-include">

    <title id="&BASEID;.urlconf-include.title">
      Подключение других схем URL
    </title>

    <para>
      Если вы планируете использовать ваш код в нескольких Django
      сайтах, вам следует переработать ваш файл со схемой URL таким
      образом, чтобы он позволял включать другие схемы.
    </para>

    <para>
      В любом случае ваша схема может <quote>подключать</quote> другие
      схемы. По существу происходит <quote>внедрение</quote> набора URL
      после этой команды. Например:
      <screen>
        <![CDATA[
from django.conf.urls.defaults import *

urlpatterns = patterns('',
    (r'^weblog/', include('mysite.blog.urls')),
    (r'^photos/', include('mysite.photos.urls')),
    (r'^about/$', 'mysite.views.about'),
)
        ]]>
      </screen>
    </para>

    <para>
      Здесь есть важный момент: регулярные выражения в этом примере,
      которые указывают на <function>include()</function> <emphasis>не
      имеют</emphasis> символа <token>$</token>, но
      <emphasis>имеют</emphasis> завершающий слэш. Когда Django
      встречает <function>include()</function> он отрезает совпавшую
      часть от URL и отправляет оставшуюся часть в подключенные схемы
      для дальнейшей обработки.
    </para>

    <para>
      Продолжая работу над нашим примером
      <footnote>
        <para>
          См. предыдущий пример. Данный код
          подключается командой
          <token>include('mysite.blog.urls')</token>.
        </para>
      </footnote>
      :
      <screen>
        <![CDATA[
from django.conf.urls.defaults import *

urlpatterns = patterns('',
    (r'^(\d\d\d\d)/$', 'mysite.blog.views.year_detail'),
    (r'^(\d\d\d\d)/(\d\d)/$', 'mysite.blog.views.month_detail'),
)
        ]]>
      </screen>
    </para>

    <para>
      Используя эти две схемы URL, покажем как будут обработаны
      тестовые запросы:
      <itemizedlist>
        <listitem>
          <para>
            <token>/weblog/2007/</token>: В первом наборе привязок
            совпадёт шаблон <token>r'^weblog/'</token>. Так как для
            этого шаблона используется <function>include()</function>,
            Django отрежет совпавший текст, в данном случае это будет
            <token>weblog/</token>. Оставшаяся часть URL(т.е.
            <token>2007/</token>) совпадёт с первым шаблоном в
            <token>mysite.blog.urls</token>.
          </para>
        </listitem>

        <listitem>
          <para>
            <token>/weblog//2007/</token>: В первом наборе привязок
            совпадёт шаблон <token>r'^weblog/'</token>.Так как для
            этого шаблона используется <function>include()</function>,
            Django отрежет совпавший текст, в данном случае это будет
            <token>weblog/</token>. Оставшаяся часть URL
            (т.е.<token>/2007/</token>, с ведущим слэшом) не совпадёт
            ни с одним шаблоном в <token>mysite.blog.urls</token>.
          </para>
        </listitem>

        <listitem>
          <para>
            <token>/about/</token>: Этот запрос будет обработан
            представлением <token>mysite.views.about</token> в первом
            наборе привязок, показывая, что вы можете смешивать
            подключаемые шаблоны со встроенными.
          </para>
        </listitem>
      </itemizedlist>
    </para>

    <section id="&BASEID;.urlconf-include.how-work-captured">

      <title id="&BASEID;.urlconf-include.how-work-captured.title">
        Как совпавшие параметры работают совместно с include()
      </title>

      <para>
        Подключенный набор привязок получает любые параметры от
        родительского набора, например:
        <screen>
          <![CDATA[
# root urls.py

from django.conf.urls.defaults import *

urlpatterns = patterns('',
    (r'^(?P<username>\w+)/blog/', include('foo.urls.blog')),
)

# foo/urls/blog.py

from django.conf.urls.defaults import *

urlpatterns = patterns('',
    (r'^$', 'foo.views.blog_index'),
    (r'^archive/$', 'foo.views.blog_archive'),
)
          ]]>
        </screen>
      </para>

      <para>
        В этом примере, захваченная переменная <varname>username</varname>
        передаётся в подключенный набор привязок и, следовательно, в
        <emphasis>каждую</emphasis> функцию представления внутри этого набора.
      </para>

      <para>
        Следует отметить, что захваченные параметры будут
        <emphasis>всегда</emphasis> передаваться
        <emphasis>каждой</emphasis> строке подключенного набора
        привязок, независимо от того, принимает ли представление в
        этой строке такие параметры. По этой причине, эта методика
        полезна только в случае, когда вы уверены, что каждое
        представление в подключенном наборе привязок может принять
        передаваемые параметры.
      </para>

    </section>

    <section id="&BASEID;.urlconf-include.how-work-extra">

      <title id="&BASEID;.urlconf-include.how-work-extra.title">
        Как работают дополнительные параметры совместно с include()
      </title>

      <para>
        Аналогично, вы можете передавать дополнительные параметры в
        наборе привязок в подключаемые наборы, подобно тому, как такие
        параметры передаются в обычное представление &mdash; в виде
        словаря. Как только вы сделаете это, <emphasis>каждая</emphasis>
        строка подключенного набора получит эти параметры.
      </para>

      <para>
        Например, следующие два набора привязок функционально
        идентичны.
      </para>

      <para>
        Первый:
        <screen>
          <![CDATA[
# urls.py

from django.conf.urls.defaults import *

urlpatterns = patterns('',
    (r'^blog/', include('inner'), {'blogid': 3}),
)

# inner.py

from django.conf.urls.defaults import *

urlpatterns = patterns('',
    (r'^archive/$', 'mysite.views.archive'),
    (r'^about/$', 'mysite.views.about'),
    (r'^rss/$', 'mysite.views.rss'),
)
          ]]>
        </screen>
      </para>

      <para>
        Второй:
        <screen>
          <![CDATA[
# urls.py

from django.conf.urls.defaults import *

urlpatterns = patterns('',
    (r'^blog/', include('inner')),
)

# inner.py

from django.conf.urls.defaults import *

urlpatterns = patterns('',
    (r'^archive/$', 'mysite.views.archive', {'blogid': 3}),
    (r'^about/$', 'mysite.views.about', {'blogid': 3}),
    (r'^rss/$', 'mysite.views.rss', {'blogid': 3}),
)
          ]]>
        </screen>
      </para>

      <para>
        Подобно случаю с захваченными параметрами (которые мы
        рассматривали ранее), дополнительные параметры будут
        <emphasis>всегда</emphasis> передаваться <emphasis>каждой</emphasis>
        строке подключенного набора
        привязок, независимо от того, может ли функция представления
        правильно обработать такие параметры. По этой причине, эта
        методика полезна только в случае, когда вы уверены, что каждое
        представление в подключенном наборе привязок может принять
        передаваемые параметры.
      </para>

    </section>

  </section>

</chapter>
