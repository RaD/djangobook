<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
 "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd"
 [
<!ENTITY BASEID "djangobook.chap08">
]>

<chapter lang="ru" id="&BASEID;">
    
    <title id="&BASEID;.title">
        Усовершенствованные представления и схемы URL
    </title>

    <para>
        Перевод &copy; Попов Руслан &lt;radz &bull; yandex &bull; ru&gt;
    </para>
    
    <para>
        В главе <quote><xref linkend="djangobook.chap03" endterm="djangobook.chap03.title"/></quote>
        мы рассказали об основах функций представлений Django и о схеме URL, в которой
        определено соответствие URL этим функциям. Эта глава остановится
        на этих вопросах более подробно.
    </para>
    
    <section id="&BASEID;.urlconf-tricks">
        
        <title id="&BASEID;.urlconf-tricks.title">
            Схема URL: полезные приёмы
        </title>
        
        <para>
            В схеме URL нет ничего особенного, как всё остальное в Django,
            это просто код на языке Python. Вы можете использовать это
            знание различными способами, как показано в разделах главы
            далее.
        </para>

        <section id="&BASEID;.urlconf-tricks.stream-func-import">
            
            <title id="&BASEID;.urlconf-tricks.stream-func-import.title">
                Упорядочивание функций импорта
            </title>
            
            <para>
                Рассмотрим нижеприведённый файл со схемой URL, созданой по примеру главы 
                <quote>
                    <xref
                     linkend="djangobook.chap03"
                     endterm="djangobook.chap03.title"/>
                </quote>:
                <screen>
                    from django.conf.urls.defaults import *
                    from mysite.views import hello, current_datetime, hours_ahead

                    urlpatterns = patterns('',
                        (r'^hello/$', hello),
                        (r'^time/$', current_datetime),
                        (r'^time/plus/(\d{1,2})/$', hours_ahead),
                    )
                </screen>
            </para>
            
            <para>
                Как объяснялось в главе
                <quote>
                    <xref
                     linkend="djangobook.chap03"
                     endterm="djangobook.chap03.title"/>
                </quote>, каждый шаблон
                схемы URL ассоциирован с функцией представления, которая
                указывается в виде функционального объекта. Это означает, что
                необходимо импортировать функции представления вначале модуля.
            </para>
            
            <para>
                Но по мере усложнения Django приложения, его схема URL также
                растёт, управление этими импортами может быть
                утомительным. (Для каждой новой функции представления вам
                потребуется не забыть об её импорте, это скажется на размере
                оператора импорта.) Есть возможность избежать этого, просто
                импортируя сам модуль
                <token>
                    views
                </token>
                . Нижеприведённый
                пример эквивалентен предыдущему:
                <screen>
                    from django.conf.urls.defaults import *
                    from mysite import views

                    urlpatterns = patterns('',
                        (r'^hello/$', views.hello),
                        (r'^time/$', views.current_datetime),
                        (r'^time/plus/(d{1,2})/$', views.hours_ahead),
                    )
                </screen>
            </para>
            
            <para>
                Django предоставляет другой способ указания функции
                представления для определённого шаблона в схеме URL. Вы можете
                передать строку, которая содержит имя модуля и имя функции,
                вместо передачи самого объекта. Продолжаем работу над нашим
                примером:
                <screen>
                    from django.conf.urls.defaults import *

                    urlpatterns = patterns('',
                        (r'^hello/$', 'mysite.views.hello'),
                        (r'^time/$', 'mysite.views.current_datetime'),
                        (r'^time/plus/(d{1,2})/$', 'mysite.views.hours_ahead'),
                    )
                </screen>
            </para>
            
            <para>
                Следует отметить кавычки вокруг имён представления! Мы используем
                <quote>'mysite.views.current_datetime'</qoute> - с кавычками - 
                вместо <quote>mysite.views.current_datetime</quote>
            </para>
            
            <para>
                Используя этот метод, больше нет необходимости импортировать
                функции представления. Django автоматически импортирует
                соответствующую функцию представления как только она
                понадобится, в соответствии с текстовым описанием её имени и
                пути.
            </para>
            
            <para>
                Ещё сильнее код можно сократить, используя общий префикс для
                пути к функциям представления. В нашем примере, каждая строка
                начиналась с
                <quote>
                    mysite.views
                </quote>
                , т.е. опять
                дублирование. Мы можем исключить этот общий префикс и передать
                его в качестве первого аргумента функции
                <function>
                    patterns()
                </function>
                , например так:
                <screen>
                    from django.conf.urls.defaults import *

                    urlpatterns = patterns('mysite.views',
                        (r'^hello/$', 'hello'),
                        (r'^time/$', 'current_datetime'),
                        (r'^time/plus/(d{1,2})/$', 'hours_ahead'),
                    )
                </screen>
            </para>
            
            <para>
                Следует заметить, что не надо ставить завершающую точку в
                префикс и не надо ставить точку перед именами функций
                представления. Всё это будет автоматически сделано Django.
            </para>
            
            <para>
                Так какой из этих двух подходов лучше? Это зависит от вашего
                стиля написания кода и ваших нужд.
            </para>
            
            <para>
                Преимущества использования строк вместо объектов:
                <itemizedlist>
                    <listitem>
                        <para>
                            Краткий код, т.к. не требуется импортировать функции
                            представления.
                        </para>
                    </listitem>
                    
                    <listitem>
                        <para>
                            Более читаемая и управляемая схема URL в случае, если
                            ваши функции представления располагаются в нескольких
                            различных модулях.
                        </para>
                    </listitem>
                </itemizedlist>
            </para>
            
            <para>
                Преимущества использования объектов вместо строк:
                <itemizedlist>
                    <listitem>
                        <para>
                            Простая замена функций представления. Обратитесь к
                            разделу
                            <quote>
                                Wrapping View Functions
                            </quote>
                            FIXME
                            (что-то нет такого в оригинальной книге) в этой главе.
                        </para>
                    </listitem>
                    
                    <listitem>
                        <para>
                            Стиль Python, сохраняются его традиции, такие как
                            передача функции в виде объекта.
                        </para>
                    </listitem>
                </itemizedlist>
            </para>
            
            <para>
                Оба подхода правильные. Вы можете смешивать их в одном файле,
                описывающем схему URL. Это ваш выбор.
            </para>
            
        </section>
        
        <section id="&BASEID;.urlconf-tricks.multiple-prefixes">
            
            <title id="&BASEID;.urlconf-tricks.multiple-prefixes.title">
                Использование множества префиксов для представлений
            </title>
            
            <para>
                На практике при использовании строчной методики вы можете
                столкнуться с ситуацией, когда функции представления в схеме
                URL не будут иметь общего префикса. Однако, это не помешает
                вам воспользоваться преимуществами префикса. Просто добавьте
                нужное количество <function>patterns()</function>, вот так:
                <screen>
                    # Раньше
                    from django.conf.urls.defaults import *

                    urlpatterns = patterns('',
                        (r'^hello/$', 'mysite.views.hello'),
                        (r'^time/$', 'mysite.views.current_datetime'),
                        (r'^time/plus/(\d{1,2})/$', 'mysite.views.hours_ahead'),
                        (r'^tag/(\w+)/$', 'weblog.views.tag'),
                    )
                    
                    # Теперь
                    from django.conf.urls.defaults import *

                    urlpatterns = patterns('mysite.views',
                        (r'^hello/$', 'hello'),
                        (r'^time/$', 'current_datetime'),
                        (r'^time/plus/(\d{1,2})/$', 'hours_ahead'),
                    )

                    urlpatterns += patterns('weblog.views',
                        (r'^tag/(\w+)/$', 'tag'),
                    )
                </screen>
            </para>
            
            <para>
                Всё, о чём заботится среда разработки, &mdash; это о
                существовании переменной <varname>rlpatterns</varname>. Эта
                переменная может быть создана динамически, как это показано в
                примере. Следует отметить, что объекты, возвращаемые 
                <function>patterns()</function>, могут быть объединены оператором "+".
            </para>
            
        </section>
        
        <section id="&BASEID;.urlconf-tricks.debug-mode">
            
            <title id="&BASEID;.urlconf-tricks.debug-mode.title">
                Специальные URL в режиме отладки
            </title>
            
            <para>
                Говоря о динамическом построении <varname>urlpatterns</varname>
                , вы можете пожелать
                использовать преимущества этой методики для изменения
                поведения вашей схемы URL при работе Django в режиме
                отладки. Чтобы осуществить это, просто проверяйте значение
                параметра <token>DEBUG</token>во время работы приложения, вот так:
                <screen>
                    from django.conf import settings
                    from django.conf.urls.defaults import *
                    from mysite import views

                    urlpatterns = patterns('',
                        (r'^$', views.homepage),
                        (r'^(\d{4})/([a-z]{3})/$', views.archive_month),
                    )

                    if settings.DEBUG:
                        urlpatterns += patterns('',
                            (r'^debuginfo/$', views.debug),
                        )
                </screen>
            </para>
            
            <para>
                В этом примере URL <token>/debuginfo/</token>будет работать,
                только если параметр <token>DEBUG</token> установлен в
                <token>True</token>.
            </para>
            
        </section>
        
        <section id="&BASEID;.urlconf-tricks.named-groups">
            
            <title id="&BASEID;.urlconf-tricks.named-groups.title">
                Использование именованных групп
            </title>
            
            <para>
                Ранее во всех примерах мы использовали простые, 
                <emphasis>не именованные</emphasis> группы регулярных
                выражений. Мы ограничивали части URL круглыми скобками,
                которые требовалось обработать функцией представления, как
                аргументы. Существует возможность использования
                <emphasis>именованных</emphasis> групп регулярных выражений
                для получения кусков URL и последующей их передачи функции
                представления как именованных аргументов.
            </para>
            
            <para>
                <note>
                    <title>
                        Именованные аргументы или позиционные аргументы
                    </title>
                    
                    <para>
                        Функция в языке Python может быть вызвана с использованием
                        именованных аргументов или с помощью обязательных
                        аргументов, а в некоторых случаях, эти аргументы можно
                        смешивать. При использовании именованных аргументов вы
                        должны указать имена и значения аргументов. В противном
                        случае вы просто передаёте значения, они будут назначены
                        аргументам по порядку их определения в функции.
                    </para>
                    
                    <para>
                        Например, рассмотрим эту простую функцию:
                        <screen>
                            def sell(item, price, quantity):
                                print "Selling %s unit(s) of %s at %s" % (quantity, item, price)
                        </screen>
                    </para>
                    
                    <para>
                        Для вызова функции с помощью обязательных аргументов надо
                        перечислить их в порядке, в котором они определены в
                        функции:
                        <screen>
                            sell('Socks', '$2.50', 6)
                        </screen>
                    </para>
                    
                    <para>
                        Для вызова функции с помощью именованных аргументов
                        следует указать имена и значения аргументов. Следующие
                        операторы эквивалентны предыдущему примеру:
                        <screen>
                            sell(item='Socks', price='$2.50', quantity=6)
                            sell(item='Socks', quantity=6, price='$2.50')
                            sell(price='$2.50', item='Socks', quantity=6)
                            sell(price='$2.50', quantity=6, item='Socks')
                            sell(quantity=6, item='Socks', price='$2.50')
                            sell(quantity=6, price='$2.50', item='Socks')
                        </screen>
                    </para>
                    
                    <para>
                        Наконец, вы можете смешивать эти два подхода, пока
                        обязательные аргументы находятся на своих
                        местах. Следующие операторы эквивалентны предыдущим
                        примерам:
                        <screen>
                            sell('Socks', '$2.50', quantity=6)
                            sell('Socks', price='$2.50', quantity=6)
                            sell('Socks', quantity=6, price='$2.50')
                        </screen>
                    </para>
                </note>
            </para>
            
            <para>
                В регулярных выражениях Python синтаксис для именованных групп
                регулярных выражений будет таким:
                <token>(?P&lt;name&gt;pattern)</token>, где
                <token>name</token> является именем группы, а <token>pattern</token>
                &mdash; неким шаблоном.
            </para>
            
            <para>
                Ниже дан пример файла со схемой URL, в котором используются
                не именованные группы:
                <screen>
                    from django.conf.urls.defaults import *
                    from mysite import views

                    urlpatterns = patterns('',
                        (r'^articles/(\d{4})/$', views.year_archive),
                        (r'^articles/(\d{4})/(\d{2})/$', views.month_archive),
                    )
                </screen>
            </para>
            
            <para>
                Теперь приведём тот же файл, который переписан с
                использованием именованных групп:
                <screen>
                    <![CDATA[
from django.conf.urls.defaults import *
from mysite import views

urlpatterns = patterns('',
    (r'^articles/(?P<year>\d{4})/$', views.year_archive),
    (r'^articles/(?P<year>\d{4})/(?P<month>\d{2})/$', views.month_archive),
)
	  ]]>
                </screen>
            </para>
            
            <para>
                Этот пример аналогичен предыдущему за исключением одного
                тонкого различия: полученные значения передаются в функции
                представления в виде именованных аргументов.
            </para>
            
            <para>
                Например, при использовании не именованных групп запрос к
                <token>/articles/2006/03/</token>
                будет преобразован к такому вызову функции:
                <screen>
                    month_archive(request, '2006', '03')
                </screen>
            </para>
            
            <para>
                Однако при использовании именованных групп тот же самый запрос
                будет преобразован к такому вызову функции:
                <screen>
                    month_archive(request, year='2006', month='03')
                </screen>
            </para>
            
            <para>
                На практике, использование именованных групп позволяет вашей
                схеме URL быть более очевидной и менее подверженной внесению
                ошибок. Вы можете менять порядок следования аргументов в ваших
                функциях представления. Следуя вышеописанным примерам, если
                нам потребуется так изменить URL, чтобы вставить месяц
                <emphasis>перед</emphasis> годом, при использовании
                не именованных групп, нам потребуется не забыть внести
                соответствующие изменения в порядок аргументов в представлении
                <token>month_archive</token>. При использовании именованных
                групп такое изменение порядка параметров в регулярном
                выражении никак не скажется на работе функции представления.
            </para>
            
            <para>
                Конечно, выгода от использования именованных групп идёт от
                краткости. Некоторые разработчики найдут синтаксис именованных
                групп ужасным и слишком многословным. Другим преимуществом
                именованных групп является читаемость, особенно для людей,
                незнакомых с регулярными выражениями или с вашим Django
                приложением. Ведь проще всего понять, что происходит в
                приложении, просто заглянув в файл со схемой URL, который
                использует именованные функции.
            </para>
            
        </section>
        
        <section id="&BASEID;.urlconf-tricks.algorithm">
            
            <title id="&BASEID;.urlconf-tricks.algorithm.title">
                Понимание алгоритма совпадения/группировки
            </title>
            
            <para>
                Недостаток использования именованных групп в схеме URL в том,
                что один шаблон не может содержать не именованные и именованные
                группы. Если вы попробуете так сделать, Django не отобразит
                никакой ошибки, но, вероятно, вы обнаружите, что ваша схема
                перестала работать так как ожидалось. Проще говоря, существует
                алгоритм работы парсера схемы URL в отношении именованных и
                не именованных групп в регулярных выражениях:
                <itemizedlist>
                    <listitem>
                        <para>
                            Если есть хотя бы один именованный аргумент, то
                            не именованные аргументы игнорируются.
                        </para>
                    </listitem>
                    
                    <listitem>
                        <para>
                            Иначе, передаются все не именованные аргументы в качестве
                            обязательных.
                        </para>
                    </listitem>
                    
                    <listitem>
                        <para>
                            В обоих случаях передаётся дополнительная информация в
                            виде именованного аргумента. Читайте далее для получения
                            подробностей.
                        </para>
                    </listitem>
                </itemizedlist>
            </para>
            
        </section>
        
        <section id="&BASEID;.urlconf-tricks.extra-option">
            
            <title id="&BASEID;.urlconf-tricks.extra-option.title">
                Передача дополнительных аргументов в функции представления
            </title>
            
            <para>
                Случается, что иногда приходится писать незначительно
                различающиеся функции представления. Например, скажем у вас
                есть два представления, чьё содержимое идентично, исключая
                шаблоны, которые они используют:
                <screen>
                    # urls.py

                    from django.conf.urls.defaults import *
                    from mysite import views

                    urlpatterns = patterns('',
                        (r'^foo/$', views.foo_view),
                        (r'^bar/$', views.bar_view),
                    )

                    # views.py

                    from django.shortcuts import render_to_response
                    from mysite.models import MyModel

                    def foo_view(request):
                        m_list = MyModel.objects.filter(is_new=True)
                        return render_to_response('template1.html', {'m_list': m_list})

                    def bar_view(request):
                        m_list = MyModel.objects.filter(is_new=True)
                        return render_to_response('template2.html', {'m_list': m_list})
                </screen>
            </para>
            
            <para>
                Мы сами дублируем код и это не элегантно. Сначала вы можете
                решить убрать избыточность просто используя одно и то же
                представления для обоих URL, поставите скобки в URL для того,
                чтобы получить его и проверить, чтобы определить какой шаблон
                надо использовать, например так:
                <screen>
                    # urls.py

                    from django.conf.urls.defaults import *
                    from mysite import views

                    urlpatterns = patterns('',
                        (r'^(foo)/$', views.foobar_view),
                        (r'^(bar)/$', views.foobar_view),
                    )

                    # views.py

                    from django.shortcuts import render_to_response
                    from mysite.models import MyModel

                    def foobar_view(request, url):
                        m_list = MyModel.objects.filter(is_new=True)
                        if url == 'foo':
                            template_name = 'template1.html'
                        elif url == 'bar':
                            template_name = 'template2.html'
                        return render_to_response(template_name, {'m_list': m_list})
                </screen>
            </para>
            
            <para>
                Проблема такого решения заключается в том, что URL переносятся
                в код. Если вы решите переименовать <token>/foo/</token> в
                <token>/fooey/</token>, вам потребуется не забыть внести
                изменения в код функции представления.
            </para>
            
            <para>
                Элегантное решение требует включить необязательный параметр в
                шаблон схемы URL. Каждый шаблон в схеме может включать в себя
                третий элемент: словарь именованных аргументов для передачи
                его в функцию представления.
            </para>
            
            <para>
                Учитывая это, мы можем переписать наш предыдущий пример так:
                <screen>
                    # urls.py

                    from django.conf.urls.defaults import *
                    from mysite import views

                    urlpatterns = patterns('',
                        (r'^foo/$', views.foobar_view, {'template_name': 'template1.html'}),
                        (r'^bar/$', views.foobar_view, {'template_name': 'template2.html'}),
                    )

                    # views.py

                    from django.shortcuts import render_to_response
                    from mysite.models import MyModel

                    def foobar_view(request, template_name):
                        m_list = MyModel.objects.filter(is_new=True)
                        return render_to_response(template_name, {'m_list': m_list})
                </screen>
            </para>
            
            <para>
                Как можно увидеть, шаблон в схеме URL имеет третий параметр 
                <varname>template_name</varname>
            </para>
            
            <para>
                Такая методика является отличным способом передачи
                дополнительной информации в функции представления с
                минимальными затратами. Эта же методика используется в
                поставляемых с Django приложениях, в основном в его основной
                системе представлений, которую мы рассмотрим в главе
                <quote>
                    <xref linkend="djangobook.chap11"
                     endterm="djangobook.chap11.title"/>
                </quote>.
            </para>
            
            <para>
                Следующие секции содержат ряд идей о том как вы можете
                использовать эту методику в своих проектах.
            </para>
            
            <section id="&BASEID;.urlconf-tricks.extra-option.faking-capture">
                
                <title id="&BASEID;.urlconf-tricks.extra-option.faking-capture.title">
                    Faking Captured URLconf Values
                </title>
                
                <para>
                    Допустим, у вас есть набор представлений, которые
                    соответствуют шаблону, наряду с другим URL, который не
                    совпадает с шаблоном, но логика его функции представления
                    аналогична. В этом случае, вы можете <quote>подделать</quote>
                    получение значений из URL с помощью
                    дополнительной опции для обработки этого дополнительного URL
                    той же функцией представления.
                </para>
                
                <para>
                    Например, у вас может быть приложение, которое отображает
                    некие данные для определённого дня, вот с такими URL:
                    <screen>
                        /mydata/jan/01/
                        /mydata/jan/02/
                        /mydata/jan/03/
                        # ...
                        /mydata/dec/30/
                        /mydata/dec/31/
                    </screen>
                </para>
                
                <para>
                    Довольно просто это обработать, используя синтаксис
                    именованных групп:
                    <screen>
                        <![CDATA[
urlpatterns = patterns('',
    (r'^mydata/(?P<month>\w{3})/(?P<day>\d\d)/$', views.my_view),
)
	    ]]>
                    </screen>
                </para>
                
                <para>
                    А сигнатура функции представления станет такой:
                    <screen>
                        def my_view(request, month, day):
                        # ....
                    </screen>
                </para>
                
                <para>
                    Это прямолинейный подход, ничего подобного раньше вы не
                    видели. Эта уловка пригодится когда понадобится добавить
                    другой URL, который будет использовать
                    <token>my_view</token>, но её URL не будет обрабатывать
                    <token>month</token> и/или <token>day</token>.
                </para>
                
                <para>
                    Например, вы можете добавить другой URL,
                    <token>/mydata/birthday/</token>, который будет аналогичен
                    <token>/mydata/jan/06/</token>. В этом случае использование
                    дополнительного параметра даст вам преимущество:
                    <screen>
                        <![CDATA[
urlpatterns = patterns('',
    (r'^mydata/birthday/$', views.my_view, {'month': 'jan', 'day': '06'}),
    (r'^mydata/(?P<month>\w{3})/(?P<day>\d\d)/$', views.my_view),
)
	    ]]>
                    </screen>
                </para>
                
                <para>
                    Секрет в том, что не требуется вносить какие-либо изменения
                    в код функции представления. Функция должна
                    <emphasis>обрабатывать</emphasis> параметры 
                    <varname>month</varname> и <varname>day</varname>, не важно
                    получены ли они из URL или через дополнительные параметры.
                </para>
                
            </section>
            
            <section id="&BASEID;.urlconf-tricks.extra-option.making-view-generic">
                
                <title id="&BASEID;.urlconf-tricks.extra-option.making-view-generic.title">
                    Переход к обобщённым представлениям
                </title>
                
                <para>
                    Снижение количества дублирующего кода является хорошим тоном
                    разработки программного обеспечения. Например, эти функции,
                    написанные на языке Python:
                    <screen>
                        def say_hello(person_name):
                            print 'Hello, %s' % person_name
                        
                        def say_goodbye(person_name):
                            print 'Goodbye, %s' % person_name
                    </screen>
                </para>
                
                <para>
                    мы можем упростить, выделив приветствие в параметр функции:
                    <screen>
                        def greet(person_name, greeting):
                            print '%s, %s' % (greeting, person_name)
                    </screen>
                </para>
                
                <para>
                    Вы можете использовать эту философию применимо к
                    представлениям Django, используя дополнительные параметры
                    шаблонов схемы URL.
                </para>
                
                <para>
                    Учитывая это, вы можете начать создание высокоуровневых
                    абстракций для ваших представлений. Вместо того, чтобы
                    думать <quote>Это представление отображает список объектов
                    <classname>Event</classname></quote>
                    или <quote>Этопредставление отображает список объектов
                    <classname>BlogEntry</classname></quote>, рассматривайте их
                    как два особых случая<quote>Представление, которое
                    отображает список объектов, где тип объекта является
                    переменной</quote>.
                </para>
                
                <para>
                    Для примера рассмотрим следующий код:
                    <screen>
                        # urls.py
                        
                        from django.conf.urls.defaults import *
                        from mysite import views
                        
                        urlpatterns = patterns('',
                            (r'^events/$', views.event_list),
                            (r'^blog/entries/$', views.entry_list),
                        )
                        
                        # views.py
                        
                        from django.shortcuts import render_to_response
                        from mysite.models import Event, BlogEntry
                        
                        def event_list(request):
                            obj_list = Event.objects.all()
                            return render_to_response('mysite/event_list.html', {'event_list': obj_list})
                        
                        def entry_list(request):
                            obj_list = BlogEntry.objects.all()
                            return render_to_response('mysite/blogentry_list.html', {'entry_list': obj_list})
                    </screen>
                </para>
                
                <para>
                    Эти два представления делают то же самое: они отображают
                    список объектов. Таким образом, можно упростить тип объекта,
                    который они отображают:
                    <screen>
                        # urls.py
                        
                        from django.conf.urls.defaults import *
                        from mysite import models, views
                        
                        urlpatterns = patterns('',
                            (r'^events/$', views.object_list, {'model': models.Event}),
                            (r'^blog/entries/$', views.object_list, {'model': models.BlogEntry}),
                        )
                        
                        # views.py
                        
                        from django.shortcuts import render_to_response
                        
                        def object_list(request, model):
                            obj_list = model.objects.all()
                            template_name = 'mysite/%s_list.html' % model.__name__.lower()
                            return render_to_response(template_name, {'object_list': obj_list})
                    </screen>
                </para>
                
                <para>
                    Внеся небольшие изменения, мы неожиданно получили образцовое
                    представление, пригодное для многократного
                    использования. Начиная с этого момента, как только нам
                    понадобится представление, которое отображает набор объектов
                    в виде списка, мы можем просто использовать представление
                    <token>object_list</token>, вместо создания ещё одного
                    представления. Теперь рассмотрим, что же мы сделали:
                    <itemizedlist>
                        <listitem>
                            <para>
                                Мы напрямую передаём классы модели, используя параметр
                                <varname>model</varname>. Словарь с дополнительными
                                параметрами может передавать в представление объект
                                Python любого типа, а не только строки.
                            </para>
                        </listitem>
                        
                        <listitem>
                            <para>
                                Строка <token>model.objects.all()</token> является
                                примером<emphasis>утиного набора FIXME</emphasis>:
                                <quote>
                                    Если это ходит как утка и разговаривает как
                                    утка, мы можем считать это уткой.
                                </quote>
                                Следует отметить, что код ничего не знает о типе объекта
                                <varname>model</varname>, единственное требование
                                &mdash; <varname>model</varname>
                                должна иметь атрибут <token>objects</token>, у 
                                которого как раз есть метод <token>all()</token>.
                            </para>
                        </listitem>
                        
                        <listitem>
                            <para>
                                Мы используем <token>model.__name__.lower()</token>
                                для того, чтобы определить имя шаблона. В Python
                                каждый класс имеет атрибут <token>__name__</token>,
                                который содержит имя класса. Эта особенность полезна в
                                подобных случаях, когда мы не знаем имя класса во
                                время работы приложения. Например, атрибут
                                <token>__name__</token> класса
                                <classname>BlogEntry</classname> содержит строку
                                <quote>BlogEntry</quote>.
                            </para>
                        </listitem>
                        
                        <listitem>
                            <para>
                                Разница между примерами в том, что мы передаём
                                обобщённую переменную <varname>object_list</varname>
                                в шаблон. Мы могли легко изменить имя этой переменной на
                                <varname>blogentry_list</varname> или
                                <varname>event_list</varname>, но оставим это в 
                                качестве домашнего задания.
                            </para>
                        </listitem>
                    </itemizedlist>
                </para>
                
                <para>
                    Так как сайты, хранящие свои данные в базах данных,
                    используют одинаковые шаблоны, Django поставляется с набором
                    <quote>общие представления</quote>, который используется
                    вышеописанную методику для сохранения вашего времени. Мы
                    рассмотрим встроенные общие представления Django в 
                    главе <quote>
                        <xref linkend="djangobook.chap11"
                         endterm="djangobook.chap11.title"/>
                    </quote>.
                </para>
                
            </section>
            
            <section id="&BASEID;.urlconf-tricks.extra-option.view-options">

                <title id="&BASEID;.urlconf-tricks.extra-option.view-options.title">
                    Giving a View Configuration Options
                </title>
                
                <para>
                    При распространении приложения для Django может так
                    случиться, что ваши пользователи пожелают внести некоторые
                    изменения в конфигурацию приложения. В таком случае, хорошей
                    идеей будет добавить перехватчики к вашим представлениям для
                    любого параметра конфигурации, который может подвергнуться
                    такому изменению. Для этого опять надо использовать
                    дополнительные параметры шаблона схемы URL.
                </para>
                
                <para>
                    Чаще всего изменению подвергаются имена шаблонов:
                    <screen>
                        def my_view(request, template_name):
                            var = do_something()
                            return render_to_response(template_name, {'var': var})
                    </screen>
                </para>
                
            </section>
            
            <section id="&BASEID;.urlconf-tricks.extra-option.precedence">
                
                <title id="&BASEID;.urlconf-tricks.extra-option.precedence.title">
                    Understanding Precedence of Captured Values vs. Extra
                    Options
                </title>
                
                <para>
                    При наличии конфликта параметров, дополнительные параметры
                    шаблона схемы URL получают преимущество над передаваемыми в
                    функцию параметрами. Другими словами, если ваш шаблон
                    получил переменную с именованной группой, а дополнительный
                    параметр включает в себя переменную с таким же именем,
                    именно он и будет использован.
                </para>
                
                <para>
                    Например:
                    <screen>
                        from django.conf.urls.defaults import *
                        from mysite import views

                        urlpatterns = patterns('',
                            (r'^mydata/(?P<id>\d+)/$', views.my_view, {'id': 3}),
                        )

                    </screen>
                </para>
                
                <para>
                    В данном примере параметр <varname>id</varname> находится и
                    в регулярном выражении и в словаре дополнительных
                    параметров. Параметр из словаря получает преимущество. Это
                    означает, что любой запрос (т.е., <token>/mydata/2/</token>
                    или <token>/mydata/432432/</token>) будет интерпретирован
                    как-будто бы параметр <token>id</token> установлен в 
                    <token>3</token>, независимо от значения в URL.
                </para>
                
                <para>
                    Проницательные читатели отметят, что в данном случае захват
                    переменной <varname>id</varname> с помощью регулярного
                    выражения &mdash; это просто трата времени, так как
                    полученное значение будет всегда перекрываться значением
                    параметра <varname>id</varname> из словаря. Это правильное
                    поведение, мы напоминаем об этом лишь для того, чтобы вы не
                    сделали ошибку.
                </para>
                
            </section>
            
        </section>
        
        <section id="&BASEID;.urlconf-tricks.defargs">
            
            <title id="&BASEID;.urlconf-tricks.defargs.title">
                Использование стандартных аргументов для представления
            </title>
            
            <para>
                Другим удобным способом является указание стандартных значений
                для аргументов представления. Эти значения используются в
                случае, когда соответствующие параметры не определены при
                вызове функций.
            </para>
            
            <para>
                Пример:
                <screen>
                    <![CDATA[
# urls.py

from django.conf.urls.defaults import *

urlpatterns = patterns('',
    (r'^blog/$', views.page),
    (r'^blog/page(?P<num>\d+)/$', views.page),
)

# views.py

def page(request, num="1"):
    # Output the appropriate page of blog entries, according to num.
    # ...
	  ]]>
                </screen>
            </para>
            
            <para>
                В данном примере оба шаблона URL указывают на одно и то же
                представление, <token>views.page</token> , но первый шаблон не
                получает параметров из URL. Если срабатывает первый шаблон, то
                будет выполнена функция <function>page()</function> будет
                использовать стандартные значения аргументов(<token>num=1</token>
                ). Если срабатывает второй шаблон, функция <function>page()</function>
                будет использовать значение для параметра <varname>num</varname>
                полученное с помощью регулярного выражения.
            </para>
            
            <para>
                Заметьте, что в качестве значения по-умолчанию мы указали 
                <emphasis>строку</emphasis> <token>"1"</token>, а не число 
                <token>1</token>. Это для согласованности т.к. любое полученное для
                <varname>num</varname> значение будет строкой.
            </para>
            
            <para>
                Как объяснялось ранее, обычно используют данную методику
                совместно с параметрами конфигурации. Этот пример немного
                улучшает пример из раздела
                <quote>
                    <xref
                     linkend="&BASEID;.urlconf-tricks.extra-option.view-options"
                     endterm="&BASEID;.urlconf-tricks.extra-option.view-options.title"/>
                </quote>,
                предоставляя стандартное значение для <varname>template_name</varname>:
                <screen>
                    def my_view(request, template_name='mysite/my_view.html'):
                        var = do_something()
                        return render_to_response(template_name, {'var': var})
                </screen>
            </para>
            
        </section>
        
        <section id="&BASEID;.urlconf-tricks.speccasingviews">
            
            <title id="&BASEID;.urlconf-tricks.speccasingviews.title">
                Представления для особых случаев
            </title>
            
            <para>
                Иногда так случается, что есть шаблон в вашей схеме URL,
                который обрабатывает большой набор URL, но вам необходимо
                реализовать для них особые случаи. Для этого надо просто
                описать эти случаи первыми.
            </para>
            
            <para>
                Например, страницы <quote>добавить объект</quote> на сайте
                администратора Django представлены в схеме URL такой строкой:
                <screen>
                    urlpatterns = patterns('',
                    # ...
                    ('^([^/]+)/([^/]+)/add/$', 'django.contrib.admin.views.main.add_stage'),
                    # ...
                    )
                </screen>
            </para>
            
            <para>
                Эта строка совпадает с URL такими как <token>/myblog/entries/add/</token>
                и <token>/auth/groups/add/</token>. Однако страница добавления
                пользователей (<token>/auth/user/add/</token>) является особым
                случаем &mdash; оно не отображает все поля формы, она
                отображает два поля для ввода пароля и так далее. Мы
                <emphasis>можем</emphasis> решить эту проблему реализовав
                особое поведение представления, например так:
                <screen>
                    def add_stage(request, app_label, model_name):
                        if app_label == 'auth' and model_name == 'user':
                            # do special-case code
                        else:
                            # do normal code
                </screen>
            </para>
            
            <para>
                Но такой подход не элегантен по причинам, которые мы обсуждали
                чуть ранее: этот подход помещает логику обработки URL в
                представление. В качестве элегантного решения мы можем
                воспользоваться тем фактом, что шаблоны URL обрабатываются в
                порядке их определения в файле:
                <screen>
                    urlpatterns = patterns('',
                        # ...
                        ('^auth/user/add/$', 'django.contrib.admin.views.auth.user_add_stage'),
                        ('^([^/]+)/([^/]+)/add/$', 'django.contrib.admin.views.main.add_stage'),
                        # ...
                    )
                </screen>
            </para>
            
            <para>
                Теперь вызов <token>/auth/user/add/</token> будет обработан
                представлением <token>user_add_stage</token>. Несмотря на то,
                что этот URL совпадает со вторым шаблоном, он будет обработан
                первым.
            </para>
            
        </section>
        
        <section id="&BASEID;.urlconf-tricks.captchatext">

            <title id="&BASEID;.urlconf-tricks.captchatext.title">
                Обработка совпадающего текста
            </title>
            
            <para>
                Каждый аргумент, полученный из URL с помощью регулярного
                выражения передаётся представлению в виде обычной
                строки. Например:
                <screen>
                    <![CDATA[
(r'^articles/(?P<year>\d{4})/$', views.year_archive),
	  ]]>
                </screen>
            </para>
            
            <para>
                Аргумент <varname>year</varname> в этой строке будет передан в
                представление <token>views.year_archive()</token> в виде
                строки, не в виде целого числа, несмотря на то, что выражение
                <token>\d{4}</token> совпадает только со строкой чисел.
            </para>
            
            <para>
                Эту особенность следует помнить при разработке
                приложения. Множество встроенных функций Python принимают
                объекты строго определённого типа. Общей ошибкой является
                попытка создать объект <classname>datetime.date</classname>,
                используя строковое представление даты, а не целочисленное:
                <screen>
                    >>> import datetime
                    >>> datetime.date('1993', '7', '9')
                    Traceback (most recent call last):
                        ...
                    TypeError: an integer is required
                    >>> datetime.date(1993, 7, 9)
                    datetime.date(1993, 7, 9)
                </screen>
            </para>
            
            <para>
                С точки зрения схемы URL это ошибка выглядит так:
                <screen>
                    # urls.py
                    
                    from django.conf.urls.defaults import *
                    
                    urlpatterns = patterns('',
                        (r'^articles/(\d{4})/(\d{2})/(\d{2})/$', views.day_archive),
                    )
                    
                    # views.py
                    
                    import datetime
                    
                    def day_archive(request, year, month, day)
                        # The following statement raises a TypeError!
                        date = datetime.date(year, month, day)
                </screen>
            </para>
            
            <para>
                А правильно можно написать так:
                <screen>
                    def day_archive(request, year, month, day):
                        date = datetime.date(int(year), int(month), int(day))
                </screen>
            </para>
            
            <para>
                Следует отметить, что сам метод <function>int()</function>
                вызывает исключение <token>ValueError</token> при передаче ему
                строки, в которой есть не только цифры. Но мы избегаем эту
                ошибку в нашем случае, так как регулярное выражения в шаблоне URL
                обеспечивает передачу только цифр.
            </para>
            
        </section>
        
        <section id="&BASEID;.urlconf-tricks.what-to-search">
            
            <title id="&BASEID;.urlconf-tricks.what-to-search.title">
                Определение того, с чем совпадёт шаблон URL
            </title>
            
            <para>
                При получении запроса Django пытается найти соответствующий
                шаблон в схеме URL как для обычной строки Python (не как для
                Unicode строки). При этом параметры <token>GET</token> и
                <token>POST</token> или доменное имя не принимаются во
                внимание. Также не рассматривается начальный слэш, потому что
                каждое URL имеет начальный слэш.
            </para>
            
            <para>
                Например, в запросе <token>http://www.example.com/myapp/</token>
                Django будет искать шаблон URL для <token>myapp/</token>. В запросе
                <token>http://www.example.com/myapp/?page=3</token> Django
                будет искать шаблон для <token>myapp/</token>.
            </para>
            
            <para>
                Метод запроса (т.е. <token>GET</token>, <token>POST</token>,
                <token>HEAD</token>) <emphasis>не</emphasis> принимается во
                внимание при обработке схемы URL. Другими словами, все методы
                будут обрабатываться теми же функциями. Ветвление обработки
                запроса в зависимости от использованного метода лежит
                полностью на функциях представления.
            </para>
            
        </section>
        
        <section id="&BASEID;.urlconf-tricks.higher-level-abstractions">

            <title id="&BASEID;.urlconf-tricks.higher-level-abstractions">
                Высокий уровень абстракции в функциях представления
            </title>
            
            <para>
                Говоря о разветвлении логики в функциях представления основанных 
                на методе запроса, давайте посмотрим каким красивым способом мы 
                можем это сделать:
                <screen>
                    # urls.py

                    from django.conf.urls.defaults import *
                    from mysite import views

                    urlpatterns = patterns('',
                        # ...
                        (r'^somepage/$', views.some_page),
                        # ...
                    )

                    # views.py

                    from django.http import Http404, HttpResponseRedirect
                    from django.shortcuts import render_to_response

                    def some_page(request):
                        if request.method == 'POST':
                            do_something_for_post()
                            return HttpResponseRedirect('/someurl/')
                        elif request.method == 'GET':
                            do_something_for_get()
                            return render_to_response('page.html')
                        else:
                            raise Http404()
                </screen>
            </para>
            
            <para>
                В этом примере, обработка методов <token>POST</token> и <token>GET</token>
                функцией <function>some_page()</function> совсем отличается. 
                Все что у них общего это URL <token>/somepage/</token>. Поэтому 
                не очень красиво обрабатывать их одной функцией. Было бы на много
                лучше, если бы одна функция обрабатывала запрос <token>GET</token>,
                а другая - <token>POST</token> - и вызывалась только одна, которая
                необходима для данного типа запросов.
            </para>
            
            <para>
                Мы можем реализовать это создав функцию, которая будет вызывать 
                другие функции, руководствуясь определённой логикой. Этот пример
                покажет как этот подход поможет упростить нашу функцию 
                <function>some_page()</function>.
                <screen>
                    # views.py

                    from django.http import Http404, HttpResponseRedirect
                    from django.shortcuts import render_to_response

                    def method_splitter(request, GET=None, POST=None):
                        if request.method == 'GET' and GET is not None:
                            return GET(request)
                        elif request.method == 'POST' and POST is not None:
                            return POST(request)
                        raise Http404

                    def some_page_get(request):
                        assert request.method == 'GET'
                        do_something_for_get()
                        return render_to_response('page.html')

                    def some_page_post(request):
                        assert request.method == 'POST'
                        do_something_for_post()
                        return HttpResponseRedirect('/someurl/')

                    # urls.py

                    from django.conf.urls.defaults import *
                    from mysite import views

                    urlpatterns = patterns('',
                        # ...
                        (r'^somepage/$', views.method_splitter, {'GET': views.some_page_get, 'POST': views.some_page_post}),
                        # ...
                    )                
                </screen>
            </para>
            
            <para>
                Давайте рассмотрим что она делает:
                <itemizedlist>
                
                    <listitem>
                        <para>
                            Мы создали новую функцию представления 
                            <function>method_splitter()</function>, которая
                            вызывает другие функции в соответствии с 
                            <token>request.method</token>. Она принимает два
                            именованных аргумента <varname>GET</varname> и 
                            <varname>POST</varname>, которые должны быть
                            <emphasis>функциями представления</emphasis>.
                            Если <token>request.method</token> равен 
                            <token>'GET'</token> - вызывается функция 
                            <function>GET</function>, если <token>'POST'</token> -
                            <function>POST</function>. Если <token>request.method</token>
                            равен чему-то другому(<token>HEAD</token>, например),
                            или <varname>GET</varname> или <varname>POST</varname>
                            не указаны, тогда вызывается исключения <token>Http404</token>.
                        </para>
                    </listitem>
                    
                    <listitem>
                        <para>
                            В схеме URL <token>/somepage/</token> указывает на
                            <function>method_splitter()</function> и передает
                            ей дополнительные параметры - функции представления
                            для <varname>GET</varname> и <token>POST</token>.
                        </para>
                    </listitem>
                    
                    <listitem>
                        <para>
                            Разделяем функцию представления <function>some_page()</function>
                            на две функции - <function>some_page_get()</function> 
                            и <function>some_page_post()</function>. Это на много
                            лучше, чем использовать всю эту логику в одной
                            функции.
                        </para>
                        
                        <para>
                            Заметьте что теперь эти функции не должны проверять
                            <token>request.method</token>, потому что 
                            <function>method_splitter()</function> делает это.
                            (В тот момент, когда <function>some_page_post()</function>
                            будет вызвана, мы можем быть уверенны, что 
                            <token>request.method</token> равен <token>'POST'</token>.)
                            Все же, что бы быть уверенными, ну и для документирования,
                            мы добавили <token>assert</token>, который проверяет
                            что в <token>request.method</token> то, что мы ожидаем.
                        </para>
                    </listitem>  
                                                          
                </itemizedlist>
            </para>
            
            <para>
                111222
                Now we have ourselves a nice, generic view function that encapsulates 
                the logic of delegating a view by <token>request.method</token>. 
                Nothing about <function>method_splitter()</function> is tied to 
                our specific application, of course, so we can reuse it in other projects.
            </para>
            
            <para>
                But, while we’re at it, there’s one way to improve on <function>method_splitter()</function>. 
                As it’s written, it assumes that the <token>GET</token> and <token>POST</token> 
                views take no arguments other than <token>request</token>. 
                What if we wanted to use <function>method_splitter()</function> 
                with views that, for example, capture text from URLs, or take 
                optional keyword arguments themselves?            
            </para>
            
            <para>
                To do that, we can use a nice Python feature: variable arguments 
                with asterisks. We’ll show the example first, then explain it:
                <screen>
                    def method_splitter(request, *args, **kwargs):
                        get_view = kwargs.pop('GET', None)
                        post_view = kwargs.pop('POST', None)
                        if request.method == 'GET' and get_view is not None:
                            return get_view(request, *args, **kwargs)
                        elif request.method == 'POST' and post_view is not None:
                            return post_view(request, *args, **kwargs)
                        raise Http404
                </screen>
            </para>
            
            <para>
                Here, we’ve refactored <function>method_splitter()</function> 
                to remove the <token>GET</token> and <token>POST</token> keyword arguments, 
                in favor of <token>*args</token> and <token>**kwargs</token> (note the asterisks). 
                This is a Python feature that allows a function to accept a dynamic, 
                arbitrary number of arguments whose names aren’t known until runtime. 
                If you put a single asterisk in front of a parameter in a function definition, 
                any <emphasis>positional</emphasis> arguments to that function 
                will be rolled up into a single tuple. If you put two asterisks 
                in front of a parameter in a function definition, any <emphasis>keyword</emphasis>
                arguments to that function will be rolled up into a single dictionary.            
            </para>
            
            <para>
            For example, with this function:            
                <screen>
                    def foo(*args, **kwargs):
                        print "Positional arguments are:"
                        print args
                        print "Keyword arguments are:"
                        print kwargs
                </screen>
            </para>
            
            <para>
                Here’s how it would work: 
                <screen>
                    >>> foo(1, 2, 3)
                    Positional arguments are:
                    (1, 2, 3)
                    Keyword arguments are:
                    {}
                    >>> foo(1, 2, name='Adrian', framework='Django')
                    Positional arguments are:
                    (1, 2)
                    Keyword arguments are:
                    {'framework': 'Django', 'name': 'Adrian'}
                </screen>           
            </para>
            
            <para>
                Bringing this back to <function>method_splitter()</function>, 
                you can see we’re using <token>*args</token> and <token>**kwargs</token> 
                to accept <emphasis>any</emphasis> arguments to the function and 
                pass them along to the appropriate view. But before we do that, 
                we make two calls to <token>kwargs.pop()</token> to get the 
                <token>GET</token> and <token>POST</token> arguments, if they’re available. 
                (We’re using <function>pop()</function> with a default value of 
                <token>None</token> to avoid <token>KeyError</token> if one or 
                the other isn’t defined.)            
            </para>
        </section>
        
        <section id="&BASEID;.urlconf-tricks.wrapping-view-functions">

            <title id="&BASEID;.urlconf-tricks.wrapping-view-functions">
                Wrapping View Functions
            </title>
            
            <para>
                Our final view trick takes advantage of an advanced Python technique. 
                Say you find yourself repeating a bunch of code throughout various views, 
                as in this example:            
                <screen>
                    def my_view1(request):
                        if not request.user.is_authenticated():
                            return HttpResponseRedirect('/accounts/login/')
                        # ...
                        return render_to_response('template1.html')

                    def my_view2(request):
                        if not request.user.is_authenticated():
                            return HttpResponseRedirect('/accounts/login/')
                        # ...
                        return render_to_response('template2.html')

                    def my_view3(request):
                        if not request.user.is_authenticated():
                            return HttpResponseRedirect('/accounts/login/')
                        # ...
                        return render_to_response('template3.html')
                </screen>
            </para>
            
            <para>
                Here, each view starts by checking that <token>request.user</token> 
                is authenticated — that is, the current user has successfully logged 
                into the site — and redirects to <token>/accounts/login/</token> if not. 
                (Note that we haven’t yet covered <token>request.user</token> — 
                <quote><xref linkend="djangobook.chap14" endterm="djangobook.chap14.title"/></quote> 
                does — but, as you might imagine, <token>request.user</token> 
                represents the current user, either logged-in or anonymous.)            
            </para>
            
            <para>
                It would be nice if we could remove that bit of repetitive code 
                from each of these views and just mark them as requiring authentication. 
                We can do that by making a view wrapper. Take a moment to study this:
                <screen>
                    def requires_login(view):
                        def new_view(request, *args, **kwargs):
                            if not request.user.is_authenticated():
                                return HttpResponseRedirect('/accounts/login/')
                            return view(request, *args, **kwargs)
                        return new_view
                </screen>
            </para>
            
            <para>
                This function, <function>requires_login</function>, takes a view 
                function (<token>view</token>) and returns a new view function 
                (<token>new_view</token>). The new function, new_view is defined 
                <emphasis>within</emphasis> <function>requires_login</function> 
                and handles the logic of checking <token>request.user.is_authenticated()</token>
                and delegating to the original view (<token>view</token>).            
            </para>
            
            <para>
                Now, we can remove the <token>if not request.user.is_authenticated()</token> 
                checks from our views and simply wrap them with <function>requires_login</function> 
                in our URLconf:
                <screen>
                    from django.conf.urls.defaults import *
                    from mysite.views import requires_login, my_view1, my_view2, my_view3

                    urlpatterns = patterns('',
                        (r'^view1/$', requires_login(my_view1)),
                        (r'^view2/$', requires_login(my_view2)),
                        (r'^view3/$', requires_login(my_view3)),
                    )
                </screen>            
            </para>
            
            <para>
                This has the same effect as before, but with less code redundancy. 
                Now we’ve created a nice, generic function — <function>requires_login</function> 
                that we can wrap around any view in order to make it require login.            
            </para>
        </section>
        
    </section>
    
    <section id="&BASEID;.urlconf-include">
        
        <title id="&BASEID;.urlconf-include.title">
            Подключение других схем URL
        </title>
        
        <para>
            Если вы планируете использовать ваш код в нескольких Django
            сайтах, вам следует переработать ваш файл со схемой URL таким
            образом, чтобы он позволял включать другие схемы.
        </para>
        
        <para>
            В любом случае ваша схема может <quote>подключать</quote> другие
            схемы. По существу происходит <quote>внедрение</quote> набора URL
            после этой команды. Например:
            <screen>
                from django.conf.urls.defaults import *
                
                urlpatterns = patterns('',
                    (r'^weblog/', include('mysite.blog.urls')),
                    (r'^photos/', include('mysite.photos.urls')),
                    (r'^about/$', 'mysite.views.about'),
                )
            </screen>
        </para>
        
        <para>
            Здесь есть важный момент: регулярные выражения в этом примере,
            которые указывают на <function>include()</function> <emphasis>не имеют</emphasis>
            символа <token>$</token>, но <emphasis>имеют</emphasis>
            завершающий слэш. Когда Django встречает <function>include()</function>
            он отрезает совпавшую
            часть от URL и отправляет оставшуюся часть в подключенные
            схемы для дальнейшей обработки.
        </para>
        
        <para>
            Продолжая работу над нашим примером 
            <footnote>
                <para>
                    См. предыдущий пример. Данный код
                    подключается командой 
                    <token>include('mysite.blog.urls')</token>.
                </para>
            </footnote>
            :
            <screen>
                from django.conf.urls.defaults import *
                
                urlpatterns = patterns('',
                    (r'^(\d\d\d\d)/$', 'mysite.blog.views.year_detail'),
                    (r'^(\d\d\d\d)/(\d\d)/$', 'mysite.blog.views.month_detail'),
                )
            </screen>
        </para>
        
        <para>
            Используя эти две схемы URL, покажем как будут обработаны
            тестовые запросы:
            <itemizedlist>
                <listitem>
                    <para>
                        <token>/weblog/2007/</token>: В первом наборе привязок
                        совпадёт шаблон <token>r'^weblog/'</token>. Так как для
                        этого шаблона используется <function>include()</function>,
                        Django отрежет совпавший текст, в данном случае это будет
                        <token>weblog/</token>. Оставшаяся часть URL(т.е.
                        <token>2007/</token>) совпадёт с первым шаблоном в
                        <token>mysite.blog.urls</token>.
                    </para>
                </listitem>
                
                <listitem>
                    <para>
                        <token>/weblog//2007/</token>: В первом наборе привязок
                        совпадёт шаблон <token>r'^weblog/'</token>.Так как для
                        этого шаблона используется <function>include()</function>,
                        Django отрежет совпавший текст, в данном случае это будет
                        <token>weblog/</token>. Оставшаяся часть URL 
                        (т.е.<token>/2007/</token>, с ведущим слэшом) не совпадёт
                        ни с одним шаблоном в <token>mysite.blog.urls</token>.
                    </para>
                </listitem>
                
                <listitem>
                    <para>
                        <token>/about/</token>: Этот запрос будет обработан
                        представлением <token>mysite.views.about</token> в первом
                        наборе привязок, показывая, что вы можете смешивать
                        подключаемые шаблоны со встроенными.
                    </para>
                </listitem>
            </itemizedlist>
        </para>
        
        <section id="&BASEID;.urlconf-include.how-work-captured">
            
            <title id="&BASEID;.urlconf-include.how-work-captured.title">
                Как совпавшие параметры работают совместно с include()
            </title>
            
            <para>
                Подключенный набор привязок получает любые параметры от
                родительского набора, например:
                <screen>
                    <![CDATA[
# root urls.py

from django.conf.urls.defaults import *

urlpatterns = patterns('',
    (r'^(?P<username>\w+)/blog/', include('foo.urls.blog')),
)

# foo/urls/blog.py

from django.conf.urls.defaults import *

urlpatterns = patterns('',
    (r'^$', 'foo.views.blog_index'),
    (r'^archive/$', 'foo.views.blog_archive'),
)
	  ]]>
                </screen>
            </para>
            
            <para>
                В этом примере, захваченная переменная <varname>username</varname>
                передаётся в подключенный набор привязок и, следовательно, в
                <emphasis>каждую</emphasis> функцию представления внутри этого набора.
            </para>
            
            <para>
                Следует отметить, что захваченные параметры будут
                <emphasis>всегда</emphasis> передаваться
                <emphasis>каждой</emphasis> строке подключенного набора
                привязок, независимо от того, принимает ли представление в
                этой строке такие параметры. По этой причине, эта методика
                полезна только в случае, когда вы уверены, что каждое
                представление в подключенном наборе привязок может принять
                передаваемые параметры.
            </para>
            
        </section>
        
        <section id="&BASEID;.urlconf-include.how-work-extra">
            
            <title id="&BASEID;.urlconf-include.how-work-extra.title">
                Как работают дополнительные параметры совместно с include()
            </title>
            
            <para>
                Аналогично, вы можете передавать дополнительные параметры в
                наборе привязок в подключаемые наборы, подобно тому, как такие
                параметры передаются в обычное представление &mdash; в виде
                словаря. Как только вы сделаете это, <emphasis>каждая</emphasis>
                строка подключенного набора получит эти параметры.
            </para>
            
            <para>
                Например, следующие два набора привязок функционально
                идентичны.
            </para>
            
            <para>
                Первый:
                <screen>
                    # urls.py
                    
                    from django.conf.urls.defaults import *
                    
                    urlpatterns = patterns('',
                    (r'^blog/', include('inner'), {'blogid': 3}),
                    )
                    
                    # inner.py
                    
                    from django.conf.urls.defaults import *
                    
                    urlpatterns = patterns('',
                    (r'^archive/$', 'mysite.views.archive'),
                    (r'^about/$', 'mysite.views.about'),
                    (r'^rss/$', 'mysite.views.rss'),
                    )
                </screen>
            </para>
            
            <para>
                Второй:
                <screen>
                    # urls.py
                    
                    from django.conf.urls.defaults import *
                    
                    urlpatterns = patterns('',
                    (r'^blog/', include('inner')),
                    )
                    
                    # inner.py
                    
                    from django.conf.urls.defaults import *
                    
                    urlpatterns = patterns('',
                    (r'^archive/$', 'mysite.views.archive', {'blogid': 3}),
                    (r'^about/$', 'mysite.views.about', {'blogid': 3}),
                    (r'^rss/$', 'mysite.views.rss', {'blogid': 3}),
                    )
                </screen>
            </para>
            
            <para>
                Подобно случаю с захваченными параметрами (которые мы
                рассматривали ранее), дополнительные параметры будут
                <emphasis>всегда</emphasis> передаваться <emphasis>каждой</emphasis>
                строке подключенного набора
                привязок, независимо от того, может ли функция представления
                правильно обработать такие параметры. По этой причине, эта
                методика полезна только в случае, когда вы уверены, что каждое
                представление в подключенном наборе привязок может принять
                передаваемые параметры.
            </para>
            
        </section>
        
    </section>
    
</chapter>
