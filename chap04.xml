<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
"http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd"
[
<!ENTITY BASEID "djangobook.chap04">
]>

<chapter lang="ru" id="&BASEID;">

  <title id="&BASEID;.title">
    Шаблоны
  </title>

  <para>
    Перевод &copy; Попов Руслан &lt;radz &bull; yandex &bull; ru&gt;
  </para>

  <para>
    В предыдущей главе вы могли заметить что-то особенное в том, как
    мы возвращали текст в наших представлениях. А именно, HTML был
    напрямую вбит в код на Python, примерно так:
    <screen>
      <![CDATA[
def current_datetime(request):
    now = datetime.datetime.now()
    html = "<html><body>It is now %s.</body></html>" % now
    return HttpResponse(html)
      ]]>
    </screen>
  </para>

  <para>
    Несмотря на то, что данный подход был удобен для объяснения
    принципов работы представления, он не может быть признан годным
    для использования в реальных проектах. И вот почему:

    <itemizedlist>
      <listitem>
	<para>
	  Любое изменение в дизайне страницы требует изменения в
	  коде. Дизайн сайта изменяется гораздо чаще, чем сам код
	  сайта. Удобнее будет иметь возможность вносить изменения в
	  дизайн, не затрагивая код.
	</para>
      </listitem>

      <listitem>
	<para>
	  Разработка кода на языке Python и работа с HTML являются
	  двумя различными дисциплинам и наиболее профессиональные
	  среды web-разработки разделяют такую ответственность между
	  отдельными людьми (или даже отдельными подразделениями). От
	  дизайнеров и HTML/CSS кодеров не следует требовать
	  редактирования Python кода для выполнения их работы.
	</para>
      </listitem>

      <listitem>
	<para>
	  Возможность одновременной работы программистов на Python
	  кодом и дизайнеров над шаблонами является наиболее
	  эффективным подходом, в отличие от необходимости одним
	  ожидать окончания работ других, чтобы приступить к
	  выполнению своих задач.
	</para>
      </listitem>
    </itemizedlist>
  </para>

  <para>
    По этим причинам гораздо проще и более удобно разделять дизай
    страницы от кода, обеспечивающего её работу. Мы можем сделать это
    с помощью <emphasis>шаблонной системы</emphasis> Django, которую
    мы обсудим в этой главе.
  </para>

  <section id="&BASEID;.basics">

    <title id="&BASEID;.basics.title">
      Основы шаблонной системы
    </title>
    
    <para>
      Шаблон Dkango &mdash; это строка текста, которая предназначена
      для разделения представления документа от его данных. Шаблон
      определяет места подстановки и различные виды основной логики
      (шаблонные теги), которая управляет отображением
      документа. Обычно, шаблоны используются для создания HTML, но
      шаблоны Django также способны участвовать в генерации любого
      текстового формата.
    </para>

    <para>
      Давайте начнём с простого примера. Данный шаблон описывает HTML
      страницу, которая благодарит посетителя за заказ, отправленный
      компании. Рассматривайте его как вид письма:
      <screen>
	<![CDATA[
<html>
<head><title>Ordering notice</title></head>

<body>

<h1>Ordering notice</h1>

<p>Dear {{ person_name }},</p>

<p>Thanks for placing an order from {{ company }}. It's scheduled to
ship on {{ ship_date|date:"F j, Y" }}.</p>

<p>Here are the items you've ordered:</p>

<ul>
{% for item in item_list %}
    <li>{{ item }}</li>
{% endfor %}
</ul>

{% if ordered_warranty %}
    <p>Your warranty information will be included in the packaging.</p>
{% else %}
    <p>You didn't order a warranty, so you're on your own when
    the products inevitably stop working.</p>
{% endif %}

<p>Sincerely,<br />{{ company }}</p>

</body>
</html>
	]]>
      </screen>
    </para>

    <para>
      Данный шаблон представляет собой обычный HTML с несколькими
      переменными и шаблонными тегами. Рассмотрим его подробнее:

      <itemizedlist>
	<listitem>
	  <para>
	    Любой текст взятый в скобки (т.е., <token>{{ person_name
	    }}</token>) является <emphasis>переменной</emphasis>. Это
	    означает <quote>вставить значение переменной с указанным
	    именем.</quote> (Как же мы определяем значения переменных?
	    Скоро мы это рассмотрим.)
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Любой текст взятый в фигурные скобки и проценты (т.е.,
	    <token>{% if ordered_warranty %}</token>) является
	    <emphasis>шаблонным тегом</emphasis>. Определение тега
	    достаточно простое: тег просто указывает шаблонной системе
	    <quote>сделать что-то.</quote>
	  </para>

	  <para>
	    Вышеприведёный шаблон содержит тег <token>for</token>
	    (<token>{% for item in item_list %}</token>) и тег
	    <token>if</token> (<token>{% if ordered_warranty
	    %}</token>).
	  </para>

	  <para>
	    Тег <token>for</token> работает почти так же как и
	    оператор <token>for</token> языка Python, позволяя вам
	    циклически обрабатывать каждый элемент
	    последовательности. Тег <token>if</token>, как вы можете
	    ожидать, работает аналогично логическому оператору
	    <token>if</token>. В данном примере, тег проверяет
	    является ли <token>True</token> значением
	    <varname>ordered_warranty</varname>. Если это так,
	    шаблонная система отобразит всё, что находится между
	    <token>{% if ordered_warranty %}</token> и <token>{% else
	    %}</token>. В противном случае, шаблонная система
	    отобразит всё между <token>{% else %}</token> и <token>{%
	    endif %}</token>. Следует отметить, что элемент <token>{%
	    else %}</token> является необязательным.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Наконец, второй параграф данного шаблона содержит пример
	    использования <emphasis>фильтра</emphasis>, который
	    предоставляет наиболее удобный способ изменения формата
	    переменной. В данном примере, <token>{{ ship_date|date:"F
	    j, Y" }}</token>, мы передаём значение переменной
	    <varname>ship_date</varname> фильтру <token>date</token>,
	    указывая для него аргументы <token>"F j,
	    Y"</token>. Фильтр <token>date</token> форматирует дату в
	    соответствии с указанным форматом. Фильтры подключаются к
	    переменным с помощью символа <token>|</token>, аналогично
	    Unix потокам.
	  </para>
	</listitem>
      </itemizedlist>
    </para>

    <para>
      Каждый шаблон Django имеет доступ к некоторому количеству
      встроенных тегов и фильтров, многие из которых будут рассмотрены
      в последующих разделах главы. Приложение F FIXME содержит полный
      список тегов и фильтров, будет неплохо, если вы ознакомитесь с
      этим списком. Также есть возможность создавать свои собственный
      фильтры и теги, мы рассмотрим это в главе 9 FIXME.
    </para>

  </section>

  <section id="&BASEID;.usage">

    <title id="&BASEID;.usage.title">
      Использование шаблонной системы
    </title>
    
    <para>
      Давайте рассмотрим шаблонную систему Django подробнее, вы
      сможете увидеть как она работает, но <emphasis>пока</emphasis>
      мы не будем интегрировать её с представлениями, которые мы
      создали в прошлой главе. Наша цель в данный момент &mdash;
      показать вам как шаблонная система работает независимо от
      остальной части Django. (Предположим другой способ: обычно вы
      будете использовать шаблонную систему совместно с
      представлениями, но мы желаем показать то, что шаблонная система
      является обычной библиотекой Python, которую вы можете
      использовать <emphasis>где угодно</emphasis>, не только с
      представлениями Django.)
    </para>

    <para>
      Ниже указан самый основной способ использования шаблонной
      системы Django в коде Python:

      <orderedlist>
	<listitem>
	  <para>
	    Создать объект <classname>Template</classname>, передав
	    ему шаблон в виде строки.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Вызвать метод <function>render()</function> объекта
	    <classname>Template</classname> с набором переменных
	    (<emphasis>контекст</emphasis>). Метод возвратит полностью
	    обработанный шаблон в виде строки, все переменные и
	    шаблонные теги будут вычислены в соответствии с
	    контекстом.
	  </para>
	</listitem>
      </orderedlist>
    </para>

    <para>
      Пример использования:
      <screen>
	<![CDATA[
>>> from django import template
>>> t = template.Template('My name is {{ name }}.')
>>> c = template.Context({'name': 'Adrian'})
>>> print t.render(c)
My name is Adrian.
>>> c = template.Context({'name': 'Fred'})
>>> print t.render(c)
My name is Fred.
	]]>
      </screen>
    </para>

    <para>
      Следующие разделы описывают каждый шаг более детально.
    </para>

    <section id="&BASEID;.usage.create">
      
      <title id="&BASEID;.usage.create.title">
	Создание шаблонных объектов
      </title>

      <para>
	Простейшим способом создания объекта
	<classname>Template</classname> является его прямое
	порождение. Класс <classname>Template</classname> расположен в
	модуле <token>django.template</token>, конструктор принимает
	единственный аргумент &mdash; строку с кодом шаблона. Давайте
	рассмотрим как это всё работает с помощью интерактивного
	интерпретатора языка Python.
      </para>

      <para>
	В каталоге проекта <token>mysite</token>, созданном с помощью
	команды <command>django-admin.py startproject</command> (это
	было описано в главе <quote><xref linkend="djangobook.chap02"
	endterm="djangobook.chap02.title"/></quote>), выполните
	команды <command>python manage.py shell</command> для запуска
	интерактивного интерпретатора.
      </para>

      <para>
	<note>
	  <title>
	    A special Python prompt FIXME
	  </title>

	  <para>
	    Если вы использовали Python ранее, вас может
	    заинтересовать, почему мы используем <command>python
	    manage.py shell</command>, а не просто
	    <command>python</command>. Обе команды запускают
	    интерпретатор, но наш вариант имеет одну ключевую
	    особенность: перед запуском интерпретатора, он указывает
	    Django какой файл конфигурации следует
	    использовать. Многие компоненты Django, включая шаблонную
	    систему, зависят от ваших настроек и вы не сможете их
	    использовать до тех пор, пока среда разработки не будет
	    знать где их брать.
	  </para>

	  <para>
	    Если вам это интересно, расскажем как всё это работает
	    внутри. Django ищет переменную среды с именем
	    <varname>DJANGO_SETTINGS_MODULE</varname>, которая должна
	    содержать путь до вашего файла
	    <filename>settings.py</filename>. Например,
	    <varname>DJANGO_SETTINGS_MODULE</varname> может быть
	    установлено в <token>mysite.settings</token>,
	    подразумевая, что каталог <filename>mysite</filename>
	    находится в пути Python.
	  </para>

	  <para>
	    При запуске <command>python manage.py shell</command>
	    настройка <varname>DJANGO_SETTINGS_MODULE</varname>
	    производится автоматически. Мы рекомендуем использовать
	    данный метод для работы с приведёнными ниже примерами.
	  </para>

	  <para>
	    После того, как вы лучше изучите Django, вероятно вы
	    перестанете использовать данный способ и будете
	    устанавливать <varname>DJANGO_SETTINGS_MODULE</varname>
	    вручную в вашем <filename>.bash_profile</filename> или в
	    другом конфигурационном файле вашей среды.
	  </para>
	</note>
      </para>

      <para>
	Рассмотрим основы шаблонной системы:
	<screen>
	  <![CDATA[
>>> from django.template import Template
>>> t = Template('My name is {{ name }}.')
>>> print t
	  ]]>
	</screen>
      </para>

      <para>
	Если вы попробовали запустить данный код в интерпретаторе, то
	вы увидели нечто подобное:
	<screen>
	  <![CDATA[
<django.template.Template object at 0xb7d5f24c>
	  ]]>
	</screen>
      </para>

      <para>
	Шестнадцатеричный адрес объекта &mdash;
	<token>0xb7d5f24c</token> будет всякий раз разным, не
	обращайте на это внимание. Это внутренняя информация Python,
	так называемый <quote>идентификатор</quote> созданного объекта
	<classname>Template</classname>.
      </para>

      <para>
	При создании объекта <classname>Template</classname> шаблонная
	система компилирует строку с кодом шаблона во внутренний
	оптимизированный формат, готовый для обработки. Но если ваш
	шаблонный код содержит синтаксические ошибки, вызов
	<function>Template()</function> приведёт к исключению
	<classname>TemplateSyntaxError</classname>:
	<screen>
	  <![CDATA[
>>> from django.template import Template
>>> t = Template('{% notatag %}')
Traceback (most recent call last):
  File "<stdin>", line 1, in ?
  ...
django.template.TemplateSyntaxError: Invalid block tag: 'notatag'
	  ]]>
	</screen>
      </para>

    </section>

    <section id="&BASEID;.usage.render">
      
      <title id="&BASEID;.usage.render.title">
	Обработка шаблона
      </title>
    
    </section>

    <section id="&BASEID;.usage.many-contexts">
      
      <title id="&BASEID;.usage.many-contexts.title">
	Множество контекстов и единственный шаблон
      </title>
    
    </section>

    <section id="&BASEID;.usage.lookup">
      
      <title id="&BASEID;.usage.lookup.title">
	Поиск контекстной переменной
      </title>
    
      <section id="&BASEID;.usage.lookup.method-call">
      
	<title id="&BASEID;.usage.lookup.method-call.title">
	  Вызов методов
	</title>
	
      </section>

      <section id="&BASEID;.usage.lookup.invalid-vars">
      
	<title id="&BASEID;.usage.lookup.invalid-vars.title">
	  Обработка неправильных переменных
	</title>
	
      </section>

    </section>

    <section id="&BASEID;.usage.playing">
      
      <title id="&BASEID;.usage.playing.title">
	Играем с контекстными объектами
      </title>
    
    </section>

  </section>

</chapter>