<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
"http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd"
[
<!ENTITY BASEID "djangobook.chap04">
]>

<chapter lang="ru" id="&BASEID;">

  <title id="&BASEID;.title">
    Шаблоны
  </title>

  <para>
    Перевод &copy; Попов Руслан &lt;radz &bull; yandex &bull; ru&gt;
  </para>

  <para>
    В предыдущей главе вы могли заметить что-то особенное в том, как
    мы возвращали текст в наших представлениях. А именно, HTML был
    напрямую вбит в код на Python, примерно так:
    <screen>
      <![CDATA[
def current_datetime(request):
    now = datetime.datetime.now()
    html = "<html><body>It is now %s.</body></html>" % now
    return HttpResponse(html)
      ]]>
    </screen>
  </para>

  <para>
    Несмотря на то, что данный подход был удобен для объяснения
    принципов работы представления, он не может быть признан годным
    для использования в реальных проектах. И вот почему:

    <itemizedlist>
      <listitem>
	<para>
	  Любое изменение в дизайне страницы требует изменения в
	  коде. Дизайн сайта изменяется гораздо чаще, чем сам код
	  сайта. Удобнее будет иметь возможность вносить изменения в
	  дизайн, не затрагивая код.
	</para>
      </listitem>

      <listitem>
	<para>
	  Разработка кода на языке Python и работа с HTML являются
	  двумя различными дисциплинам и наиболее профессиональные
	  среды web-разработки разделяют такую ответственность между
	  отдельными людьми (или даже отдельными подразделениями). От
	  дизайнеров и HTML/CSS кодеров не следует требовать
	  редактирования Python кода для выполнения их работы.
	</para>
      </listitem>

      <listitem>
	<para>
	  Возможность одновременной работы программистов на Python
	  кодом и дизайнеров над шаблонами является наиболее
	  эффективным подходом, в отличие от необходимости одним
	  ожидать окончания работ других, чтобы приступить к
	  выполнению своих задач.
	</para>
      </listitem>
    </itemizedlist>
  </para>

  <para>
    По этим причинам гораздо проще и более удобно разделять дизай
    страницы от кода, обеспечивающего её работу. Мы можем сделать это
    с помощью <emphasis>шаблонной системы</emphasis> Django, которую
    мы обсудим в этой главе.
  </para>

  <section id="&BASEID;.basics">

    <title id="&BASEID;.basics.title">
      Основы шаблонной системы
    </title>
    
    <para>
      Шаблон Django &mdash; это строка текста, которая предназначена
      для разделения представления документа от его данных. Шаблон
      определяет места подстановки и различные виды основной логики
      (шаблонные теги), которая управляет отображением
      документа. Обычно, шаблоны используются для создания HTML, но
      шаблоны Django также способны участвовать в генерации любого
      текстового формата.
    </para>

    <para>
      Давайте начнём с простого примера. Данный шаблон описывает HTML
      страницу, которая благодарит посетителя за заказ, отправленный
      компании. Рассматривайте его как вид письма:
      <screen>
	<![CDATA[
<html>
<head><title>Ordering notice</title></head>

<body>

<h1>Ordering notice</h1>

<p>Dear {{ person_name }},</p>

<p>Thanks for placing an order from {{ company }}. It's scheduled to
ship on {{ ship_date|date:"F j, Y" }}.</p>

<p>Here are the items you've ordered:</p>

<ul>
{% for item in item_list %}
    <li>{{ item }}</li>
{% endfor %}
</ul>

{% if ordered_warranty %}
    <p>Your warranty information will be included in the packaging.</p>
{% else %}
    <p>You didn't order a warranty, so you're on your own when
    the products inevitably stop working.</p>
{% endif %}

<p>Sincerely,<br />{{ company }}</p>

</body>
</html>
	]]>
      </screen>
    </para>

    <para>
      Данный шаблон представляет собой обычный HTML с несколькими
      переменными и шаблонными тегами. Рассмотрим его подробнее:

      <itemizedlist>
	<listitem>
	  <para>
	    Любой текст взятый в скобки (т.е., <token>{{ person_name
	    }}</token>) является <emphasis>переменной</emphasis>. Это
	    означает <quote>вставить значение переменной с указанным
	    именем.</quote> (Как же мы определяем значения переменных?
	    Скоро мы это рассмотрим.)
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Любой текст взятый в фигурные скобки и проценты (т.е.,
	    <token>{% if ordered_warranty %}</token>) является
	    <emphasis>шаблонным тегом</emphasis>. Определение тега
	    достаточно простое: тег просто указывает шаблонной системе
	    <quote>сделать что-то.</quote>
	  </para>

	  <para>
	    Вышеприведёный шаблон содержит тег <token>for</token>
	    (<token>{% for item in item_list %}</token>) и тег
	    <token>if</token> (<token>{% if ordered_warranty
	    %}</token>).
	  </para>

	  <para>
	    Тег <token>for</token> работает почти так же как и
	    оператор <token>for</token> языка Python, позволяя вам
	    циклически обрабатывать каждый элемент
	    последовательности. Тег <token>if</token>, как вы можете
	    ожидать, работает аналогично логическому оператору
	    <token>if</token>. В данном примере, тег проверяет
	    является ли <token>True</token> значением
	    <varname>ordered_warranty</varname>. Если это так,
	    шаблонная система отобразит всё, что находится между
	    <token>{% if ordered_warranty %}</token> и <token>{% else
	    %}</token>. В противном случае, шаблонная система
	    отобразит всё между <token>{% else %}</token> и <token>{%
	    endif %}</token>. Следует отметить, что элемент <token>{%
	    else %}</token> является необязательным.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Наконец, второй параграф данного шаблона содержит пример
	    использования <emphasis>фильтра</emphasis>, который
	    предоставляет наиболее удобный способ изменения формата
	    переменной. В данном примере, <token>{{ ship_date|date:"F
	    j, Y" }}</token>, мы передаём значение переменной
	    <varname>ship_date</varname> фильтру <token>date</token>,
	    указывая для него аргументы <token>"F j,
	    Y"</token>. Фильтр <token>date</token> форматирует дату в
	    соответствии с указанным форматом. Фильтры подключаются к
	    переменным с помощью символа <token>|</token>, аналогично
	    Unix потокам.
	  </para>
	</listitem>
      </itemizedlist>
    </para>

    <para>
      Каждый шаблон Django имеет доступ к некоторому количеству
      встроенных тегов и фильтров, многие из которых будут рассмотрены
      в последующих разделах главы. Приложение F FIXME содержит полный
      список тегов и фильтров, будет неплохо, если вы ознакомитесь с
      этим списком. Также есть возможность создавать свои собственный
      фильтры и теги, мы рассмотрим это в главе 9 FIXME.
    </para>

  </section>

  <section id="&BASEID;.usage">

    <title id="&BASEID;.usage.title">
      Использование шаблонной системы
    </title>
    
    <para>
      Давайте рассмотрим шаблонную систему Django подробнее, вы
      сможете увидеть как она работает, но <emphasis>пока</emphasis>
      мы не будем интегрировать её с представлениями, которые мы
      создали в прошлой главе. Наша цель в данный момент &mdash;
      показать вам как шаблонная система работает независимо от
      остальной части Django. (Предположим другой способ: обычно вы
      будете использовать шаблонную систему совместно с
      представлениями, но мы желаем показать то, что шаблонная система
      является обычной библиотекой Python, которую вы можете
      использовать <emphasis>где угодно</emphasis>, не только с
      представлениями Django.)
    </para>

    <para>
      Ниже указан самый основной способ использования шаблонной
      системы Django в коде Python:

      <orderedlist>
	<listitem>
	  <para>
	    Создать объект <classname>Template</classname>, передав
	    ему шаблон в виде строки.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Вызвать метод <function>render()</function> объекта
	    <classname>Template</classname> с набором переменных
	    (<emphasis>контекст</emphasis>). Метод возвратит полностью
	    обработанный шаблон в виде строки, все переменные и
	    шаблонные теги будут вычислены в соответствии с
	    контекстом.
	  </para>
	</listitem>
      </orderedlist>
    </para>

    <para>
      Пример использования:
      <screen>
	<![CDATA[
>>> from django import template
>>> t = template.Template('My name is {{ name }}.')
>>> c = template.Context({'name': 'Adrian'})
>>> print t.render(c)
My name is Adrian.
>>> c = template.Context({'name': 'Fred'})
>>> print t.render(c)
My name is Fred.
	]]>
      </screen>
    </para>

    <para>
      Следующие разделы описывают каждый шаг более детально.
    </para>

    <section id="&BASEID;.usage.create">
      
      <title id="&BASEID;.usage.create.title">
	Создание шаблонных объектов
      </title>

      <para>
	Простейшим способом создания объекта
	<classname>Template</classname> является его прямое
	порождение. Класс <classname>Template</classname> расположен в
	модуле <token>django.template</token>, конструктор принимает
	единственный аргумент &mdash; строку с кодом шаблона. Давайте
	рассмотрим как это всё работает с помощью интерактивного
	интерпретатора языка Python.
      </para>

      <para>
	В каталоге проекта <token>mysite</token>, созданном с помощью
	команды <command>django-admin.py startproject</command> (это
	было описано в главе <quote><xref linkend="djangobook.chap02"
	endterm="djangobook.chap02.title"/></quote>), выполните
	команды <command>python manage.py shell</command> для запуска
	интерактивного интерпретатора.
      </para>

      <para>
	<note>
	  <title>
	    A special Python prompt FIXME
	  </title>

	  <para>
	    Если вы использовали Python ранее, вас может
	    заинтересовать, почему мы используем <command>python
	    manage.py shell</command>, а не просто
	    <command>python</command>. Обе команды запускают
	    интерпретатор, но наш вариант имеет одну ключевую
	    особенность: перед запуском интерпретатора, он указывает
	    Django какой файл конфигурации следует
	    использовать. Многие компоненты Django, включая шаблонную
	    систему, зависят от ваших настроек и вы не сможете их
	    использовать до тех пор, пока среда разработки не будет
	    знать где их брать.
	  </para>

	  <para>
	    Если вам это интересно, расскажем как всё это работает
	    внутри. Django ищет переменную среды с именем
	    <varname>DJANGO_SETTINGS_MODULE</varname>, которая должна
	    содержать путь до вашего файла
	    <filename>settings.py</filename>. Например,
	    <varname>DJANGO_SETTINGS_MODULE</varname> может быть
	    установлено в <token>mysite.settings</token>,
	    подразумевая, что каталог <filename>mysite</filename>
	    находится в пути Python.
	  </para>

	  <para>
	    При запуске <command>python manage.py shell</command>
	    настройка <varname>DJANGO_SETTINGS_MODULE</varname>
	    производится автоматически. Мы рекомендуем использовать
	    данный метод для работы с приведёнными ниже примерами.
	  </para>

	  <para>
	    После того, как вы лучше изучите Django, вероятно вы
	    перестанете использовать данный способ и будете
	    устанавливать <varname>DJANGO_SETTINGS_MODULE</varname>
	    вручную в вашем <filename>.bash_profile</filename> или в
	    другом конфигурационном файле вашей среды.
	  </para>
	</note>
      </para>

      <para>
	Рассмотрим основы шаблонной системы:
	<screen>
	  <![CDATA[
>>> from django.template import Template
>>> t = Template('My name is {{ name }}.')
>>> print t
	  ]]>
	</screen>
      </para>

      <para>
	Если вы попробовали запустить данный код в интерпретаторе, то
	вы увидели нечто подобное:
	<screen>
	  <![CDATA[
<django.template.Template object at 0xb7d5f24c>
	  ]]>
	</screen>
      </para>

      <para>
	Шестнадцатеричный адрес объекта &mdash;
	<token>0xb7d5f24c</token> будет всякий раз разным, не
	обращайте на это внимание. Это внутренняя информация Python,
	так называемый <quote>идентификатор</quote> созданного объекта
	<classname>Template</classname>.
      </para>

      <para>
	При создании объекта <classname>Template</classname> шаблонная
	система компилирует строку с кодом шаблона во внутренний
	оптимизированный формат, готовый для обработки. Но если ваш
	шаблонный код содержит синтаксические ошибки, вызов
	<function>Template()</function> приведёт к исключению
	<classname>TemplateSyntaxError</classname>:
	<screen>
	  <![CDATA[
>>> from django.template import Template
>>> t = Template('{% notatag %}')
Traceback (most recent call last):
  File "<stdin>", line 1, in ?
  ...
django.template.TemplateSyntaxError: Invalid block tag: 'notatag'
	  ]]>
	</screen>
      </para>

      <para>
	Термин <quote>block tag<footnote><para>Блочный
	тег</para></footnote></quote> в данном случае относится к
	<token>{% notatag %}</token>. <quote>Блочный тег</quote> и
	<quote>шаблонный тег</quote> являются синонимами.
      </para>

      <para>
	Система вызывает исключение
	<classname>TemplateSyntaxError</classname> в любом из
	нижеприведённых случаев:

	<itemizedlist>
	  <listitem>
	    <para>
	      Неверные теги;
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      Неверные аргументы у верных тегов;
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      Неверные фильтры;
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      Неверные аргументы у верных фильтров;
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      Неверный синтаксис шаблона;
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      Незакрытые теги (для тегов, которые требуют наличия
	      завершающих тегов).
	    </para>
	  </listitem>
	</itemizedlist>
      </para>

    </section>

    <section id="&BASEID;.usage.render">
      
      <title id="&BASEID;.usage.render.title">
	Обработка шаблона
      </title>

      <para>
	После того, как объект <classname>Template</classname> создан,
	вы можете передавать ему данные через
	<emphasis>контекст</emphasis>. Контекстом называют набор
	значений, ассоциированных с шаблоннымм переменными. Шаблон
	использует контекст для замены шаблонных переменных на
	значения и для вычисления тегов.
      </para>

      <para>
	Контекст в Django представлен классом
	<classname>Context</classname>, который определён в модуле
	<token>django.template</token>. Конструктор этого класса
	принимает один необязательный аргумент &mdash; словарь,
	содержащий имена переменных и ассоциированные им
	значения. Вызовите метод <function>render()</function> объекта
	<classname>Template</classname> для заполнения шаблона
	контекстными значениями:
	<screen>
	  <![CDATA[
>>> from django.template import Context, Template
>>> t = Template('My name is {{ name }}.')
>>> c = Context({'name': 'Stephane'})
>>> t.render(c)
u'My name is Stephane.'
	  ]]>
	</screen>
      </para>

      <para>
	Единственное, о чём следует упомянуть &mdash; то, что значение
	<token>t.render(c)</token> является объектом
	<classname>Unicode</classname>, а не обычной строкой
	Python. Вы можете выразить это, добавив <token>u</token> перед
	строкой. Django везде использует объекты
	<classname>Unicode</classname> вместо обычных строк. Если вы
	не понимаете последствия этого подхода, не
	беспокойтесь. Просто запомните, что поддержка Unicode
	позволяет упростить для вашего приложения поддержку
	национальных языков.
      </para>

      <para>
	<note>
	  <title>
	    Словари и контексты
	  </title>

	  <para>
	    Словарь в языке Python является отображением между
	    известным набором ключей и их
	    значений. <classname>Context</classname> подобен словарю,
	    но он также предоставляет дополнительный функционал,
	    который описан в главе 9 FIXME.
	  </para>
	</note>
      </para>

      <para>
	Имена переменных должны начинаться с буквы (<token>A-Z</token>
	или <token>a-z</token>) и могут состоять из множества букв,
	цифр, символов подчёркивания и точек. (Точки являются особым
	случаем, мы скоро рассмотрим их.) Имена переменных
	регистрозависимы.
      </para>

      <para>
	Ниже показан пример компиляции и обработки шаблона, который
	похож на тот, что мы рассмотрели в начале главы:
	<screen>
	  <![CDATA[
>>> from django.template import Template, Context
>>> raw_template = """<p>Dear {{ person_name }},</p>
...
... <p>Thanks for placing an order from {{ company }}. It's scheduled to
... ship on {{ ship_date|date:"F j, Y" }}.</p>
...
... {% if ordered_warranty %}
... <p>Your warranty information will be included in the packaging.</p>
... {% else %}
... <p>You didn't order a warranty, so you're on your own when
... the products inevitably stop working.</p>
... {% endif %}
...
... <p>Sincerely,<br />{{ company }}</p>"""
>>> t = Template(raw_template)
>>> import datetime
>>> c = Context({'person_name': 'John Smith',
...     'company': 'Outdoor Equipment',
...     'ship_date': datetime.date(2009, 4, 2),
...     'ordered_warranty': False})
>>> t.render(c)
u"<p>Dear John Smith,</p>\n\n<p>Thanks for placing an order from Outdoor
Equipment. It's scheduled to\nship on April 2, 2009.</p>\n\n\n<p>You
didn't order a warranty, so you're on your own when\nthe products
inevitably stop working.</p>\n\n\n<p>Sincerely,<br />Outdoor Equipment
</p>"
	  ]]>
	</screen>
      </para>

      <para>
	Рассмотрим каждую строку кода:

	<itemizedlist>
	  <listitem>
	    <para>
	      Сначала мы импортируем классы
	      <classname>Template</classname> и
	      <classname>Context</classname>, которые определены в
	      модуле <token>django.template</token>.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      Мы сохраняем оригинальный текст нашего шаблона в
	      переменной <varname>raw_template</varname>. Следует
	      отметить, что мы используем тройные кавычки для
	      выделения строки, так как мы имеем дело с многострочной
	      строкой. Дело в том, что строки, заключённый в одинарные
	      кавычки, не могут быть многострочными.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      Затем мы создаём шаблонный объект, <token>t</token>,
	      передавая <varname>raw_template</varname> в конструктор
	      класса <classname>Template</classname>.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      Мы импортируем модуль <token>datetime</token> из
	      стандартной библиотеки Python, так как нам он
	      понадобится в далее.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      Затем мы создаём контекстный объект,
	      <token>c</token>. Конструктор класса
	      <classname>Context</classname> принимает словарь,
	      который содержит ассоциированные именам значения. В
	      нашем случае, мы определили, что
	      <varname>person_name</varname> имеет значение
	      <token>'John Smith'</token>, <varname>company</varname>
	      &mdash; <token>'Outdoor Equipment'</token> и так далее.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      В конце мы вызвали метод <function>render()</function>
	      для нашего шаблонного объекта, передав ему контекст. Нам
	      был возвращён обработанный шаблон, т.е., метод заменил
	      переменные их действительными значениями и вычислил все
	      шаблонные теги.
	    </para>

	    <para>
	      Следует отметить, что параграф <quote>You didn’t order a
	      warranty</quote> был отображён, потому что переменная
	      <varname>ordered_warranty</varname> вычислилась в
	      <token>False</token>. Обратите внимание на дату,
	      <token>April 2, 2009</token>, которая отобразилась в
	      соответствии с заданным форматом &mdash; <token>'F j,
	      Y'</token>. (Мы расскажем о аргументак фильтра
	      <function>date</function> немного позже.)
	    </para>

	    <para>
	      Если вы новичок в Python, вы можете заинтересоваться
	      почему результат содержит символы перевода строки
	      (<token>\n</token>), вместо того, чтобы отображать
	      реальные переводы строк. Так происходит из-за тонкостей
	      работы интерактивного интерпретатора Python: вызов
	      <token>t.render(c)</token> возвращает строку и, по
	      умолчанию, интерактивный интерпретатор отображает
	      <emphasis>представление</emphasis> строки, вместо
	      печатного варианта строки. Если вы желаете получить
	      печатную строку, используйте оператор
	      <function>print</function>: <token>print
	      t.render(c)</token>.
	    </para>
	  </listitem>
	</itemizedlist>
      </para>

      <para>
	Таковы основы использования шаблонной системы Django: просто
	напишите шаблонную строку, создайте объект
	<classname>Template</classname>, создайте
	<classname>Context</classname> и вызовите метод
	<function>render()</function>.
      </para>
    
    </section>

    <section id="&BASEID;.usage.many-contexts">
      
      <title id="&BASEID;.usage.many-contexts.title">
	Множество контекстов и единственный шаблон
      </title>

      <para>
	После того, как вы создали объект
	<classname>Template</classname>, вы можете с его помощью
	обработать множество контекстов. Например:
	<screen>
	  <![CDATA[
# Так делать не стоит
for name in ('John', 'Julie', 'Pat'):
    t = Template('Hello, {{ name }}')
    print t.render(Context({'name': name}))

# Правильный подход
t = Template('Hello, {{ name }}')
for name in ('John', 'Julie', 'Pat'):
    print t.render(Context({'name': name}))
	  ]]>
	</screen>
      </para>

      <para>
	Django обрабатывает шаблон достаточно быстро. Внутри всё это
	сводится к вызову единственного регулярного выражения. Это
	сильно контрастирует по отношению к шаблонным движкам,
	построенных на XML, которые вносят затраты на разбор XML и по
	скорости проигрывают шаблонной системе Django.
      </para>

    </section>

    <section id="&BASEID;.usage.lookup">
      
      <title id="&BASEID;.usage.lookup.title">
	Поиск контекстной переменной
      </title>

      <para>
	В вышеприведённых примерах мы передавали простые значения в
	контекст, в основном это были строки, иногда даты. Тем не
	менее, шаблонная система легко обрабатывает более сложные
	структуры данных, такие как списки, словари и различные
	объекты.
      </para>

      <para>
	Ключом к такой всеядности является символ <token>.</token>
	(точка). Используйте точку для получения доступа к ключам
	словаря, атрибутам, методам и индексам объекта.
      </para>

      <para>
	Это хорошо проиллюстрировано в нескольких примерах. Например,
	предположим, что вы передали словарь в шаблон. Для получения
	доступа к значениям этого словаря по ключу следует
	использовать точку:
	<screen>
	  <![CDATA[
>>> from django.template import Template, Context
>>> person = {'name': 'Sally', 'age': '43'}
>>> t = Template('{{ person.name }} is {{ person.age }} years old.')
>>> c = Context({'person': person})
>>> t.render(c)
u'Sally is 43 years old.'
	  ]]>
	</screen>
      </para>

      <para>
	Аналогично, точка также позволяет получить доступ к атрибутам
	объекта. Например, объект <classname>datetime.date</classname>
	содержит атрибуты <token>year</token>, <token>month</token> и
	<token>day</token>, и вы можете получить к ним доступ:
	<screen>
	  <![CDATA[
>>> from django.template import Template, Context
>>> import datetime
>>> d = datetime.date(1993, 5, 2)
>>> d.year
1993
>>> d.month
5
>>> d.day
2
>>> t = Template('The month is {{ date.month }} and the year is {{ date.year }}.')
>>> c = Context({'date': d})
>>> t.render(c)
u'The month is 5 and the year is 1993.'
	  ]]>
	</screen>
      </para>

      <para>
	Следующий пример использует класс, демонстрируя методику
	получения доступа к атрибутам объекта:
	<screen>
	  <![CDATA[
>>> from django.template import Template, Context
>>> class Person(object):
...     def __init__(self, first_name, last_name):
...         self.first_name, self.last_name = first_name, last_name
>>> t = Template('Hello, {{ person.first_name }} {{ person.last_name }}.')
>>> c = Context({'person': Person('John', 'Smith')})
>>> t.render(c)
u'Hello, John Smith.'
	  ]]>
	</screen>
      </para>

      <para>
	С помощью точек можно получать доступ к
	<emphasis>методам</emphasis> объектов. Например, каждая строка
	Python обладает методами <function>upper()</function> и
	<function>isdigit()</function>, и вы можете использовать их в
	шаблонной системе Django с помощью <quote>точечного</quote>
	синтаксиса:
	<screen>
	  <![CDATA[
>>> from django.template import Template, Context
>>> t = Template('{{ var }} -- {{ var.upper }} -- {{ var.isdigit }}')
>>> t.render(Context({'var': 'hello'}))
u'hello -- HELLO -- False'
>>> t.render(Context({'var': '123'}))
u'123 -- 123 -- True'
	  ]]>
	</screen>
      </para>

      <para>
	Следует отметить, что <emphasis>не следует</emphasis>
	завершать имя метода скобками. Также нет никакой возможности
	передать аргументы в методы, вы можете использовать только те
	методы, которые не требуют аргументов. (Мы объясним такой
	подход немного позже в этой главе.)
      </para>

      <para>
	Наконец, точки используюся для доступа к элементам списка по
	индексу, например:
	<screen>
	  <![CDATA[
>>> from django.template import Template, Context
>>> t = Template('Item 2 is {{ items.2 }}.')
>>> c = Context({'items': ['apples', 'bananas', 'carrots']})
>>> t.render(c)
u'Item 2 is carrots.'
	  ]]>
	</screen>
      </para>

      <para>
	Отрицательные значения индекса не допускаются. Например,
	шаблонная переменная <token>{{ items.-1 }}</token> вызовет
	исключение <classname>TemplateSyntaxError</classname>.

	<note>
	  <title>
	    Списки в Python
	  </title>

	  <para>
	    Запомните: индексирование элементов списка в Python
	    начинается с нуля. Первый элемент имеет индекс 0, второй
	    &mdash; 1 и так далее.
	  </para>
	</note>
      </para>

      <para>
	Использование <quote>точечного</quote> синтаксиса можно
	описать так, когда шаблонная система обнаруживает точку в
	имени переменной, она пытается выполнить следующие действия в
	указанном порядке:

	<itemizedlist>
	  <listitem>
	    <para>
	      Поиск в словаре (т.е., <token>foo["bar"]</token>);
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      Поиск атрибута (т.е., <token>foo.bar</token>);
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      Вызов метода (т.е., <token>foo.bar()</token>);
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      Поиск в списке по индексу (т.е., <token>foo[2]</token>).
	    </para>
	  </listitem>
	</itemizedlist>
      </para>

      <para>
	Система использует первое, что сработает.
      </para>

      <para>
	<quote>Точечный</quote> поиск может быть
	многоуровневым. Например, в следующем примере используется
	переменная <token>{{ person.name.upper }}</token>, которая
	преобразовывается в поиск по словарю
	(<token>person['name']</token>) и затем вызывается метод
	(<function>upper()</function>):
	<screen>
	  <![CDATA[
>>> from django.template import Template, Context
>>> person = {'name': 'Sally', 'age': '43'}
>>> t = Template('{{ person.name.upper }} is {{ person.age }} years old.')
>>> c = Context({'person': person})
>>> t.render(c)
u'SALLY is 43 years old.'
	  ]]>
	</screen>
      </para>
    
      <section id="&BASEID;.usage.lookup.method-call">
      
	<title id="&BASEID;.usage.lookup.method-call.title">
	  Вызов методов
	</title>
	
	<para>
	  Вызовы методов являются более сложным процессом, чем другие
	  типы <quote>точечного</quote> поиска. Ниже представлены
	  вещи, о которых рекомендуется помнить:

	  <itemizedlist>
	    <listitem>
	      <para>
		Если в процессе <quote>точечного</quote> поиска метод
		вызывает исключение, оно будет обработано. Но только
		если исключение не будет иметь атрибута
		<varname>silent_variable_failure</varname>
		установленный в <token>True</token>. Если исключение
		<emphasis>имеет</emphasis> атрибут
		<varname>silent_variable_failure</varname>, переменная
		будет преобразовываться в пустую строку, например:
		<screen>
		  <![CDATA[
>>> t = Template("My name is {{ person.first_name }}.")
>>> class PersonClass3:
...     def first_name(self):
...         raise AssertionError, "foo"
>>> p = PersonClass3()
>>> t.render(Context({"person": p}))
Traceback (most recent call last):
...
AssertionError: foo

>>> class SilentAssertionError(AssertionError):
...     silent_variable_failure = True
>>> class PersonClass4:
...     def first_name(self):
...         raise SilentAssertionError
>>> p = PersonClass4()
>>> t.render(Context({"person": p}))
u'My name is .'
		  ]]>
		</screen>
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		Вызов метода срабатывает только в случае, если метод
		не требует наличия аргументов. В противном случае,
		система попробует следующий тип поиска (поиск в списке
		по индексу).
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		Очевидно, что некоторые методы будут иметь побочные
		эффекты и, в лучшем случае, было бы глупо давать
		шаблонной системе доступ к ним.
	      </para>

	      <para>
		Например, у вас есть объект
		<classname>BankAccount</classname>, у которого есть
		метод <function>delete()</function>. Если шаблон
		содержит что-то аналогичное <token>{{ account.delete
		}}</token>, где <token>account</token> &mdash; это
		объект <classname>BankAccount</classname>, то объект
		будет удалён во время обработки шаблона!
	      </para>

	      <para>
		Чтобы сделать такое невозможным, установите для этого
		метода атрибут <token>alters_data</token>:
		<screen>
		  <![CDATA[
def delete(self):
    # Delete the account
delete.alters_data = True
		  ]]>
		</screen>
	      </para>

	      <para>
		Шаблонная система не будет выполнять метод, помеченный
		таким образом. Продолжая обсуждение вышеприведённого
		примера, если шаблон содержит <token>{{ account.delete
		}}</token> и метод <function>delete()</function> имеет
		<token>alters_data=True</token>, то метод
		<function>delete()</function> не будет выполнен при
		обработке шаблона, он будет просто проигнорирован.
	      </para>
	    </listitem>
	  </itemizedlist>
	</para>

      </section>

      <section id="&BASEID;.usage.lookup.invalid-vars">
      
	<title id="&BASEID;.usage.lookup.invalid-vars.title">
	  Обработка неправильных переменных
	</title>
	
	<para>
	  По умолчанию, если переменная не существует, шаблонная
	  система отобразит такую переменную как пустую
	  строку. Например:
	  <screen>
	    <![CDATA[
>>> from django.template import Template, Context
>>> t = Template('Your name is {{ name }}.')
>>> t.render(Context())
u'Your name is .'
>>> t.render(Context({'var': 'hello'}))
u'Your name is .'
>>> t.render(Context({'NAME': 'hello'}))
u'Your name is .'
>>> t.render(Context({'Name': 'hello'}))
u'Your name is .'
	    ]]>
	  </screen>
	</para>

	<para>
	  Система просто игнорирует такие шаблонные переменные, не
	  вызывая исключение, потому что она должна быть устойчивой к
	  человеческим ошибкам. В данном случае все
	  <quote>точечные</quote> проверки будут неудачными. В случае
	  настоящего приложения недопустимо, чтобы web-сайт стал
	  недоступным из-за маленькой ошибки в шаблоне.
	</para>

      </section>

    </section>

    <section id="&BASEID;.usage.playing">
      
      <title id="&BASEID;.usage.playing.title">
	Играем с контекстными объектами
      </title>
    
      <para>
	Большую часть времени, вы будете создавать объекты
	<classname>Context</classname> передавая готовый словарь в
	<function>Context()</function>. Но вы можете добавлять и
	удалять элементы из объекта <classname>Context</classname>
	после его создания, используя стандартный синтаксис словаря
	Python:
	<screen>
	  <![CDATA[
>>> from django.template import Context
>>> c = Context({"foo": "bar"})
>>> c['foo']
'bar'
>>> del c['foo']
>>> c['foo']
Traceback (most recent call last):
  ...
KeyError: 'foo'
>>> c['newvariable'] = 'hello'
>>> c['newvariable']
'hello'
	  ]]>
	</screen>
      </para>

    </section>

  </section>

  <section id="&BASEID;.tags-and-filters">
    
    <title id="&BASEID;.tags-and-filters.title">
      Основные шаблонные теги и фильтры
    </title>
    
    <para>
      Как мы уже говорили ранее, шаблонная система поставляется со
      встроенными тегами и фильтрами. Следующие разделы описывают
      основные теги и шаблоны.
    </para>

    <section id="&BASEID;.tags-and-filters.tags">
    
      <title id="&BASEID;.tags-and-filters.tags.title">
	Теги
      </title>

      <section id="&BASEID;.tags-and-filters.tags.if-else">
	
	<title id="&BASEID;.tags-and-filters.tags.if-else.title">
	  if/else
	</title>

	<para>
	  Тег <token>{% if %}</token> вычисляет переменную и если
	  результатом вычисления является <token>True</token> (т.е.,
	  она существует, не пустая и не равна <token>False</token>),
	  система отображает всё между <token>{% if %}</token> и
	  <token>{% endif %}</token>, например:
	  <screen>
	    <![CDATA[
{% if today_is_weekend %}
    <p>Welcome to the weekend!</p>
{% endif %}
	    ]]>
	  </screen>
	</para>

	<para>
	  Тег <token>{% else %}</token> является необязательным:
	  <screen>
	    <![CDATA[
{% if today_is_weekend %}
    <p>Welcome to the weekend!</p>
{% else %}
    <p>Get back to work.</p>
{% endif %}
	    ]]>
	  </screen>
	</para>

	<para>
	  <note>
	    <title>
	      <quote>Истина</quote> в Python
	    </title>

	    <para>
	      В Python и в шаблонной системе Django нижеприведённые
	      объекты вычисляются в <token>False</token> в контексте
	      <classname>Boolean</classname>:

	      <itemizedlist>
		<listitem>
		  <para>
		    Пустой список (<token>[]</token>);
		  </para>
		</listitem>

		<listitem>
		  <para>
		    Пустой кортеж (<token>()</token>);
		  </para>
		</listitem>

		<listitem>
		  <para>
		    Пустой словарь (<token>{}</token>);
		  </para>
		</listitem>

		<listitem>
		  <para>
		    Ноль (<token>0</token>);
		  </para>
		</listitem>

		<listitem>
		  <para>
		    Особый объект <classname>None</classname>;
		  </para>
		</listitem>

		<listitem>
		  <para>
		    Объект <classname>False</classname> (это очевидно);
		  </para>
		</listitem>

		<listitem>
		  <para>
		    Особые объекты, которые определяют их собственное
		    поведение <classname>Boolean</classname> (это
		    питонские навороты).
		  </para>
		</listitem>
	      </itemizedlist>
	    </para>

	    <para>
	      Всё остальное вычисляется в <token>True</token>.
	    </para>
	  </note>
	</para>

	<para>
	  Тег <token>{% if %}</token> принимает <token>and</token>,
	  <token>or</token> или <token>not</token> для тестирования
	  множества переменных или инвертирования. Например:
	  <screen>
	    <![CDATA[
{% if athlete_list and coach_list %}
    Both athletes and coaches are available.
{% endif %}

{% if not athlete_list %}
    There are no athletes.
{% endif %}

{% if athlete_list or coach_list %}
    There are some athletes or some coaches.
{% endif %}

{% if not athlete_list or coach_list %}
    There are no athletes or there are some coaches.
{% endif %}

{% if athlete_list and not coach_list %}
    There are some athletes and absolutely no coaches.
{% endif %}
	    ]]>
	  </screen>
	</para>

	<para>
	  Теги <token>{% if %}</token> не позволяют объединять
	  <token>and</token> и <token>or</token> в одном теге, потому
	  что порядок логики будет двусмысленным. Пример с ошибкой:
	  <screen>
	    <![CDATA[
{% if athlete_list and coach_list or cheerleader_list %}
	    ]]>
	  </screen>
	</para>

	<para>
	  Использование скобок для управления порядком операций не
	  поддерживается. Если вам потребуются скобки, рассмотрите
	  применение логики вне шаблона и передачу результата
	  вычисления в виде выделенной шаблонной переменной. Или
	  просто используйте вложенные теги <token>{% if %}</token>,
	  например:
	  <screen>
	    <![CDATA[
{% if athlete_list %}
    {% if coach_list or cheerleader_list %}
        We have athletes, and either coaches or cheerleaders!
    {% endif %}
{% endif %}
	    ]]>
	  </screen>
	</para>

	<para>
	  Допускается множественное использование одного и того же
	  логического оператора, но вы не можете объединять различные
	  операторы. Вот правильное использование:
	  <screen>
	    <![CDATA[
{% if athlete_list or coach_list or parent_list or teacher_list %}
	    ]]>
	  </screen>
	</para>

	<para>
	  Тега <token>{% elif %}</token> не существует. Используйте
	  вложенные теги <token>{% if %}</token> для решения такой
	  задачи:
	  <screen>
	    <![CDATA[
{% if athlete_list %}
    <p>Here are the athletes: {{ athlete_list }}.</p>
{% else %}
    <p>No athletes are available.</p>
    {% if coach_list %}
        <p>Here are the coaches: {{ coach_list }}.</p>
    {% endif %}
{% endif %}
	    ]]>
	  </screen>
	</para>

	<para>
	  Не забывайте закрывать каждый тег <token>{% if %}</token> с
	  помощью <token>{% endif %}</token>. В противном случае
	  Django будет вызывать исключение
	  <classname>TemplateSyntaxError</classname>.
	</para>

      </section>

      <section id="&BASEID;.tags-and-filters.tags.for">
	
	<title id="&BASEID;.tags-and-filters.tags.for.title">
	  for
	</title>

	<para>
	  Тег <token>{% for %}</token> позволяет обработать каждый
	  элемент последовательности. Аналогично оператору
	  <token>for</token> языка Python, синтаксис таков <token>for
	  X in Y</token>, где <token>Y</token> &mdash; это
	  последовательность, а <token>X</token> &mdash; это имя
	  переменной, в которую помещается значение текущего
	  элемента. На каждом шагу цикла, шаблонная система выводит
	  всё, что находится между тегами <token>{% for %}</token> и
	  <token>{% endfor %}</token>.
	</para>

	<para>
	  Например, вы можете использовать следующих пример для
	  отображения списка атлетов, который находится в
	  <varname>athlete_list</varname>:
	  <screen>
	    <![CDATA[
<ul>
{% for athlete in athlete_list %}
    <li>{{ athlete.name }}</li>
{% endfor %}
</ul>
	    ]]>
	  </screen>
	</para>

	<para>
	  Добавьте <token>reversed</token> к тегу для обработки списка
	  в обратном порядке:
	  <screen>
	    <![CDATA[
{% for athlete in athlete_list reversed %}
...
{% endfor %}
	    ]]>
	  </screen>
	</para>

	<para>
	  Теги <token>{% for %}</token> можно вкладывать друг в друга:
	  <screen>
	    <![CDATA[
{% for athlete in athlete_list %}
    <h1>{{ athlete.name }}</h1>
    <ul>
    {% for sport in athlete.sports_played %}
        <li>{{ sport }}</li>
    {% endfor %}
    </ul>
{% endfor %}
	    ]]>
	  </screen>
	</para>

	<para>
	  Ниже показан стандартный способ проверки размера списка
	  перед итерацией по его элементам или вывода отдельного
	  сообщения, в случае пустого списка:
	  <screen>
	    <![CDATA[
{% if athlete_list %}
    {% for athlete in athlete_list %}
        <p>{{ athlete.name }}</p>
    {% endfor %}
{% else %}
    <p>There are no athletes. Only computer programmers.</p>
{% endif %}
	    ]]>
	  </screen>
	</para>

	<para>
	  Так как этот способ часто употребляется на практике, тег
	  <token>{% for %}</token> поддерживает необязательный
	  оператор <token>{% empty %}</token>, который позволяет
	  выводить сообщение, в случае пустого списка. Этот пример
	  эквивалентен предыдущему:
	  <screen>
	    <![CDATA[
{% for athlete in athlete_list %}
    <p>{{ athlete.name }}</p>
{% empty %}
    <p>There are no athletes. Only computer programmers.</p>
{% endfor %}
	    ]]>
	  </screen>
	</para>

	<para>
	  Нет стандартной возможности прекратить цикл до окончания
	  обработки списка. Если вам надо это сделать, создайтё
	  переменную, которая будет содержать список только с теми
	  значениями, которые нужны. Аналогично, нет поддержки
	  оператора <token>continue</token>, который бы позволил
	  перейти к обработке следующего элемента списка. (Обратитесь
	  к разделу <quote><xref linkend="&BASEID;.limitations"
	  endterm="&BASEID;.limitations.title"/></quote> для описания
	  причин, которые привели к такому поведению тега.)
	</para>

	<para>
	  Во время каждой итерации <token>{% for %}</token> вы
	  получаете доступ к шаблонной переменной
	  <varname>forloop</varname>. Эта переменная обладает
	  несколькими атрибутами, которые предоставляют информацию о
	  текущем цикле:

	  <itemizedlist>
	    <listitem>
	      <para>
		<varname>forloop.counter</varname> всегда содержит
		целое число, представляющее собой количество
		выполненных итераций, включая текущую. Отсчёт
		начинается с единицы, таким образом, во время первой
		итерации данный атрибут будет иметь значение
		<token>1</token>. Пример:
		<screen>
		  <![CDATA[
{% for item in todo_list %}
    <p>{{ forloop.counter }}: {{ item }}</p>
{% endfor %}
		  ]]>
		</screen>
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		<varname>forloop.counter0</varname> аналогичен
		<varname>forloop.counter</varname>, только отсчёт
		начинается с нуля. То есть, во время первой итерации
		данный атрибут будет иметь значение <token>0</token>.
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		<varname>forloop.revcounter</varname> всегда содержит
		целое число, представляющее собой количество
		оставшихся итераций. Во время первой итерации данный
		атрибут содержит число, равное количеству итераций
		цикла, а время последней итерации &mdash; атрибут
		содержит значение <token>1</token>.
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		<varname>forloop.revcounter0</varname> аналогичен
		атрибуту <varname>forloop.revcounter</varname>, только
		отсчёт начинается с нуля. Во время первой итерации
		данный атрибут содержит число, равное количеству
		итераций цикла минус единица, а время последней
		итерации &mdash; атрибут содержит значение
		<token>0</token>.
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		<varname>forloop.first</varname> является
		<token>Boolean</token> и установлен в
		<token>True</token> только во время первой итерации
		цикла. Пример использования:
		<screen>
		  <![CDATA[
{% for object in objects %}
    {% if forloop.first %}<li class="first">{% else %}<li>{% endif %}
    {{ object }}
    </li>
{% endfor %}
		  ]]>
		</screen>
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		<varname>forloop.last</varname> является
		<token>Boolean</token> и установлен в
		<token>True</token> только во время последней итерации
		цикла. Пример использования:
		<screen>
		  <![CDATA[
{% for link in links %}{{ link }}
  {% if not forloop.last %}|{% endif %}
{% endfor %}
		  ]]>
		</screen>
	      </para>

	      <para>
		После обработки данного тега получается примерно такой
		результат:
		<screen>
		  <![CDATA[
Link1 | Link2 | Link3 | Link4
		  ]]>
		</screen>
	      </para>

	      <para>
		Другим пример может быть пример с разделением слов с
		помощью запятой:
		<screen>
		  <![CDATA[
Favorite places:
{% for p in places %}{{ p }}{% if not forloop.last %}, {% endif %}{% endfor %}
		  ]]>
		</screen>
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		<varname>forloop.parentloop</varname> является ссылкой
		на объект <token>forloop</token>
		<emphasis>родительского</emphasis> цикла, в случае
		вложенных циклов. Пример:
		<screen>
		  <![CDATA[
{% for country in countries %}
    <table>
    {% for city in country.city_list %}
        <tr>
        <td>Country #{{ forloop.parentloop.counter }}</td>
        <td>City #{{ forloop.counter }}</td>
        <td>{{ city }}</td>
        </tr>
    {% endfor %}
    </table>
{% endfor %}
		  ]]>
		</screen>
	      </para>
	    </listitem>
	  </itemizedlist>
	</para>

	<para>
	  Эта волшебная переменная <varname>forloop</varname> доступна
	  только внутри циклов. После того, как парсер достигнет тега
	  <token>{% endfor %}</token>, переменная
	  <varname>forloop</varname> уничтожается.
	</para>

	<para>
	  <note>
	    <title>
	      Контекст и переменная <varname>forloop</varname>
	    </title>

	    <para>
	      Inside the <token>{% for %}</token> block, the existing
	      variables are moved out of the way to avoid overwriting
	      the magic <varname>forloop</varname> variable. Django
	      exposes this moved context in
	      <varname>forloop.parentloop</varname> FIXME. В общем
	      случае вам не надо беспокоиться об этом, но если вы
	      будете использовать в блоке переменную
	      <varname>forloop</varname> (не смотря на наши
	      рекомендации не делать так), она будет переименована в
	      <varname>forloop.parentloop</varname> на время обработки
	      блока <token>{% for %}</token>.
	    </para>
	  </note>
	</para>

      </section>

      <section id="&BASEID;.tags-and-filters.tags.ifequal-ifnotequal">
	
	<title id="&BASEID;.tags-and-filters.tags.ifequal-ifnotequal.title">
	  ifequal/ifnotequal
	</title>

	<para>
	  Шаблонная система Django умышленно создана в виде
	  неполноценного языка программирования и, следовательно, не
	  позволит вам выполнить операторы языка Python. (Более
	  подробно данный аспект рассмотрен в разделе <quote><xref
	  linkend="&BASEID;.limitations"
	  endterm="&BASEID;.limitations.title"/></quote> данной
	  главы.) Тем не менее, сравнение двух значений и отображение
	  некой информации в случае равенства является достаточно
	  общим требованием к шаблонам. И Django предоставляет тег
	  <token>{% ifequal %}</token> для решения данной задачи.
	</para>

	<para>
	  Тег <token>{% ifequal %}</token> сравнивает два значения и
	  отображает всё, что находится между <token>{% ifequal
	  %}</token> и <token>{% endifequal %}</token>, если эти
	  значения равны.
	</para>

	<para>
	  Данный пример сравнивает шаблонные переменные
	  <varname>user</varname> и <varname>currentuser</varname>:
	  <screen>
	    <![CDATA[
{% ifequal user currentuser %}
    <h1>Welcome!</h1>
{% endifequal %}
	    ]]>
	  </screen>
	</para>

	<para>
	  Аргументами могут служить строки (вбитые в шаблон),
	  ограниченные одинарными или двойными кавычками, вот пример:
	  <screen>
	    <![CDATA[
{% ifequal section 'sitenews' %}
    <h1>Site News</h1>
{% endifequal %}

{% ifequal section "community" %}
    <h1>Community</h1>
{% endifequal %}
	    ]]>
	  </screen>
	</para>

	<para>
	  Аналогично <token>{% if %}</token>, тег <token>{% ifequal
	  %}</token> поддерживает необязательный тег <token>{% else
	  %}</token>:
	  <screen>
	    <![CDATA[
{% ifequal section 'sitenews' %}
    <h1>Site News</h1>
{% else %}
    <h1>No News Here</h1>
{% endifequal %}
	    ]]>
	  </screen>
	</para>

	<para>
	  В качестве аргументов тега разрешено использовать только
	  переменные, строки, целые и десятичные числа. Ниже показаны
	  примеры правильного использования:
	  <screen>
	    <![CDATA[
{% ifequal variable 1 %}
{% ifequal variable 1.23 %}
{% ifequal variable 'foo' %}
{% ifequal variable "foo" %}
	    ]]>
	  </screen>
	</para>

	<para>
	  Любые другие типы переменных, подобных словарям, спискам или
	  логическим значениям не могут быть использованы в <token>{%
	  ifequal %}</token>. Ниже показаны примеры неправильного
	  использования:
	  <screen>
	    <![CDATA[
{% ifequal variable True %}
{% ifequal variable [1, 2, 3] %}
{% ifequal variable {'key': 'value'} %}
	    ]]>
	  </screen>
	</para>

	<para>
	  Если вам требуется проверить соответствие чего-либо
	  логическому значению, используйте тег <token>{% if
	  %}</token> вместо <token>{% ifequal %}</token>.
	</para>
	  
      </section>

      <section id="&BASEID;.tags-and-filters.tags.comments">
	
	<title id="&BASEID;.tags-and-filters.tags.comments.title">
	  Комментарии
	</title>

	<para>
	  Аналогично принятому в HTML или Python, шаблонный язык
	  Django позволяет использовать комментарии. Для определения
	  комментария используйте <token>{# #}</token>:
	  <screen>
	    <![CDATA[
{# This is a comment #}
	    ]]>
	  </screen>
	</para>

	<para>
	  Комментарий не будет отображен при обработке шаблона.
	</para>

	<para>
	  Комментарии, использующие данный синтаксис, не могут быть
	  многострочными. Данное ограничение повышает
	  производительность обработки шаблонов. При обработке
	  следующего шаблона комментарий будет отображён как есть
	  (т.е., тег не будет распознан как комментарий):
	  <screen>
	    <![CDATA[
This is a {# this is not
a comment #}
test.
	    ]]>
	  </screen>
	</para>

	<para>
	  Если вам необходимо использовать многострочные комментарии,
	  используйте шаблонный тег <token>{% comment %}</token>, вот
	  так:
	  <screen>
	    <![CDATA[
{% comment %}
This is a
multi-line comment.
{% endcomment %}
	    ]]>
	  </screen>
	</para>
	  
      </section>

    </section>

    <section id="&BASEID;.tags-and-filters.filters">
    
      <title id="&BASEID;.tags-and-filters.filters.title">
	Фильтры
      </title>

      <para>
	Как было описано ранее в этой главе, шаблонные фильтры
	представляют собой простой способ изменения значения пееменных
	перед их отображением. Фильтры используют символ
	<token>|</token>:
	<screen>
	  <![CDATA[
{{ name|lower }}
	  ]]>
	</screen>
      </para>

      <para>
	Этот код выведет значение переменной <token>{{ name
	}}</token>, после его обработки фильтром <token>lower</token>,
	который преобразует буквы текста в нижний регистр.
      </para>

      <para>
	Фильтры могут <emphasis>подключаться один к
	другому</emphasis>. Ниже показан пример, который берёт первый
	элемент списка и преобразовывает его в верхний регистр:
	<screen>
	  <![CDATA[
{{ my_list|first|upper }}
	  ]]>
	</screen>
      </para>

      <para>
	Некоторые фильтры принимают аргументы. Аргумент фильтра
	указывается после двоеточия и всегда в двойных
	кавычках. Например:
	<screen>
	  <![CDATA[
{{ bio|truncatewords:"30" }}
	  ]]>
	</screen>
      </para>

      <para>
	Этот код отобразит первые тридцать слов из переменной
	<varname>bio</varname>.
      </para>

      <para>
	Далее представлены несколько наиболее важных
	фильтров. Приложение F FIXME описывает все остальные.

	<itemizedlist>
	  <listitem>
	    <para>
	      <token>addslashes</token>: Добавляет обратные слеш перед
	      символами: обратный слеш, одинарная или двойная
	      кавычки. Это удобно при включении созданного текста в
	      строку JavaScript.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <token>date</token>: Форматирует вывод объекта
	      <token>date</token> или <token>datetime</token> в
	      соответствии с форматной строкой, переданной в
	      параметре, например:
	      <screen>
		<![CDATA[
{{ pub_date|date:"F j, Y" }}
		]]>
	      </screen>
	      Формат аргумента определён в приложении F FIXME.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <token>length</token>: Возвращает длину значения. Для
	      списка возвращается количество его элементов. Для строки
	      &mdash; количество символов. (Следует отметить, что этот
	      фильтр работает с любым объектом Python, который значет
	      как определять свою длину, т.е., с любым объектом
	      обладающим методом <function>__len__()</function>.)
	    </para>
	  </listitem>
	</itemizedlist>
      </para>

    </section>

  </section>

  <section id="&BASEID;.limitations">
    
    <title id="&BASEID;.limitations.title">
      Философия и ограничения
    </title>

    <para>
      Теперь, когда у вас есть понимание языка шаблонов Django, мы
      должны остановиться на его осознанных ограничениях и на том,
      почему так сделано.
    </para>

    <para>
      Мнения разработчиков о шаблонной системе варьируются очень
      широко по сравнению с другими компонентами веб
      приложений. Поддерживает это утверждение тот факт, что сам
      Python содержит их десятки, если не сотни. Каждая шаблонная
      система вероятно была создана потому что её разработчик счёл все
      существующие системы неподходящими. (В действительности,
      существует своеобразный экзамен для разработчика на Python —
      написать свой собственный язык шаблонной системы! Если вы не
      сделали такого, попробуйте. Это интересный опыт.)
    </para>

    <para>
      Помня это, вам возможно будет интересно узнать, что Django не
      требует, чтобы вы использовали именно её язык шаблонов. По
      причине того, что Django создана как полноценная система веб
      разработки, которая предоставляет все необходимые компоненты для
      продуктивной работы, будет <emphasis>гораздо удобнее</emphasis>
      использовать её шаблонную систему, вместо других шаблонных
      библиотек Python. Но это не накладывает никаких ограничений на
      вас. Как вы увидите в разделе <quote><xref
      linkend="&BASEID;.usage-templates"
      endterm="&BASEID;.usage-templates.title"/></quote>, очень легко
      использовать другой шаблонный язык совместно с Django.
    </para>

    <para>
      Но уже сейчас ясно, что мы настойчиво предлагаем использовать
      шаблонный язык Django. Шаблонная система ведёт свою историю из
      разработки для World Online и объединяет опыт создателей
      Django. Вот некоторые из постулатов:

      <itemizedlist>
	<listitem>
	  <para>
	    <emphasis>Бизнес-логика должна быть отделена от логики
	    представления.</emphasis> Мы рассматриваем шаблонную
	    систему как инструмент управления представлением и логикой
	    для этого представления, не более. Шаблонная система не
	    должна поддерживать функциональность, которая выходит за
	    рамки этой основополагающей цели.
	  </para>

	  <para>
	    По этой причине нет возможности вызвать напрямую код на
	    языке Python из шаблонов Django. Всё
	    <quote>программирование</quote> принципиально ограничено
	    рамками возможностей тегов. Можно
	    <emphasis>создать</emphasis> пользовательские шаблонные
	    теги для выполнения определённых задач, но намеренно не
	    позволяется выполнять код на языке Python вне тегов
	    шаблона.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    <emphasis>Синтаксис должен быть отделён от
	    HTML/XML.</emphasis> Несмотря на то, что шаблонная система
	    Django используется в первую очередь для генерации HTML,
	    она разрабатывалась с поддержкой не HTML форматов, таких
	    как обычный текст. Некоторые другие языки шаблонов
	    основаны на XML, размещая всю шаблонную логику в тегах и
	    атрибутах XML, но Django сознательно избегает это
	    ограничение. Требование верного XML для создания шаблонов
	    привносит целый букет человеческих ошибок и
	    трудно-понимаемых сообщений о них. Также, использование
	    XML парсера привносит неприемлемый уровень нагрузки на
	    процессор шаблонов.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    <emphasis>Предполагается, что дизайнеры способны работать
	    с чистым HTML.</emphasis> Шаблонная система не разработана
	    так, чтобы шаблоны всегда отображались красиво в WYSIWYG
	    редакторах, подобных Dreamweaver. Поддержка таких
	    редакторов накладывает слишком серьёзные ограничения на
	    синтаксис шаблона. Django ожидает, что авторы шаблонов
	    работают с HTML напрямую.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    <emphasis>Предполагается, что дизайнеры не являются Python
	    программистами.</emphasis> Авторы шаблонной системы
	    признают, что чаще всего шаблоны для страниц
	    разрабатываются <emphasis>дизайнерами</emphasis>, не
	    <emphasis>разработчиками</emphasis>, и, следовательно, это
	    не должно предполагать наличия знания языка Python.
	  </para>

	  <para>
	    Тем не менее, шаблонная система старается поддерживать
	    небольшие команды, в которых шаблоны
	    <emphasis>создаются</emphasis> Python программистами. Она
	    предлагает способ расширения синтаксиса системы с помощью
	    кода на языке Python (подробности в главе 9 FIXME).
	  </para>
	</listitem>

	<listitem>
	  <para>
	    <emphasis>Изобретение языка программирования &mdash; не
	    наша цель.</emphasis> Цель &mdash; предложить достаточно
	    программистской функциональности, такой как ветвление и
	    циклы, чего будет достаточно для презентационных решений.
	  </para>
	</listitem>
      </itemizedlist>
    </para>

  </section>

  <section id="&BASEID;.usage-templates">
    
    <title id="&BASEID;.usage-templates.title">
      Использование шаблонов в представлениях
    </title>

  </section>

  <section id="&BASEID;.loading-templates">
    
    <title id="&BASEID;.loading-templates.title">
      Загрузка шаблонов
    </title>

    <section id="&BASEID;.loading-templates.render-to-response">
    
      <title id="&BASEID;.loading-templates.render-to-response.title">
	render_to_response()
      </title>

    </section>

    <section id="&BASEID;.loading-templates.locals-trick">
    
      <title id="&BASEID;.loading-templates.locals-trick.title">
	Трюк с locals()
      </title>

    </section>

    <section id="&BASEID;.loading-templates.subdirs">
    
      <title id="&BASEID;.loading-templates.subdirs.title">
	Подкаталоги в get_template()
      </title>

    </section>

    <section id="&BASEID;.loading-templates.include">
    
      <title id="&BASEID;.loading-templates.include.title">
	Шаблонный тег include
      </title>

    </section>

  </section>

  <section id="&BASEID;.template-inheritance">
    
    <title id="&BASEID;.template-inheritance.title">
      Наследование шаблонов
    </title>
    
  </section>

</chapter>