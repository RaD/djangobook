<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
"http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd"
[
<!ENTITY BASEID "djangobook.chap04">
]>

<chapter lang="ru" id="&BASEID;">

  <title id="&BASEID;.title">
    Шаблоны
  </title>

  <para>
    Перевод &copy; Попов Руслан &lt;radz &bull; yandex &bull; ru&gt;
  </para>

  <para>
    В предыдущей главе вы могли заметить что-то особенное в том, как
    мы возвращали текст в наших представлениях. А именно, HTML был
    напрямую вбит в код на Python, примерно так:
    <screen>
      <![CDATA[
def current_datetime(request):
    now = datetime.datetime.now()
    html = "<html><body>It is now %s.</body></html>" % now
    return HttpResponse(html)
      ]]>
    </screen>
  </para>

  <para>
    Несмотря на то, что данный подход был удобен для объяснения
    принципов работы представления, он не может быть признан годным
    для использования в реальных проектах. И вот почему:

    <itemizedlist>
      <listitem>
	<para>
	  Любое изменение в дизайне страницы требует изменения в
	  коде. Дизайн сайта изменяется гораздо чаще, чем сам код
	  сайта. Удобнее будет иметь возможность вносить изменения в
	  дизайн, не затрагивая код.
	</para>
      </listitem>

      <listitem>
	<para>
	  Разработка кода на языке Python и работа с HTML являются
	  двумя различными дисциплинам и наиболее профессиональные
	  среды web-разработки разделяют такую ответственность между
	  отдельными людьми (или даже отдельными подразделениями). От
	  дизайнеров и HTML/CSS кодеров не следует требовать
	  редактирования Python кода для выполнения их работы.
	</para>
      </listitem>

      <listitem>
	<para>
	  Возможность одновременной работы программистов на Python
	  кодом и дизайнеров над шаблонами является наиболее
	  эффективным подходом, в отличие от необходимости одним
	  ожидать окончания работ других, чтобы приступить к
	  выполнению своих задач.
	</para>
      </listitem>
    </itemizedlist>
  </para>

  <para>
    По этим причинам гораздо проще и более удобно разделять дизай
    страницы от кода, обеспечивающего её работу. Мы можем сделать это
    с помощью <emphasis>шаблонной системы</emphasis> Django, которую
    мы обсудим в этой главе.
  </para>

  <section id="&BASEID;.basics">

    <title id="&BASEID;.basics.title">
      Основы шаблонной системы
    </title>
    
    <para>
      Шаблон Dkango &mdash; это строка текста, которая предназначена
      для разделения представления документа от его данных. Шаблон
      определяет места подстановки и различные виды основной логики
      (шаблонные теги), которая управляет отображением
      документа. Обычно, шаблоны используются для создания HTML, но
      шаблоны Django также способны участвовать в генерации любого
      текстового формата.
    </para>

    <para>
      Давайте начнём с простого примера. Данный шаблон описывает HTML
      страницу, которая благодарит посетителя за заказ, отправленный
      компании. Рассматривайте его как вид письма:
      <screen>
	<![CDATA[
<html>
<head><title>Ordering notice</title></head>

<body>

<h1>Ordering notice</h1>

<p>Dear {{ person_name }},</p>

<p>Thanks for placing an order from {{ company }}. It's scheduled to
ship on {{ ship_date|date:"F j, Y" }}.</p>

<p>Here are the items you've ordered:</p>

<ul>
{% for item in item_list %}
    <li>{{ item }}</li>
{% endfor %}
</ul>

{% if ordered_warranty %}
    <p>Your warranty information will be included in the packaging.</p>
{% else %}
    <p>You didn't order a warranty, so you're on your own when
    the products inevitably stop working.</p>
{% endif %}

<p>Sincerely,<br />{{ company }}</p>

</body>
</html>
	]]>
      </screen>
    </para>

    <para>
      Данный шаблон представляет собой обычный HTML с несколькими
      переменными и шаблонными тегами. Рассмотрим его подробнее:

      <itemizedlist>
	<listitem>
	  <para>
	    Любой текст взятый в скобки (т.е., <token>{{ person_name
	    }}</token>) является <emphasis>переменной</emphasis>. Это
	    означает <quote>вставить значение переменной с указанным
	    именем.</quote> (Как же мы определяем значения переменных?
	    Скоро мы это рассмотрим.)
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Любой текст взятый в фигурные скобки и проценты (т.е.,
	    <token>{% if ordered_warranty %}</token>) является
	    <emphasis>шаблонным тегом</emphasis>. Определение тега
	    достаточно простое: тег просто указывает шаблонной системе
	    <quote>сделать что-то.</quote>
	  </para>

	  <para>
	    Вышеприведёный шаблон содержит тег <token>for</token>
	    (<token>{% for item in item_list %}</token>) и тег
	    <token>if</token> (<token>{% if ordered_warranty
	    %}</token>).
	  </para>

	  <para>
	    Тег <token>for</token> работает почти так же как и
	    оператор <token>for</token> языка Python, позволяя вам
	    циклически обрабатывать каждый элемент
	    последовательности. Тег <token>if</token>, как вы можете
	    ожидать, работает аналогично логическому оператору
	    <token>if</token>. В данном примере, тег проверяет
	    является ли <token>True</token> значением
	    <varname>ordered_warranty</varname>. Если это так,
	    шаблонная система отобразит всё, что находится между
	    <token>{% if ordered_warranty %}</token> и <token>{% else
	    %}</token>. В противном случае, шаблонная система
	    отобразит всё между <token>{% else %}</token> и <token>{%
	    endif %}</token>. Следует отметить, что элемент <token>{%
	    else %}</token> является необязательным.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Наконец, второй параграф данного шаблона содержит пример
	    использования <emphasis>фильтра</emphasis>, который
	    предоставляет наиболее удобный способ изменения формата
	    переменной. В данном примере, <token>{{ ship_date|date:"F
	    j, Y" }}</token>, мы передаём значение переменной
	    <varname>ship_date</varname> фильтру <token>date</token>,
	    указывая для него аргументы <token>"F j,
	    Y"</token>. Фильтр <token>date</token> форматирует дату в
	    соответствии с указанным форматом. Фильтры подключаются к
	    переменным с помощью символа <token>|</token>, аналогично
	    Unix потокам.
	  </para>
	</listitem>
      </itemizedlist>
    </para>

    <para>
      Каждый шаблон Django имеет доступ к некоторому количеству
      встроенных тегов и фильтров, многие из которых будут рассмотрены
      в последующих разделах главы. Приложение F FIXME содержит полный
      список тегов и фильтров, будет неплохо, если вы ознакомитесь с
      этим списком. Также есть возможность создавать свои собственный
      фильтры и теги, мы рассмотрим это в главе 9 FIXME.
    </para>

  </section>

  <section id="&BASEID;.usage">

    <title id="&BASEID;.usage.title">
      Использование шаблонной системы
    </title>
    
    <para>
      Давайте рассмотрим шаблонную систему Django подробнее, вы
      сможете увидеть как она работает, но <emphasis>пока</emphasis>
      мы не будем интегрировать её с представлениями, которые мы
      создали в прошлой главе. Наша цель в данный момент &mdash;
      показать вам как шаблонная система работает независимо от
      остальной части Django. (Предположим другой способ: обычно вы
      будете использовать шаблонную систему совместно с
      представлениями, но мы желаем показать то, что шаблонная система
      является обычной библиотекой Python, которую вы можете
      использовать <emphasis>где угодно</emphasis>, не только с
      представлениями Django.)
    </para>

    <para>
      Ниже указан самый основной способ использования шаблонной
      системы Django в коде Python:

      <orderedlist>
	<listitem>
	  <para>
	    Создать объект <classname>Template</classname>, передав
	    ему шаблон в виде строки.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Вызвать метод <function>render()</function> объекта
	    <classname>Template</classname> с набором переменных
	    (<emphasis>контекст</emphasis>). Метод возвратит полностью
	    обработанный шаблон в виде строки, все переменные и
	    шаблонные теги будут вычислены в соответствии с
	    контекстом.
	  </para>
	</listitem>
      </orderedlist>
    </para>

    <para>
      Пример использования:
      <screen>
	<![CDATA[
>>> from django import template
>>> t = template.Template('My name is {{ name }}.')
>>> c = template.Context({'name': 'Adrian'})
>>> print t.render(c)
My name is Adrian.
>>> c = template.Context({'name': 'Fred'})
>>> print t.render(c)
My name is Fred.
	]]>
      </screen>
    </para>

    <para>
      Следующие разделы описывают каждый шаг более детально.
    </para>

    <section id="&BASEID;.usage.create">
      
      <title id="&BASEID;.usage.create.title">
	Создание шаблонных объектов
      </title>

      <para>
	Простейшим способом создания объекта
	<classname>Template</classname> является его прямое
	порождение. Класс <classname>Template</classname> расположен в
	модуле <token>django.template</token>, конструктор принимает
	единственный аргумент &mdash; строку с кодом шаблона. Давайте
	рассмотрим как это всё работает с помощью интерактивного
	интерпретатора языка Python.
      </para>

      <para>
	В каталоге проекта <token>mysite</token>, созданном с помощью
	команды <command>django-admin.py startproject</command> (это
	было описано в главе <quote><xref linkend="djangobook.chap02"
	endterm="djangobook.chap02.title"/></quote>), выполните
	команды <command>python manage.py shell</command> для запуска
	интерактивного интерпретатора.
      </para>

      <para>
	<note>
	  <title>
	    A special Python prompt FIXME
	  </title>

	  <para>
	    Если вы использовали Python ранее, вас может
	    заинтересовать, почему мы используем <command>python
	    manage.py shell</command>, а не просто
	    <command>python</command>. Обе команды запускают
	    интерпретатор, но наш вариант имеет одну ключевую
	    особенность: перед запуском интерпретатора, он указывает
	    Django какой файл конфигурации следует
	    использовать. Многие компоненты Django, включая шаблонную
	    систему, зависят от ваших настроек и вы не сможете их
	    использовать до тех пор, пока среда разработки не будет
	    знать где их брать.
	  </para>

	  <para>
	    Если вам это интересно, расскажем как всё это работает
	    внутри. Django ищет переменную среды с именем
	    <varname>DJANGO_SETTINGS_MODULE</varname>, которая должна
	    содержать путь до вашего файла
	    <filename>settings.py</filename>. Например,
	    <varname>DJANGO_SETTINGS_MODULE</varname> может быть
	    установлено в <token>mysite.settings</token>,
	    подразумевая, что каталог <filename>mysite</filename>
	    находится в пути Python.
	  </para>

	  <para>
	    При запуске <command>python manage.py shell</command>
	    настройка <varname>DJANGO_SETTINGS_MODULE</varname>
	    производится автоматически. Мы рекомендуем использовать
	    данный метод для работы с приведёнными ниже примерами.
	  </para>

	  <para>
	    После того, как вы лучше изучите Django, вероятно вы
	    перестанете использовать данный способ и будете
	    устанавливать <varname>DJANGO_SETTINGS_MODULE</varname>
	    вручную в вашем <filename>.bash_profile</filename> или в
	    другом конфигурационном файле вашей среды.
	  </para>
	</note>
      </para>

      <para>
	Рассмотрим основы шаблонной системы:
	<screen>
	  <![CDATA[
>>> from django.template import Template
>>> t = Template('My name is {{ name }}.')
>>> print t
	  ]]>
	</screen>
      </para>

      <para>
	Если вы попробовали запустить данный код в интерпретаторе, то
	вы увидели нечто подобное:
	<screen>
	  <![CDATA[
<django.template.Template object at 0xb7d5f24c>
	  ]]>
	</screen>
      </para>

      <para>
	Шестнадцатеричный адрес объекта &mdash;
	<token>0xb7d5f24c</token> будет всякий раз разным, не
	обращайте на это внимание. Это внутренняя информация Python,
	так называемый <quote>идентификатор</quote> созданного объекта
	<classname>Template</classname>.
      </para>

      <para>
	При создании объекта <classname>Template</classname> шаблонная
	система компилирует строку с кодом шаблона во внутренний
	оптимизированный формат, готовый для обработки. Но если ваш
	шаблонный код содержит синтаксические ошибки, вызов
	<function>Template()</function> приведёт к исключению
	<classname>TemplateSyntaxError</classname>:
	<screen>
	  <![CDATA[
>>> from django.template import Template
>>> t = Template('{% notatag %}')
Traceback (most recent call last):
  File "<stdin>", line 1, in ?
  ...
django.template.TemplateSyntaxError: Invalid block tag: 'notatag'
	  ]]>
	</screen>
      </para>

      <para>
	Термин <quote>block tag<footnote><para>Блочный
	тег</para></footnote></quote> в данном случае относится к
	<token>{% notatag %}</token>. <quote>Блочный тег</quote> и
	<quote>шаблонный тег</quote> являются синонимами.
      </para>

      <para>
	Система вызывает исключение
	<classname>TemplateSyntaxError</classname> в любом из
	нижеприведённых случаев:

	<itemizedlist>
	  <listitem>
	    <para>
	      Неверные теги;
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      Неверные аргументы у верных тегов;
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      Неверные фильтры;
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      Неверные аргументы у верных фильтров;
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      Неверный синтаксис шаблона;
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      Незакрытые теги (для тегов, которые требуют наличия
	      завершающих тегов).
	    </para>
	  </listitem>
	</itemizedlist>
      </para>

    </section>

    <section id="&BASEID;.usage.render">
      
      <title id="&BASEID;.usage.render.title">
	Обработка шаблона
      </title>

      <para>
	После того, как объект <classname>Template</classname> создан,
	вы можете передавать ему данные через
	<emphasis>контекст</emphasis>. Контекстом называют набор
	значений, ассоциированных с шаблоннымм переменными. Шаблон
	использует контекст для замены шаблонных переменных на
	значения и для вычисления тегов.
      </para>

      <para>
	Контекст в Django представлен классом
	<classname>Context</classname>, который определён в модуле
	<token>django.template</token>. Конструктор этого класса
	принимает один необязательный аргумент &mdash; словарь,
	содержащий имена переменных и ассоциированные им
	значения. Вызовите метод <function>render()</function> объекта
	<classname>Template</classname> для заполнения шаблона
	контекстными значениями:
	<screen>
	  <![CDATA[
>>> from django.template import Context, Template
>>> t = Template('My name is {{ name }}.')
>>> c = Context({'name': 'Stephane'})
>>> t.render(c)
u'My name is Stephane.'
	  ]]>
	</screen>
      </para>

      <para>
	Единственное, о чём следует упомянуть &mdash; то, что значение
	<token>t.render(c)</token> является объектом
	<classname>Unicode</classname>, а не обычной строкой
	Python. Вы можете выразить это, добавив <token>u</token> перед
	строкой. Django везде использует объекты
	<classname>Unicode</classname> вместо обычных строк. Если вы
	не понимаете последствия этого подхода, не
	беспокойтесь. Просто запомните, что поддержка Unicode
	позволяет упростить для вашего приложения поддержку
	национальных языков.
      </para>

      <para>
	<note>
	  <title>
	    Словари и контексты
	  </title>

	  <para>
	    Словарь в языке Python является отображением между
	    известным набором ключей и их
	    значений. <classname>Context</classname> подобен словарю,
	    но он также предоставляет дополнительный функционал,
	    который описан в главе 9 FIXME.
	  </para>
	</note>
      </para>

      <para>
	Имена переменных должны начинаться с буквы (<token>A-Z</token>
	или <token>a-z</token>) и могут состоять из множества букв,
	цифр, символов подчёркивания и точек. (Точки являются особым
	случаем, мы скоро рассмотрим их.) Имена переменных
	регистрозависимы.
      </para>

      <para>
	Ниже показан пример компиляции и обработки шаблона, который
	похож на тот, что мы рассмотрели в начале главы:
	<screen>
	  <![CDATA[
>>> from django.template import Template, Context
>>> raw_template = """<p>Dear {{ person_name }},</p>
...
... <p>Thanks for placing an order from {{ company }}. It's scheduled to
... ship on {{ ship_date|date:"F j, Y" }}.</p>
...
... {% if ordered_warranty %}
... <p>Your warranty information will be included in the packaging.</p>
... {% else %}
... <p>You didn't order a warranty, so you're on your own when
... the products inevitably stop working.</p>
... {% endif %}
...
... <p>Sincerely,<br />{{ company }}</p>"""
>>> t = Template(raw_template)
>>> import datetime
>>> c = Context({'person_name': 'John Smith',
...     'company': 'Outdoor Equipment',
...     'ship_date': datetime.date(2009, 4, 2),
...     'ordered_warranty': False})
>>> t.render(c)
u"<p>Dear John Smith,</p>\n\n<p>Thanks for placing an order from Outdoor
Equipment. It's scheduled to\nship on April 2, 2009.</p>\n\n\n<p>You
didn't order a warranty, so you're on your own when\nthe products
inevitably stop working.</p>\n\n\n<p>Sincerely,<br />Outdoor Equipment
</p>"
	  ]]>
	</screen>
      </para>

      <para>
	Рассмотрим каждую строку кода:

	<itemizedlist>
	  <listitem>
	    <para>
	      Сначала мы импортируем классы
	      <classname>Template</classname> и
	      <classname>Context</classname>, которые определены в
	      модуле <token>django.template</token>.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      Мы сохраняем оригинальный текст нашего шаблона в
	      переменной <varname>raw_template</varname>. Следует
	      отметить, что мы используем тройные кавычки для
	      выделения строки, так как мы имеем дело с многострочной
	      строкой. Дело в том, что строки, заключённый в одинарные
	      кавычки, не могут быть многострочными.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      Затем мы создаём шаблонный объект, <token>t</token>,
	      передавая <varname>raw_template</varname> в конструктор
	      класса <classname>Template</classname>.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      Мы импортируем модуль <token>datetime</token> из
	      стандартной библиотеки Python, так как нам он
	      понадобится в далее.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      Затем мы создаём контекстный объект,
	      <token>c</token>. Конструктор класса
	      <classname>Context</classname> принимает словарь,
	      который содержит ассоциированные именам значения. В
	      нашем случае, мы определили, что
	      <varname>person_name</varname> имеет значение
	      <token>'John Smith'</token>, <varname>company</varname>
	      &mdash; <token>'Outdoor Equipment'</token> и так далее.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      В конце мы вызвали метод <function>render()</function>
	      для нашего шаблонного объекта, передав ему контекст. Нам
	      был возвращён обработанный шаблон, т.е., метод заменил
	      переменные их действительными значениями и вычислил все
	      шаблонные теги.
	    </para>

	    <para>
	      Следует отметить, что параграф <quote>You didn’t order a
	      warranty</quote> был отображён, потому что переменная
	      <varname>ordered_warranty</varname> вычислилась в
	      <token>False</token>. Обратите внимание на дату,
	      <token>April 2, 2009</token>, которая отобразилась в
	      соответствии с заданным форматом &mdash; <token>'F j,
	      Y'</token>. (Мы расскажем о аргументак фильтра
	      <function>date</function> немного позже.)
	    </para>

	    <para>
	      Если вы новичок в Python, вы можете заинтересоваться
	      почему результат содержит символы перевода строки
	      (<token>\n</token>), вместо того, чтобы отображать
	      реальные переводы строк. Так происходит из-за тонкостей
	      работы интерактивного интерпретатора Python: вызов
	      <token>t.render(c)</token> возвращает строку и, по
	      умолчанию, интерактивный интерпретатор отображает
	      <emphasis>представление</emphasis> строки, вместо
	      печатного варианта строки. Если вы желаете получить
	      печатную строку, используйте оператор
	      <function>print</function>: <token>print
	      t.render(c)</token>.
	    </para>
	  </listitem>
	</itemizedlist>
      </para>

      <para>
	Таковы основы использования шаблонной системы Django: просто
	напишите шаблонную строку, создайте объект
	<classname>Template</classname>, создайте
	<classname>Context</classname> и вызовите метод
	<function>render()</function>.
      </para>
    
    </section>

    <section id="&BASEID;.usage.many-contexts">
      
      <title id="&BASEID;.usage.many-contexts.title">
	Множество контекстов и единственный шаблон
      </title>

      <para>
	После того, как вы создали объект
	<classname>Template</classname>, вы можете с его помощью
	обработать множество контекстов. Например:
	<screen>
	  <![CDATA[
# Так делать не стоит
for name in ('John', 'Julie', 'Pat'):
    t = Template('Hello, {{ name }}')
    print t.render(Context({'name': name}))

# Правильный подход
t = Template('Hello, {{ name }}')
for name in ('John', 'Julie', 'Pat'):
    print t.render(Context({'name': name}))
	  ]]>
	</screen>
      </para>

      <para>
	Django обрабатывает шаблон достаточно быстро. Внутри всё это
	сводится к вызову единственного регулярного выражения. Это
	сильно контрастирует по отношению к шаблонным движкам,
	построенных на XML, которые вносят затраты на разбор XML и по
	скорости проигрывают шаблонной системе Django.
      </para>

    </section>

    <section id="&BASEID;.usage.lookup">
      
      <title id="&BASEID;.usage.lookup.title">
	Поиск контекстной переменной
      </title>

      <para>
	В вышеприведённых примерах мы передавали простые значения в
	контекст, в основном это были строки, иногда даты. Тем не
	менее, шаблонная система легко обрабатывает более сложные
	структуры данных, такие как списки, словари и различные
	объекты.
      </para>

      <para>
	Ключом к такой всеядности является символ <token>.</token>
	(точка). Используйте точку для получения доступа к ключам
	словаря, атрибутам, методам и индексам объекта.
      </para>

      <para>
	Это хорошо проиллюстрировано в нескольких примерах. Например,
	предположим, что вы передали словарь в шаблон. Для получения
	доступа к значениям этого словаря по ключу следует
	использовать точку:
	<screen>
	  <![CDATA[
>>> from django.template import Template, Context
>>> person = {'name': 'Sally', 'age': '43'}
>>> t = Template('{{ person.name }} is {{ person.age }} years old.')
>>> c = Context({'person': person})
>>> t.render(c)
u'Sally is 43 years old.'
	  ]]>
	</screen>
      </para>

      <para>
	Аналогично, точка также позволяет получить доступ к атрибутам
	объекта. Например, объект <classname>datetime.date</classname>
	содержит атрибуты <token>year</token>, <token>month</token> и
	<token>day</token>, и вы можете получить к ним доступ:
	<screen>
	  <![CDATA[
>>> from django.template import Template, Context
>>> import datetime
>>> d = datetime.date(1993, 5, 2)
>>> d.year
1993
>>> d.month
5
>>> d.day
2
>>> t = Template('The month is {{ date.month }} and the year is {{ date.year }}.')
>>> c = Context({'date': d})
>>> t.render(c)
u'The month is 5 and the year is 1993.'
	  ]]>
	</screen>
      </para>

      <para>
	Следующий пример использует класс, демонстрируя методику
	получения доступа к атрибутам объекта:
	<screen>
	  <![CDATA[
>>> from django.template import Template, Context
>>> class Person(object):
...     def __init__(self, first_name, last_name):
...         self.first_name, self.last_name = first_name, last_name
>>> t = Template('Hello, {{ person.first_name }} {{ person.last_name }}.')
>>> c = Context({'person': Person('John', 'Smith')})
>>> t.render(c)
u'Hello, John Smith.'
	  ]]>
	</screen>
      </para>

    
      <section id="&BASEID;.usage.lookup.method-call">
      
	<title id="&BASEID;.usage.lookup.method-call.title">
	  Вызов методов
	</title>
	
      </section>

      <section id="&BASEID;.usage.lookup.invalid-vars">
      
	<title id="&BASEID;.usage.lookup.invalid-vars.title">
	  Обработка неправильных переменных
	</title>
	
      </section>

    </section>

    <section id="&BASEID;.usage.playing">
      
      <title id="&BASEID;.usage.playing.title">
	Играем с контекстными объектами
      </title>
    
    </section>

  </section>

</chapter>