<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
"http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd"
[
<!ENTITY BASEID "djangobook.chap05">
]>

<chapter lang="ru" id="&BASEID;">

  <title id="&BASEID;.title">
    Модели
  </title>

  <para>
    Перевод &copy; Попов Руслан &lt;ruslan.popov &bull; gmail&gt;
  </para>

  <para>
    В главе <quote><xref linkend="djangobook.chap03"
    endterm="djangobook.chap03.title"/></quote> мы описали основы
    создания динамических сайтов с помощью Django: настройка
    представлений и схемы URL для них. Как было рассказано,
    представление отвечает за <emphasis>некоторую произвольную
    логику</emphasis> и возвращает отклик. В одном из примеров логикой
    являлось вычисление текущей даты и времени.
  </para>

  <para>
    В современных веб-приложениях произвольная логика часто вовлечена
    в работу с базой данных. Обычно, сайт такого типа подключается к
    серверу базы данных, получает от него некоторые данные и, выполнив
    форматирование, отображает эти данные на странице. Так же сайт
    может предоставлять посетителям сайта возможность заполнять базу
    данных своими данными.
  </para>

  <para>
    Множество сложных сайтов предоставляют некую комбинацию этих двух
    вариантов. Например, <ulink url="http://www.amazon.com/"/>
    является отличным примером такого сайта. Каждая страница продукта,
    по существу, является запросом в базу данных продуктов Amazon,
    отформатированном в виде HTML. А когда вы отсылаете свой
    комментарий, он помещается в базу данных отзывов.
  </para>

  <para>
    Django отлично подходит для создания сайтов, ориентированных на
    использование совместно с базой данных, т.к., она поставляется с
    простыми, но мощными механизмами выполнения запросов к базе данных
    с помощью Python. Эта глава описывает этот механизм: слой Django
    для работы с базой данных.
  </para>

  <para>
    Следует отметить, что необязательно знать основы теории баз данных
    и SQL для использования этого слоя Django, но это крайне
    рекомендуется. Введение в эти понятия находится вне сферы этой
    книги. Вероятно, вы сможете понять концепции, учитывая контекст
    изложения.
  </para>

  <section id="&BASEID;.dumbway">

    <title id="&BASEID;.dumbway.title">
      <quote>Тупой</quote> способ выполнения запросов в представлениях
    </title>

    <para>
      Подобно определённому в главе <quote><xref
      linkend="djangobook.chap03"
      endterm="djangobook.chap03.title"/></quote>
      <quote>тупому</quote> способу генерации вывода с помощью
      представлений (вбивание руками текста прямо в код
      представления), существует <quote>тупой</quote> способ
      получения в представлениях информации из базы данных. Это
      просто: используйте <emphasis>любую</emphasis> существующую
      библиотеку языка Python для выполнения SQL запроса и
      обрабатывайте его результаты.
    </para>

    <para>
      В этом примере представления мы используем библиотеку
      <token>MySQLdb</token> (доступную по адресу <ulink
      url="http://www.djangoproject.com/r/python-mysql/"/>) для
      подключения к базе данных MySQL, получения нескольких записей и
      помещения их в шаблон для отображения на странице сайта:
      <screen>
	    <![CDATA[
from django.shortcuts import render_to_response
import MySQLdb

def book_list(request):
    db = MySQLdb.connect(user='me', db='mydb', passwd='secret', host='localhost')
    cursor = db.cursor()
    cursor.execute('SELECT name FROM books ORDER BY name')
    names = [row[0] for row in cursor.fetchall()]
    db.close()
    return render_to_response('book_list.html', {'names': names})
        ]]>
      </screen>
    </para>

    <para>
      Такой подход работает, но вы должны немедленно столкнуться с
      некоторыми проблемами:

      <itemizedlist>
        <listitem>
          <para>
            Мы жёстко определяем параметры соединения с базой
            данных. В идеале эти параметры должны храниться в
            конфигурации проекта Django.
          </para>
        </listitem>

        <listitem>
          <para>
            Мы должны писать нудный код: создать соединение, создать
            курсор, выполнить оператор и закрыть соединение. В идеале
            всё, что мы должны сделать &mdash; указать необходимый нам
            результат.
          </para>
        </listitem>

        <listitem>
          <para>
            Это привязывает нас к MySQL. Если, с течением времени, мы
            решим перейти с MySQL на PostgreSQL, нам потребуется
            использовать другой драйвер для базы данных (т.е.,
            <token>psycopg</token> вместо <token>MySQLdb</token>),
            изменить параметры соединения и, в зависимости от природы
            SQL операторов, возможно, переписать SQL запросы. В
            идеале, мы должны рассматривать сервер базы данных
            абстрактно, т.е., для смены сервера мы должны внести
            изменения в одно только место проекта. (Эта проблема имеет
            особое значение в случае, если вы работаете над
            приложением Django с открытым кодом, которое вы желаете
            распространить среди максимально возможного количества
            пользователей.)
          </para>
        </listitem>
      </itemizedlist>
    </para>

    <para>
      Как вы можете ожидать, слой Django для работы с базами данных
      помогает решать такие проблемы. Далее представлен пример как
      надо изменить предыдущее представление для использования Django
      API для работы с базами данных:
      <screen>
        <![CDATA[
from django.shortcuts import render_to_response
from mysite.books.models import Book

def book_list(request):
    books = Book.objects.order_by('name')
    return render_to_response('book_list.html', {'books': books})
        ]]>
      </screen>
    </para>

    <para>
      Мы разберём этот код немного позже в этой главе.
    </para>

  </section>

  <section id="&BASEID;.mtvdevpat">

    <title id="&BASEID;.mtvdevpat.title">
      Методика MTV (или MVC)
    </title>

    <para>
      Прежде чем мы погрузимся в изучение кода, давайте рассмотрим
      общий дизайн БД ориентированных веб-приложений Django.
    </para>

    <para>
      Как мы рассказывали в предыдущих главах, Django поощряет
      свободное связывание и строгое разделение частей
      приложения. Если следовать этой философии, то легко вносить
      изменения в одну конкретную часть приложения без ущерба для
      остальных частей. В функциях представления, например, мы
      обсуждали важность отделения бизнес-логики от логики отображения
      с помощью шаблонной системы. Используя слой для работы с базой
      данных, мы применяем эту же философию для логики доступа к
      данным.
    </para>

    <para>
      Эти три вещи вместе &mdash; логика доступа к данным,
      бизнес-логика и логика отображения &mdash; составляют концепцию,
      которую называют шаблоном
      <emphasis>Модель-Представление-Управление</emphasis>
      (<emphasis>Model-View-Controller</emphasis>, MVC) архитектуры
      программного обеспечения. В этой концепции термин
      <quote>Модель</quote> относится к логике доступа к данным;
      термин <quote>Представление</quote> относится к той части
      системы, которая определяет, что показать и как; а термин
      <quote>Управление</quote> относится к той части системы, которая
      определяет какое представление надо использовать, в зависимости
      от пользовательского ввода, по необходимости получая доступ к
      модели.
    </para>

    <para>
      <note>
        <title>
          Почему используется сокращение?
        </title>

        <para>
          Целью чёткого определения сокращений, подобных MVC, является
          упорядочивание взаимодействия между разработчиками. Вместо
          того, чтобы сказать вашим сотрудникам: <quote>Давайте
          использовать абстрактный доступ к данным, затем создадим
          слой управления отображением данных и тогда создадим слой
          между ними, который всем этим управляет</quote> можно
          воспользоваться общим термином: <quote>Давайте здесь
          использовать подход MVC</quote>.
        </para>
      </note>
    </para>

    <para>
      Django следует модели MVC достаточно близко, т.е., может быть
      назван MVC совместимой средой разработки. Вот примерно как M, V
      и C используются в Django:

      <itemizedlist>
        <listitem>
          <para>
            <emphasis>M</emphasis>, доступ к данным, обрабатывается
            слоем работы с базой данных, который описан в этой главе.
          </para>
        </listitem>

        <listitem>
          <para>
            <emphasis>V</emphasis>, эта часть, которая определяет
            какие данные получать и как их отображать, обрабатывается
            представлениями и шаблонами.
          </para>
        </listitem>

        <listitem>
          <para>
            <emphasis>C</emphasis>, эта часть, которая выбирает
            представление в зависимости от пользовательского ввода,
            обрабатывается самой средой разработки, следуя созданной
            вами схемой URL, и вызывает соответствующую функцию Python
            для указанного URL.
          </para>
        </listitem>
      </itemizedlist>
    </para>

    <para>
      Так как <quote>C</quote> обрабатывается средой разработки и всё
      интересное в Django происходит в моделях, шаблонах и
      представлениях, на Django ссылаются как на
      <emphasis>MTV-ориентированную среду разработки</emphasis>. В
      MTV-подходе к разработке:

      <itemizedlist>
        <listitem>
          <para>
            <emphasis>M</emphasis> определено для
            <quote>Модели</quote> (Model), слоя доступа к данным. Этот
            слой знает всё о данных: как получить к ним доступ, как
            проверить их, как с ними работать и как данные связаны
            между собой.
          </para>
        </listitem>

        <listitem>
          <para>
            <emphasis>T</emphasis> определено для
            <quote>Шаблона</quote> (Template), слоя представления
            данных. Этот слой принимает решения относительно
            представления данных: как и что должно отображаться на
            странице или в другом типе документа.
          </para>
        </listitem>

        <listitem>
          <para>
            <emphasis>V</emphasis> определено для
            <quote>Представления</quote> (View), слоя
            бизнес-логики. Этот слой содержит логику, как получать
            доступ к моделям и применять соответствующий шаблон. Вы
            можете рассматривать его как мост между моделями и
            шаблонами.
          </para>
        </listitem>
      </itemizedlist>
    </para>

    <para>
      Если вам приходилось работать с другими MVC ориентированными
      средами разработки, такими как Ruby on Rails, вы можете
      рассматривать представления в Django как
      <quote>контролёры</quote>, а шаблоны Django &mdash; как
      <quote>представления</quote>. Это печальная путаница возникла в
      результате различных толкований MVC. В интерпретации Django
      <quote>представление</quote> описывает данные, которые будут
      представлены пользователю. Неважно <emphasis>как</emphasis> эти
      данные будут выглядеть, важно <emphasis>какие</emphasis>
      данные. Напротив, в Ruby on Rails и подобных ему средах
      предполагается, что в работу контролёра включено принятие
      решения, какие данные будут представлены пользователю, в то
      время как представление точно определяет
      <emphasis>как</emphasis> эти данные будут выглядеть, а не
      <emphasis>какие</emphasis> данные будут представлены.
    </para>

    <para>
      Ни одна интерпретация не имеет преимуществ над другой. Важно
      понимать основную концепцию.
    </para>

  </section>

  <section id="&BASEID;.dbconfig">

    <title id="&BASEID;.dbconfig.title">
      Настройка базы данных
    </title>

    <para>
      Учитывая вышеописанную философию, начнём исследовать слой Django
      для работы с базой данных. Первое, что нам понадобится &mdash;
      необходимо позаботиться о начальной настройке. Необходимо
      указать Django какой сервер базы данных использовать и как к
      нему подключаться.
    </para>

    <para>
      <note>
        <title>
          Используем кодировку UTF-8, пример для MySQL
          (прим. переводчика)
        </title>

        <para>
          Откроем на редактирование файл
          <filename>/etc/mysql/my.cnf</filename>.
        </para>

        <para>
          В конец секции <token>[client]</token> добавим строчку:
          <screen>
default-character-set=utf8
          </screen>
        </para>

        <para>
          В конец секции <token>[mysqld]</token> добавим строчки:
          <screen>
default-character-set=utf8
collation_server=utf8_unicode_ci
          </screen>
        </para>

        <para>
          Теперь следует перезапустить сервер базы данных и можно
          приступать к созданию самой базы.
        </para>
      </note>
    </para>

    <para>
      <note>
        <title>
          Проверка настроек кодировки (прим. переводчика)
        </title>

        <para>
          В результате вышеописанных действий вы должны получить:
          <screen>
            <![CDATA[
mysql> show variables like 'coll%';
+----------------------+-----------------+
| Variable_name        | Value           |
+----------------------+-----------------+
| collation_connection | utf8_general_ci |
| collation_database   | utf8_unicode_ci |
| collation_server     | utf8_unicode_ci |
+----------------------+-----------------+
3 rows in set (0.00 sec)

mysql> show variables like 'char%';
+--------------------------+----------------------------+
| Variable_name            | Value                      |
+--------------------------+----------------------------+
| character_set_client     | utf8                       |
| character_set_connection | utf8                       |
| character_set_database   | utf8                       |
| character_set_filesystem | binary                     |
| character_set_results    | utf8                       |
| character_set_server     | utf8                       |
| character_set_system     | utf8                       |
| character_sets_dir       | /usr/share/mysql/charsets/ |
+--------------------------+----------------------------+
8 rows in set (0.00 sec)
            ]]>
          </screen>
        </para>
      </note>
    </para>

    <para>
      Мы предполагаем, что вы уже установили сервер базы данных,
      запустили его и создали базу данных внутри. Пример для MySQL:
      <screen>
        <![CDATA[
CREATE USER user@localhost IDENTIFIED BY "topsecret";
CREATE DATABASE mysite;
GRANT ALL ON mysite.* TO user@localhost;
        ]]>
      </screen>
    </para>

    <para>
      Использование SQLite является особым случаем: не требуется
      создавать базу данных, так как SQLite использует файлы на
      файловой системе для хранения своих данных.
    </para>

    <para>
      Подобно параметру <varname>TEMPLATE_DIRS</varname> из предыдущей
      главы, по умолчанию параметры соединения с базой данных
      определяются в файле конфигурации проекта,
      <filename>settings.py</filename>. Отредактируйте этот файл и
      посмотрите на настройки базы данных:
      <screen>
DATABASE_ENGINE = ''
DATABASE_NAME = ''
DATABASE_USER = ''
DATABASE_PASSWORD = ''
DATABASE_HOST = ''
DATABASE_PORT = ''
      </screen>
    </para>

    <para>
      Опишем каждый параметр:
      <itemizedlist>
        <listitem>
          <para>
            Параметр <varname>DATABASE_ENGINE</varname> указывает тип
            базы данных. Может быть одним из показанных в таблице
            <quote><xref linkend="&BASEID;.tbl1"
            endterm="&BASEID;.tbl1.title"/></quote>.
          </para>

          <para>
            <table id="&BASEID;.tbl1" frame="all" pgwide="1">

              <title id="&BASEID;.tbl1.title">
                Настройки драйвера базы данных
              </title>

              <tgroup cols="3" align="left" colsep="1" rowsep="1">
                <colspec colname="c1" colwidth="4cm"/>
                <colspec colname="c2" colwidth="4cm"/>
                <colspec colname="c3" colwidth="6cm"/>

                <thead>
                  <row>
                    <entry>Значение</entry>
                    <entry>База данных</entry>
                    <entry>Драйвер</entry>
                  </row>
                </thead>

                <tbody>
                  <row>
                    <entry><token>postgresql</token></entry>
                    <entry>PostgreSQL</entry>
                    <entry>
                      <token>psycopg</token> версия 1.х, <ulink
                      url="http://www.djangoproject.com/r/python-pgsql/1/"/>
                    </entry>
                  </row>

                  <row>
                    <entry><token>postgresql_psycopg2</token></entry>
                    <entry>PostgreSQL</entry>
                    <entry>
                      <token>psycopg</token> версия 2.х, <ulink
                      url="http://www.djangoproject.com/r/python-pgsql/"/>
                    </entry>
                  </row>

                  <row>
                    <entry><token>mysql</token></entry>
                    <entry>MySQL</entry>
                    <entry>
                      <token>MySQLdb</token>, <ulink
                      url="http://www.djangoproject.com/r/python-mysql/"/>
                    </entry>
                  </row>

                  <row>
                    <entry><token>sqlite3</token></entry>
                    <entry>SQLite</entry>
                    <entry>
                      При использовании Python 2.5+ драйвер не нужен. В
                      противном случае <ulink
                      url="http://www.djangoproject.com/r/python-sqlite/"/>
                    </entry>
                  </row>

                  <row>
                    <entry><token>oracle</token></entry>
                    <entry>Oracle</entry>
                    <entry>
                      <token>cx_Oracle</token>, <ulink
                      url="http://www.djangoproject.com/r/python-oracle/"/>
                    </entry>
                  </row>
                </tbody>
              </tgroup>
            </table>
          </para>

          <para>
            Следует отметить, что для работы с базой данных
            потребуется скачать и установить соответствующий
            драйвер. Каждый описанный драйвер доступен бесплатно,
            просто проследуйте по ссылке, которая приведена в колонке
            <quote>Драйвер</quote>. Если вы используете Linux,
            вероятно ваша система управления пакетами может предложить
            соответствующие пакеты. (Например, ищите пакеты с именами
            <token>python-postgresql</token> или
            <token>python-psycopg</token>.)
          </para>

          <para>
            Пример:
            <screen>
              <![CDATA[
DATABASE_ENGINE = 'postgresql_psycopg2'
              ]]>
            </screen>
          </para>
        </listitem>

        <listitem>
          <para>
            Параметр <varname>DATABASE_NAME</varname> указывает Django
            имя вашей базы данных. Например:
            <screen>
              <![CDATA[
DATABASE_NAME = 'mydb'
              ]]>
            </screen>
          </para>

          <para>
            Если вы использует SQLite, укажите полный путь к файлу
            базы данных на файловой системе. Например:
            <screen>
              <![CDATA[
DATABASE_NAME = '/home/django/mydata.db'
              ]]>
            </screen>
          </para>

          <para>
            Мы используем каталог <filename>/home/django</filename> в
            этом примере, но вам следует выбирать каталог, который
            более подходит для вашей задачи.
          </para>
        </listitem>

        <listitem>
          <para>
            Параметр <varname>DATABASE_USER</varname> указывает Django
            какое имя надо использовать при соединении с базой
            данных. Если вы используете SQLite, оставьте этот параметр
            пустым.
          </para>
        </listitem>

        <listitem>
          <para>
            Параметр <varname>DATABASE_PASSWORD</varname> указывает
            Django какой пароль надо использовать при соединении с
            базой данных. Если вы используете SQLite, оставьте этот
            параметр пустым.
          </para>
        </listitem>

        <listitem>
          <para>
            Параметр <varname>DATABASE_HOST</varname> указывает Django
            какое имя сервера надо использовать при соединении с базой
            данных. Если база данных находится на том же компьютере
            (т.е., <token>localhost</token>), оставьте параметр
            пустым. Если вы используете SQLite, оставьте этот параметр
            пустым.
          </para>

          <para>
            MySQL является особым случаем. Если значение этого
            параметра начинается с прямого слэша (<token>/</token>) и
            вы используете MySQL, то соединение будет произведено
            через UNIX сокет, например:
            <screen>
DATABASE_HOST = '/var/run/mysql'
            </screen>
          </para>
        </listitem>

        <listitem>
          <para>
            (Прим. переводчика) Скопировано из прошлой версии книги,
            так как не потеряло актуальность.
          </para>

          <para>
            Параметр <varname>DATABASE_PORT</varname> указывает Django
            какой порт надо использовать при соединении с базой
            данных. Если вы используете SQLite, оставьте этот параметр
            пустым. В противном случае, соответствующий драйвер базы
            данных будет использовать стандартный (для конкретной базы
            данных) порт. В большинстве случаев используется
            стандартный порт, можете оставить этот параметр пустым.
          </para>
        </listitem>
      </itemizedlist>
    </para>

    <para>
      После заполнения этих параметров, проверьте свою
      конфигурацию. Чтобы выполнить это, запустите <command>python
      manage.py shell</command>, как делали это в прошлой главе, в
      каталоге проекта <filename>mysite</filename>. (Как мы
      рассказывали в прошлой главе команда <command>manage.py
      shell</command> является способом запуска интерпретатора Python
      с корректной конфигурацией Django проекта. Это необходимо в
      нашем случае, так как Django должна знать какой файл
      конфигурации следует использовать для получения учётных данных
      для работы с базой данных.)
    </para>

    <para>
      В интерпретаторе выполните нижеприведённые команды для проверки
      ваших настроек для соединения с базой данных:
      <screen>
        <![CDATA[
>>> from django.db import connection
>>> cursor = connection.cursor()
        ]]>
      </screen>
    </para>

    <para>
      Если ничего не произойдёт, значит всё сделано правильно. В
      противном случае, изучите сообщение об ошибке и выясните, что
      произошло. Таблица <quote><xref linkend="&BASEID;.tbl2"
      endterm="&BASEID;.tbl2.title"/></quote> содержит некоторые
      стандартные ошибки.
    </para>

    <para>
      <table id="&BASEID;.tbl2" frame="all" pgwide="1">

        <title id="&BASEID;.tbl2.title">
          Сообщения об ошибках в конфигурации доступа к базе данных
        </title>

        <tgroup cols="2" align="left" colsep="1" rowsep="1">

          <colspec colname="c1" colwidth="7cm"/>
          <colspec colname="c2" colwidth="7cm"/>

          <thead>
            <row rowsep="1">
              <entry>Сообщение об ошибке</entry>
              <entry>Решение</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>
                Вы не определили значение параметра
                <varname>DATABASE_ENGINE</varname>. (You haven't set
                the DATABASE_ENGINE setting yet.)
              </entry>
              <entry>
                Установите значение параметра
                <varname>DATABASE_ENGINE</varname>. Не оставляйте его
                пустым.
              </entry>
            </row>

            <row>
              <entry>
                Не определена переменная среды
                <varname>DJANGO_SETTINGS_MODULE</varname>. (Environment
                variable DJANGO_SETTINGS_MODULE is undefined.)
              </entry>
              <entry>
                Запустите команду <command>python manage.py
                shell</command> вместо <command>python</command>.
              </entry>
            </row>

            <row>
              <entry>
                Ошибка при загрузке модуля _____. Нет модуля с именем
                _____. (Error loading _____ module: No module named
                _____.)
              </entry>
              <entry>
                Вы не установили соответствующий драйвер базы данных,
                т.е. <token>psycopg</token> или
                <token>MySQLdb</token>.
              </entry>
            </row>

            <row>
              <entry>
                _____ не является доступным драйвером базы
                данных. (_____ isn't an available database backend.
              </entry>
              <entry>
                Установите параметр
                <varname>DATABASE_ENGINE</varname>, указав
                используемую базу данных, как было описано
                ранее. Возможно вы опечатались?
              </entry>
            </row>

            <row>
              <entry>
                База данных _____ не существует. (database _____ does
                not exist.)
              </entry>
	      <entry>
            Измените параметр <varname>DATABASE_NAME</varname>, чтобы
            он указывал на существующую базу данных, или выполните
            соответствующую команду <command>CREATE DATABASE</command>
            для создания базы данных.
	      </entry>
            </row>

            <row>
              <entry>
                Роль _____ не существует. (role _____ does not exist.)
              </entry>
              <entry>
                Измените параметр <varname>DATABASE_USER</varname>,
                чтобы он указывал на существующего пользователя или
                создайте соответствующего пользователя в базе данных.
              </entry>
            </row>

            <row>
              <entry>
                Не могу подключиться к серверу. (could not connect to
                server.)
              </entry>
              <entry>
                Удостоверьтесь, что параметры
                <varname>DATABASE_HOST</varname> и
                <varname>DATABASE_PORT</varname> установлены
                правильно, а также, что сервер баз данных работает.
              </entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </para>

  </section>

  <section id="&BASEID;.firstapp">

    <title id="&BASEID;.firstapp.title">
      Ваше первое приложение
    </title>

    <para>
      После того, как вы проверили работоспособность соединения с
      базой данных, пришло время создать
      <emphasis>Django-приложение</emphasis> &mdash; код, включающий в
      себя модели и представления, который объединён в один пакет
      Python и представляет собой цельное Django-приложение.
    </para>

    <para>
      Удобно согласовать терминологию здесь, это поможет новичкам. В
      главе <quote><xref linkend="djangobook.chap02.startproject"
      endterm="djangobook.chap02.startproject.title"/></quote> мы
      создали проект, но в чём же разница между проектом и
      приложением? Разница в том, что первое является конфигурацией, а
      второе &mdash; кодом:
      <itemizedlist>
        <listitem>
          <para>
            Проект &mdash; это экземпляр определённого набора кода
            Django-приложений и конфигурация для этих приложений.
          </para>

          <para>
            С технической точки зрения существует одно требование к
            проекту &mdash; наличие файла конфигурации, который
            определяет способ соединения с базой данных, список
            установленных приложений, каталог с шаблонами и так далее.
          </para>
        </listitem>

        <listitem>
          <para>
            Приложение &mdash; это переносимый набор некой
            функциональности, обычно включает в себя модели и
            представления, которые хранятся вместе в едином пакете
            языка Python.
          </para>

          <para>
            Например, Django поставляется с рядом приложений, таких
            как система комментирования и автоматический интерфейс
            администратора. Важной особенностью этих приложений
            является то, что они переносимы и их можно использовать во
            множестве проектов.
          </para>
        </listitem>
      </itemizedlist>
    </para>

    <para>
      Существует очень мало жёстких правил для соответствия вашего
      кода этой схеме. Если вы создаёте простой сайт, вы можете
      использовать единственное приложение. Если вы создаёте сложный
      сайт с несколькими независимыми частями, такими как
      интернет-магазин и форум, возможно вы пожелаете разнести их в
      отдельные приложения, что позволит использовать их раздельно в
      других проектах.
    </para>

    <para>
      В действительности нет нужды создавать приложения вообще, как
      это видно из примера функций представления, которые мы создали
      ранее. Для тех случаев мы просто создали файл с именем
      <filename>views.py</filename>, который содержал код функций
      представления и создали схему URL для этих функций. Никакое
      <quote>приложение</quote> нам для этого не понадобилось.
    </para>

    <para>
      Тем не менее, существует одно требование относящееся к
      приложениям: если вы используете Django API для работы с базой
      данных, то вы обязаны создать приложение. Модели должны
      находиться внутри приложения. Следовательно, для того, чтобы
      начать описывать наши модели нам потребуется создать новое
      приложение.
    </para>

    <para>
      Внутри каталога проекта <filename>mysite</filename> выполните
      эту команду для создания приложения
      <application>books</application>:
      <screen>
        <![CDATA[
python manage.py startapp books
        ]]>
      </screen>
    </para>

    <para>
      Эта команда ничего не выводит, она просто создаёт каталог
      <filename>books</filename> в каталоге
      <filename>mysite</filename>. Давайте глянем на содержимое этого
      каталога:
      <screen>
        <![CDATA[
books/
    __init__.py
    models.py
    views.py
        ]]>
      </screen>
    </para>

    <para>
      Эти файлы будут содержать модели и представления для приложения.
    </para>

    <para>
      Посмотрите с помощью вашего текстового редактора файлы
      <filename>models.py</filename> и
      <filename>views.py</filename>. Оба файла сейчас пустые, исключая
      импорт в <filename>models.py</filename>. Это каркас для вашего
      приложения.
    </para>

  </section>

  <section id="&BASEID;.defmodels">

    <title id="&BASEID;.defmodels.title">
      Определение моделей в Python
    </title>

    <para>
      Как мы рассказывали в этой главе ранее, буква <quote>M</quote> в
      <token>MTV</token> определяет слово <quote>Модель</quote>
      (Model). Модель в Django &mdash; это описание данных, которые
      хранятся в базе данных, выполненное в виде кода на языке
      Python. Это форма ваших данных &mdash; эквивалент SQL операторов
      <command>CREATE TABLE</command> &mdash; только описана она на
      языке Python вместо SQL и включает в себя не только определение
      столбцов в базе данных. Django использует модель для фонового
      выполнения SQL и возвращает удобные структуры Python с данными,
      представляющими записи в таблицах вашей базы данных. Django
      также использует модели для представления высокоуровневых
      концепций, которые SQL вряд ли сможет обработать.
    </para>

    <para>
      Если вы уже работали с базами данных, вы могли подумать:
      <quote>Зачем дублировать определение моделей данных в Python
      <emphasis>и</emphasis> в SQL?</quote> Django действует таким
      образом по нескольким причинам:
      <itemizedlist>
        <listitem>
          <para>
            Самодиагностика занимает ресурсы и несовершенна. Для того,
            чтобы предоставить удобный API для доступа к данным,
            Django должна <emphasis>как-то</emphasis> получить
            информацию о содержимом базы данных и существует два
            способа сделать это. Первый: можно явно описать данные в
            Python. Второй: самодиагностика базы данных при работе
            приложения для определения моделей данных.
          </para>

          <para>
            Второй способ кажется более очевидным, так как метаданные
            в ваших таблицах хранятся в одном месте, но он приводит к
            нескольким проблемам. Первое, самодиагностика базы данных
            во время работы приложения потребляет ресурсы. Если среде
            разработки потребуется проверять структуру базы данных при
            выполнении каждого запроса, или хотя бы при каждом запуске
            веб-сервера, вы получите значительную нагрузку на ресурсы
            сервера. (В то время как некоторые считают такую нагрузку
            приемлемой, разработчики Django нацелены на максимально
            возможную скорость работы среды. И этот подход успешно
            решает задачу обгона конкурентов в тестах.) Во-вторых,
            некоторые базы данных, особенно старые версии MySQL, не
            сохраняют достаточно метаинформации для точной и полной
            самодиагностики.
          </para>
        </listitem>

        <listitem>
          <para>
            Разрабатывать с помощью Python прикольно и хранение всего
            в виде его кода сокращает число <quote>переключений
            контекста</quote>, которые приходится делать вашему
            мозгу. Если придерживаться единой среды
            разработки/менталитета, это повысит продуктивность
            работы. Необходимость писать SQL, затем код Python, а
            потом опять SQL, отрицательно сказывается на
            производительности разработчика.
          </para>
        </listitem>

        <listitem>
          <para>
            Когда модели данных хранятся в виде кода, а не в базе
            данных, это упрощает управление версиями этих моделей. Это
            поможет вам хранить историю всех изменений моделей.
          </para>
        </listitem>

        <listitem>
          <para>
            SQL позволяет лишь определённый уровень хранения
            метаинформации о формате данных. Большинство систем
            управления базами данных не предоставляют
            специализированных типов данных для представления адресов
            электронной почты или URL. Модели Django
            предоставляют. Преимущество высокоуровневых типов данных в
            улучшении продуктивности и в большем повторном
            использовании кода.
          </para>
        </listitem>

        <listitem>
          <para>
            SQL несовместим между разными платформами баз данных. При
            распространении веб-приложения, более практично передавать
            модуль на языке Python, который описывает формат ваших
            данных, вместо отдельных наборов операторов
            <command>CREATE TABLE</command> для MySQL, PostgreSQL и
            SQLite.
          </para>
        </listitem>
      </itemizedlist>
    </para>

    <para>
      Недостаток такого подхода, тем не менее, в том, что есть
      возможность для кода Python выйти из синхронизации с содержимым
      базы данных. При внесении изменений в модель, вам потребуется
      также изменить содержимое базы данных. Мы рассмотрим некоторые
      стратегии для решения этой проблемы далее в этой главе.
    </para>

    <para>
      Наконец, мы должны отметить, что Django включает в себя утилиту,
      которая может генерировать модели по метаинформации существующей
      базы данных. Это полезно для быстрого получения и начала работы
      с уже существующей информацией.
    </para>

  </section>

  <section id="&BASEID;.firstmodel">

    <title id="&BASEID;.firstmodel.title">
      Ваша первая модель
    </title>

    <para>
      В качестве постоянного примера в этой и следующих главах мы
      сосредоточимся на простом формате данных: книга, автор,
      издатель. Мы используем это в качестве нашего примера, потому
      что концептуальные взаимоотношения между этими понятиями широко
      известны и потому что этот общий формат данных используется в
      книгах по SQL. Вы также читаете книгу, которая создана авторами
      и напечатана издателем!
    </para>

    <para>
      Мы предположим следующие концепции, поля и взаимоотношения:
      <itemizedlist>
        <listitem>
          <para>
            Автор имеет звание (господин, госпожа, товарищ), имя,
            фамилию, адрес электронной почты и фотографию.
          </para>
        </listitem>

        <listitem>
          <para>
            Издатель имеет имя, адрес, город, область, страну и сайт.
          </para>
        </listitem>

        <listitem>
          <para>
            Книга имеет название и дату издания. Она также имеет
            одного или нескольких авторов (с авторами отношение
            многие-ко-многим) и одного издателя (отношение
            один-к-многим, как внешний ключ, к издателям).
          </para>
        </listitem>
      </itemizedlist>
    </para>

    <para>
      Первым шагом в использовании этой схемы базы данных будет её
      выражение в виде кода Python. В файл
      <filename>models.py</filename>, который был создан командой
      <command>startapp</command>, добавьте следующее:
      <screen>
        <![CDATA[
from django.db import models

class Publisher(models.Model):
    name = models.CharField(max_length=30)
    address = models.CharField(max_length=50)
    city = models.CharField(max_length=60)
    state_province = models.CharField(max_length=30)
    country = models.CharField(max_length=50)
    website = models.URLField()

class Author(models.Model):
    salutation = models.CharField(max_length=10)
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=40)
    email = models.EmailField()
    headshot = models.ImageField(upload_to='/tmp')

class Book(models.Model):
    title = models.CharField(max_length=100)
    authors = models.ManyToManyField(Author)
    publisher = models.ForeignKey(Publisher)
    publication_date = models.DateField()
        ]]>
      </screen>
    </para>

    <para>
      Быстро рассмотрим этот код, чтобы разобраться с
      основами. Первое, что следует отметить &mdash; каждая модель
      представлена в виде класса Python, который является потомком
      класса
      <token>django.db.models.</token><classname>Model</classname>. Родительский
      класс, <classname>Model</classname>, содержит всю необходимую
      функциональность для обеспечения работы объектов с базой
      данных. Таким образом наши модели несут полную ответственность
      за определение полей в кратком понятном виде. Верите или нет, но
      это весь код, который необходим для получения простого доступа к
      данным с помощью Django.
    </para>

    <para>
      Обычно каждая модель соответствует одной таблице в базе данных
      и, обычно, каждый атрибут модели соответствует столбцу в
      таблице. Имя атрибута модели соответствует имени столбца
      таблицы, а тип атрибута (т.е., <token>CharField</token>)
      соответствует типу столбца (т.е.,
      <token>varchar</token>). Например, модель
      <classname>Publisher</classname> эквивалентна следующей таблице
      (в синтаксисе для PostgreSQL):
      <screen>
        <![CDATA[
CREATE TABLE "books_publisher" (
    "id" serial NOT NULL PRIMARY KEY,
    "name" varchar(30) NOT NULL,
    "address" varchar(50) NOT NULL,
    "city" varchar(60) NOT NULL,
    "state_province" varchar(30) NOT NULL,
    "country" varchar(50) NOT NULL,
    "website" varchar(200) NOT NULL
);
        ]]>
      </screen>
    </para>

    <para>
      На самом деле Django может сгенерировать такой оператор
      <token>CREATE TABLE</token> автоматически, мы это скоро покажем.
    </para>

    <para>
      Исключением из правила <quote>один класс для одной
      таблицы</quote> является случай отношения
      <quote>многие-ко-многим</quote>. В нашем примере
      <token>Book</token> имеет такое поле &mdash;
      <token>authors</token>. Это означает, что книга имеет одного или
      более авторов, но таблица <token>Book</token> не получает такого
      столбца, Django создаёт дополнительную таблицу, которая
      применяется для обеспечения этой функциональности.
    </para>

    <para>
      Полный список типов полей и опций синтаксиса моделей приведены в
      Приложении <quote><xref linkend="djangobook.appendix_b"
      endterm="djangobook.appendix_b.title"/></quote>.
    </para>

    <para>
      Наконец, следует отметить, что мы нигде явно не определяли
      первичные ключи. Если специально не запрещать, то Django
      автоматически создаёт поле <token>id</token> для таблицы каждой
      модели. Необходимо, чтобы каждая модель Django имела первичный
      ключ, созданный по одному полю.
    </para>

  </section>

  <section id="&BASEID;.install">

    <title id="&BASEID;.install.title">
      Установка модели
    </title>

    <para>
      Мы написали код. Давайте создадим таблицы в нашей базе
      данных. Чтобы это сделать мы должны
      <emphasis>активировать</emphasis> модели в нашем проекте. Это
      делается с помощью добавления приложения <token>books</token> к
      списку установленных приложений в файле параметров.
    </para>

    <para>
      Откройте файл <filename>settings.py</filename> снова и
      посмотрите на параметр <varname>INSTALLED_APPS</varname>. Этот
      параметр указывает Django какие приложения активированы для
      текущего проекта. По умолчанию, параметр выглядит так:
      <screen>
INSTALLED_APPS = (
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.sites',
)
      </screen>
    </para>

    <para>
      Временно закомментируйте все четыре строки с помощью символа
      <token>#</token>. (Эти приложения были активированы для
      удобства, но мы самостоятельно активируем и обсудим их позже.)
      Не закрывая файл, измените параметры
      <varname>MIDDLEWARE_CLASSES</varname> и
      <varname>TEMPLATE_CONTEXT_PROCESSORS</varname>. Эти параметры
      зависели от приложений, которые мы закомментировали. Теперь
      добавьте <token>mysite.books</token> в список
      <varname>INSTALLED_APPS</varname>:
      <screen>
        <![CDATA[
MIDDLEWARE_CLASSES = (
#    'django.middleware.common.CommonMiddleware',
#    'django.contrib.sessions.middleware.SessionMiddleware',
#    'django.contrib.auth.middleware.AuthenticationMiddleware',
)

INSTALLED_APPS = (
    #'django.contrib.auth',
    #'django.contrib.contenttypes',
    #'django.contrib.sessions',
    #'django.contrib.sites',
    'mysite.books',
)
        ]]>
      </screen>
    </para>

    <para>
      (Раз мы здесь работаем с одно-элементным кортежем, не забудьте о
      завершающей запятой. Между прочим, авторы этой книги
      предпочитают ставить запятую после <emphasis>каждого</emphasis>
      элемента в кортеже, независимо от того, что кортеж имеет
      единственный элемент. Это помогает избежать проблемы забытых
      запятых и никак не влияет на производительность.)
    </para>

    <para>
      Элемент <token>mysite.books</token> ссылается на приложение
      <token>books</token>, над которым мы работаем. Каждое
      приложение, перечисленное в <varname>INSTALLED_APPS</varname>,
      представлено полным путём к нему &mdash; он, путь к пакетам,
      разделён точками.
    </para>

    <para>
      После того как приложение было активировано в файле конфигурации
      проекта, мы можем создать таблицы в нашей базе данных. Сначала,
      давайте проверим модели с помощью команды:
      <screen>
python manage.py validate
      </screen>
    </para>

    <para>
      Команда <token>validate</token> проверяет корректность
      синтаксиса и логики моделей. Если всё в порядке, вы увидите
      сообщение <quote>0 errors found</quote>. Если нет,
      удостоверьтесь, что вы корректно набрали код модели. Вывод
      ошибки должен дать вам полезную информацию об ошибке в коде.
    </para>

    <para>
      Каждый раз когда вам кажется, что есть проблемы с вашими моделями,
      используйте команду <command>python manage.py
      validate</command>. Она поможет выявить все стандартные
      проблемы.
    </para>

    <para>
      Если ваши модели не имеют ошибок, выполните следующую команду,
      чтобы Django сгенерировало операторы <token>CREATE TABLE</token>
      для моделей приложения <token>books</token> (с полной подсветкой
      синтаксиса, если вы используете Unix):
      <screen>
python manage.py sqlall books
      </screen>
    </para>

    <para>
      В данной команде <token>books</token> является именем
      приложения. Это имя вы указывали при выполнении команды
      <command>manage.py startapp</command>. После запуска команды вы
      должны увидеть нечто подобное:
      <screen>
        <![CDATA[
BEGIN;
CREATE TABLE "books_publisher" (
    "id" serial NOT NULL PRIMARY KEY,
    "name" varchar(30) NOT NULL,
    "address" varchar(50) NOT NULL,
    "city" varchar(60) NOT NULL,
    "state_province" varchar(30) NOT NULL,
    "country" varchar(50) NOT NULL,
    "website" varchar(200) NOT NULL
);
CREATE TABLE "books_book" (
    "id" serial NOT NULL PRIMARY KEY,
    "title" varchar(100) NOT NULL,
    "publisher_id" integer NOT NULL REFERENCES "books_publisher" ("id"),
    "publication_date" date NOT NULL
);
CREATE TABLE "books_author" (
    "id" serial NOT NULL PRIMARY KEY,
    "salutation" varchar(10) NOT NULL,
    "first_name" varchar(30) NOT NULL,
    "last_name" varchar(40) NOT NULL,
    "email" varchar(75) NOT NULL,
    "headshot" varchar(100) NOT NULL
);
CREATE TABLE "books_book_authors" (
    "id" serial NOT NULL PRIMARY KEY,
    "book_id" integer NOT NULL REFERENCES "books_book" ("id"),
    "author_id" integer NOT NULL REFERENCES "books_author" ("id"),
    UNIQUE ("book_id", "author_id")
);
CREATE INDEX books_book_publisher_id ON "books_book" ("publisher_id");
COMMIT;
        ]]>
      </screen>
    </para>

    <para>
      Отметим следующее:
      <itemizedlist>
        <listitem>
          <para>
            Имена таблиц генерируются автоматически, комбинируется имя
            приложения (<token>books</token>) и имя модели в нижнем
            регистре (<token>publisher</token>, <token>book</token> и
            <token>author</token>). Вы можете изменить это поведение,
            подробности смотрите в приложении <quote><xref
            linkend="djangobook.appendix_b"
            endterm="djangobook.appendix_b.title"/></quote>.
          </para>
        </listitem>

        <listitem>
          <para>
            Как мы уже упоминали, Django автоматически добавляет
            первичный ключ для каждой таблицы &mdash; поле
            <token>id</token>. Вы можете изменить и это.
          </para>
        </listitem>

        <listitem>
          <para>
            По правилу Django добавляет
            <quote><token>_id</token></quote> к имени поля внешнего
            ключа. Как вы можете предположить, вы можете изменить и
            это поведение.
          </para>
        </listitem>

        <listitem>
          <para>
            Привязка внешнего ключа явно определяется с помощью
            оператора <token>REFERENCES</token>.
          </para>
        </listitem>

        <listitem>
          <para>
            Операторы <token>CREATE TABLE</token> адаптируются к
            используемой базе данных, таким образом специфичные типы
            полей, такие как <token>auto_increment</token> (MySQL),
            <token>serial</token> (PostgreSQL) или <token>integer
            primary key</token> (SQLite) обрабатываются
            автоматически. То же самое происходит с экранированием
            имён полей (т.е., используются двойные или одинарные
            кавычки). В данном примере приведён синтаксис для
            PostgreSQL.
          </para>
        </listitem>
      </itemizedlist>
    </para>

    <para>
      Команда <command>sqlall</command> не создаёт таблицы и никак не
      воздействует на базу данных &mdash; она просто выводит SQL
      операторы на экран и вы можете посмотреть, что будет передано в
      базу данных. Если вы пожелаете, можно вручную скопировать эти
      операторы в командную строку клиента базы данных или
      перенаправить данные в клиент напрямую. Тем не менее, Django
      предоставляет простой способ выполнения SQL в базе
      данных. Выполните команду <command>syncdb</command>:
      <screen>
        <![CDATA[
python manage.py syncdb
        ]]>
      </screen>
    </para>

    <para>
      Вы увидите подобное:
      <screen>
        <![CDATA[
Creating table books_publisher
Creating table books_book
Creating table books_author
Installing index for books.Book model
        ]]>
      </screen>
    </para>

    <para>
      Команда <command>syncdb</command> просто
      <emphasis>синхронизирует</emphasis> ваши модели в базе
      данных. Она просматривает все модели каждого приложения,
      указанного в параметре <varname>INSTALLED_APPS</varname>,
      проверяет наличие соответствующих таблиц в базе данных и по
      необходимости создаёт их. Следует отметить, что
      <command>syncdb</command> <emphasis>не</emphasis> синхронизирует
      изменения в моделях или удаления моделей. Если вы изменили
      модель или удалили её, то команда <command>syncdb</command> не
      поможет с внесением изменений в базу. (More on this in the
      “Making Changes to a Database Schema” section toward the end of
      this chapter. FIXME)
    </para>

    <para>
      При повторном запуске команды <command>python manage.py
      syncdb</command> ничего не произойдёт, так как вы не добавили
      модели в приложение <token>books</token> или не добавили новое
      приложение в <varname>INSTALLED_APPS</varname>. Следовательно,
      безопасно запускать эту команду &mdash; она не испортит базу
      данных.
    </para>

    <para>
      Если вам интересно, то изучите подробнее клиент вашей базы
      данных и просмотрите созданную базу данных. Вы можете вручную
      запустить клиент (т.е., <command>psql</command> для PostgreSQL)
      или вы можете применить команду <command>python manage.py
      dbshell</command>, которая запускает клиент, используя параметр
      <varname>DATABASE_ENGINE</varname>. Последний вариант более
      удобен.
    </para>

  </section>

  <section id="&BASEID;.basic-access">

    <title id="&BASEID;.basic-access.title">
      Доступ к данным
    </title>

    <para>
      После создания модели Django автоматически предоставляет
      высокоуровневый API для работы с этими моделями. Изучите его,
      запустив команду <command>python manage.py shell</command> и
      набрав следующее:
      <screen>
        <![CDATA[
>>> from books.models import Publisher
>>> p1 = Publisher(name='Addison-Wesley', address='75 Arlington Street',
...     city='Boston', state_province='MA', country='U.S.A.',
...     website='http://www.apress.com/')
>>> p1.save()
>>> p2 = Publisher(name="O'Reilly", address='10 Fawcett St.',
...     city='Cambridge', state_province='MA', country='U.S.A.',
...     website='http://www.oreilly.com/')
>>> p2.save()
>>> publisher_list = Publisher.objects.all()
>>> publisher_list
[<Publisher: Publisher object>, <Publisher: Publisher object>]
        ]]>
      </screen>
    </para>

    <para>
      Эти несколько строк кода выполняют немного. Вот основное:
      <itemizedlist>
        <listitem>
          <para>
            Во-первых, мы импортируем наш класс модели
            <classname>Publisher</classname>. Это позволит нам
            работать с таблицей базы данных, которая содержит
            информацию об издателях.
          </para>
        </listitem>

        <listitem>
          <para>
            Мы создаём экземпляр этого класса, передав значения для
            каждого поля &mdash; <token>name</token>,
            <token>address</token> и так далее.
          </para>
        </listitem>

        <listitem>
          <para>
            Чтобы сохранить объект в базе данных, воспользуйтесь
            методом
            <function>save()</function>. Django выполнит для этого SQL
            оператор <token>INSERT</token>.
          </para>
        </listitem>

        <listitem>
          <para>
            Для того, чтобы получить информацию об издателях из базы
            данных, используйте атрибут
            <token>Publisher.objects</token>, который можно
            рассматривать как список всех издателей. Получаем список
            <emphasis>всех</emphasis> объектов
            <classname>Publisher</classname> из базы данных с помощью
            метода <function>Publisher.objects.all()</function>.
            Django выполнит SQL оператор <token>SELECT</token>.
          </para>
        </listitem>
      </itemizedlist>
    </para>

    <para>
      Следует остановиться на одном моменте, если он не очевиден из
      примера. При создании объекта с помощью модели Django не
      сохраняет ничего в базе данных до тех пор, пока вы не
      воспользуетесь методом <function>save()</function>:
      <screen>
        <![CDATA[
p1 = Publisher(...)
# At this point, p1 is not saved to the database yet!
p1.save()
# Now it is.
        ]]>
      </screen>
    </para>

    <para>
      Если вам требуется создать объект и сохранить его в базе данных
      единой операцией, используйте метод
      <function>objects.create()</function>. Следующий пример
      эквивалентен предыдущему:
      <screen>
        <![CDATA[
>>> p1 = Publisher.objects.create(name='Apress',
...     address='2855 Telegraph Avenue',
...     city='Berkeley', state_province='CA', country='U.S.A.',
...     website='http://www.apress.com/')
>>> p2 = Publisher.objects.create(name="O'Reilly",
...     address='10 Fawcett St.', city='Cambridge',
...     state_province='MA', country='U.S.A.',
...     website='http://www.oreilly.com/')
>>> publisher_list = Publisher.objects.all()
>>> publisher_list
        ]]>
      </screen>
    </para>

    <para>
      Действительно, можно делать многое с помощью API для работы с
      базой данных, но сначала давайте позаботимся о небольших
      неудобствах.
    </para>

  </section>

  <section id="&BASEID;.model-representation">

    <title id="&BASEID;.model-representation.title">
      Добавляем строковое представление модели
    </title>

    <para>
      Когда мы распечатали список издателей, всё что мы получили
      &mdash; бесполезный вывод, который затрудняет понимание:
      <screen>
        <![CDATA[
[<Publisher: Publisher object>, <Publisher: Publisher object>]
        ]]>
      </screen>
    </para>

    <para>
      Это можно легко исправить, добавив метод
      <function>__unicode__()</function> к нашему объекту
      <classname>Publisher</classname>. Метод
      <function>__unicode__()</function> указывает Python как
      отображать юникодное представление объекта. Вот так это
      используется в реальном приложении:
      <screen>
        <![CDATA[
from django.db import models

class Publisher(models.Model):
    name = models.CharField(max_length=30)
    address = models.CharField(max_length=50)
    city = models.CharField(max_length=60)
    state_province = models.CharField(max_length=30)
    country = models.CharField(max_length=50)
    website = models.URLField()

    def __unicode__(self):
        return self.name

class Author(models.Model):
    salutation = models.CharField(max_length=10)
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=40)
    email = models.EmailField()
    headshot = models.ImageField(upload_to='/tmp')

    def __unicode__(self):
        return '%s %s' % (self.first_name, self.last_name)

class Book(models.Model):
    title = models.CharField(max_length=100)
    authors = models.ManyToManyField(Author)
    publisher = models.ForeignKey(Publisher)
    publication_date = models.DateField()

    def __unicode__(self):
        return self.title
        ]]>
      </screen>
    </para>

    <para>
      Как видно, метод <function>__unicode__()</function> может делать
      всё необходимое для того, чтобы возвратить строковое
      представление. В данном случае, методы
      <function>__unicode__()</function> для
      <classname>Publisher</classname> и <classname>Book</classname>
      просто возвращают имя объекта и заголовок, соответственно, но
      метод <function>__unicode__()</function> для
      <classname>Author</classname> более сложный &mdash; он
      объединяет поля <token>first_name</token> и
      <token>last_name</token>.
    </para>

    <para>
      Единственное требование к методу
      <function>__unicode__()</function> &mdash; он должен возвращать
      объект <classname>Unicode</classname>. В противном случае,
      например, если метод возвращает целое число, Python вызовет
      исключение <token>TypeError</token> с сообщением <quote>coercing
      to Unicode: need string or buffer, int found</quote>.
    </para>

    <para>
      <note>
        <title>
          Объекты <classname>Unicode</classname>
        </title>

        <para>
          Что представляют собой объекты
          <classname>Unicode</classname>?
        </para>

        <para>
          Вы можете рассматривать объект
          <classname>Unicode</classname> в качестве обычной строки,
          которая может содержать миллион различных типов символов, от
          акцентированных версий латинских букв до различных символов
          экзотических языков.
        </para>

        <para>
          Обычные строки в Python являются
          <emphasis>кодированными</emphasis>, это означает, что они
          используют кодировку: ASCII, ISO-8859-1 или UTF-8. Если вы
          помещаете в обычную строку экзотические символы (таковыми
          считаются любые символы, не попадающие в кодировку ASCII),
          вы должны помнить используемую кодировку, иначе на выходе вы
          получите непонятную мешанину символов. Проблемы возникают
          при попытках объединить данные в одной кодировке с данными в
          другой или при попытке отобразить эти данные в приложении,
          которое работает только с одной определённой кодировкой. Все
          мы встречались с сайтами или сообщениями электронной почты,
          которые содержали <quote>??? ??????</quote> или другие
          символы в нечётных позициях. Всё это показывает на проблему
          с кодировкой.
        </para>

        <para>
          Однако объекты <classname>Unicode</classname> не имеют
          кодировки. Они используют целостный, универсальный набор
          символов, называемый <quote>Unicode</quote>. При работе с
          объектами <classname>Unicode</classname> в Python, вы можете
          смешивать и сравнивать их, не беспокоясь о кодировке.
        </para>

        <para>
          Django использует объекты <classname>Unicode</classname>
          везде. Объекты моделей выбираются в виде объектов
          <classname>Unicode</classname>, представления работают с
          <classname>Unicode</classname> данными, а шаблоны
          обрабатываются как <classname>Unicode</classname>. В общем,
          вам не надо беспокоиться о кодировках вообще. Всё должно
          работать.
        </para>

        <para>
          Следует отметить то, что мы лишь кратко описали объекты
          <classname>Unicode</classname>. Вы можете самостоятельно
          продолжить их изучение. Хорошей точкой старта будет <ulink
          url="http://www.joelonsoftware.com/articles/Unicode.html"/>.
        </para>
      </note>
    </para>

    <para>
      Для того, чтобы эти изменения вступили в силу надо выйти из
      оболочки и запустить её снова командой <command>python manage.py
      shell</command>. (Это самый простой способ для активации
      изменений.) Теперь список объектов
      <classname>Publisher</classname> более понятен:
      <screen>
        <![CDATA[
>>> from books.models import Publisher
>>> publisher_list = Publisher.objects.all()
>>> publisher_list
[<Publisher: Addison-Wesley>, <Publisher: O'Reilly>]
        ]]>
      </screen>
    </para>

    <para>
      Удостоверьтесь, что каждая определённая вами модель имеет метод
      <function>__unicode__()</function>. Это необходимо не только для
      вашего удобства, но и потому что Django использует результат
      вызова этого метода при отображении объектов.
    </para>

    <para>
      Наконец, следует отметить, что <function>__unicode__()</function>
      является хорошим примером добавления <emphasis>нового
      поведения</emphasis> моделям. Модель Django описывает большее
      чем просто таблицу для объекта, она также описывает всю
      функциональность этого объекта. Метод
      <function>__unicode__()</function> является одним из примеров такой
      функциональности &mdash; модель знает как отображать себя.
    </para>

  </section>

  <section id="&BASEID;.insert-update">

    <title id="&BASEID;.insert-update.title">
      Вставка и изменение данных
    </title>

    <para>
      Вы уже видели как это делается: для того, чтобы вставить запись
      в вашу базу данных сначала надо создать экземпляр модели с
      помощью именованных аргументов, вот так:
      <screen>
        <![CDATA[
>>> p = Publisher(name='Apress',
...         address='2855 Telegraph Ave.',
...         city='Berkeley',
...         state_province='CA',
...         country='U.S.A.',
...         website='http://www.apress.com/')
        ]]>
      </screen>
    </para>

    <para>
      Этот пример создания экземпляра модели <emphasis>не</emphasis>
      производит изменений в базе данных. Эта запись не сохраняется в
      базе данных пока не будет вызван метод
      <function>save()</function>:
      <screen>
        <![CDATA[
>>> p.save()
        ]]>
      </screen>
    </para>

    <para>
      Вышеприведённые действия с точки зрения SQL операторов выглядят
      так:
      <screen>
        <![CDATA[
INSERT INTO book_publisher
    (name, address, city, state_province, country, website)
VALUES
    ('Apress', '2855 Telegraph Ave.', 'Berkeley', 'CA',
     'U.S.A.', 'http://www.apress.com/');
        ]]>
      </screen>
    </para>

    <para>
      Так как модель <classname>Publisher</classname> использует
      автоматически увеличивающийся первичный ключ <token>id</token>,
      первый вызов метода <function>save()</function> выполнит ещё и
      вычисление значения для первичного ключа и подставит это
      значение в атрибут <token>id</token>:
      <screen>
        <![CDATA[
>>> p.id
52    # значение может отличаться для ваших данных
        ]]>
      </screen>
    </para>

    <para>
      Последующие вызовы метода <function>save()</function> будут
      перезаписывать существующую запись, не создавая новую (т.е.,
      будут выполнять SQL оператор <token>UPDATE</token> вместо
      <token>INSERT</token>):
      <screen>
        <![CDATA[
>>> p.name = 'Apress Publishing'
>>> p.save()
        ]]>
      </screen>
    </para>

    <para>
      В SQL это будет выглядеть так:
      <screen>
        <![CDATA[
UPDATE book_publisher SET
    name = 'Apress Publishing',
    address = '2855 Telegraph Ave.',
    city = 'Berkeley',
    state_province = 'CA',
    country = 'U.S.A.',
    website = 'http://www.apress.com'
WHERE id = 52;
        ]]>
      </screen>
    </para>

    <para>
      Да, следует отметить то, что <emphasis>все</emphasis> поля будут
      обновлены, а не только те, что были изменены. В зависимости от
      реализации вашего приложения, такое поведение может вызвать
      <quote>гонки</quote> (race
      condition). См <quote><xref linkend="&BASEID;.select.multiple-update"
      endterm="&BASEID;.select.multiple-update.title"/></quote> далее
      о том, как выполнять подобные запросы:
      <screen>
        <![CDATA[
UPDATE books_publisher SET
    name = 'Apress Publishing'
WHERE id=52;
        ]]>
      </screen>
    </para>

  </section>

  <section id="&BASEID;.select">

    <title id="&BASEID;.select.title">
      Выборка объектов
    </title>

    <para>
      Знание о том, как можно создавать и изменять данные достаточно,
      но есть вероятность, что ваше приложение будет гораздо чаще
      обращаться к существующим объектам, чем создавать новые. Мы уже
      знаем способ получения <emphasis>каждой</emphasis> записи
      определённой модели:
      <screen>
        <![CDATA[
>>> Publisher.objects.all()
[<Publisher: Apress>, <Publisher: O'Reilly>]
        ]]>
      </screen>
    </para>

    <para>
      В общих чертах в SQL это выглядит так:
      <screen>
        <![CDATA[
SELECT
    id, name, address, city, state_province, country, website
FROM book_publisher;
        ]]>
      </screen>
    </para>

    <para>
      <note>
        <para>
          Следует отметить, что Django не использует <token>SELECT
          *</token> при просмотре данных, а вместо этого явно
          перечисляет все поля. Так было задумано изначально: в
          некоторых случаях использование <token>SELECT *</token>
          может повлиять на производительность, а главное,
          перечисление полей более соответствует нормам Искусства
          программирования на языке Python: <quote>Явное лучше
          неявного</quote>.
        </para>

        <para>
          Для получения более подробной информации об Искусстве
          программирования на языке Python выполните в консоли Python
          команду <command>import this</command>.
        </para>
      </note>
    </para>

    <para>
      Теперь внимательно рассмотрим строку
      <token>Publisher.objects.all()</token>:
      <itemizedlist>
        <listitem>
          <para>
            Сначала у нас есть определённая нами модель
            <classname>Publisher</classname>. Ничего удивительного:
            при необходимости получить доступ к данным вы используете
            модель.
          </para>
        </listitem>

        <listitem>
          <para>
            Затем мы работаем с <token>objects</token>. Технически
            этот объект можно назвать
            <emphasis>менеджером</emphasis>. Менеджеры более подробно
            будут описаны в главе <quote><xref
            linkend="djangobook.chap10"
            endterm="djangobook.chap10.title"/></quote>. Сейчас вам
            надо знать только то, что менеджеры отвечают за операции
            <quote>табличного уровня</quote> над данными, что самое
            главное, включая операции выборки данных.
          </para>

          <para>
            Все модели автоматически получают менеджер
            <token>objects</token>. Он используется при каждом доступе
            к данным.
          </para>
        </listitem>

        <listitem>
          <para>
            Наконец, у нас есть <function>all()</function>. Это метод
            объекта <token>objects</token>, который возвращает все
            записи, относящиеся к этой модели, из базы
            данных. Несмотря на то, что этот объект
            <emphasis>выглядит</emphasis> как список, в
            действительности это <emphasis>набор данных
            (QuerySet)</emphasis> &mdash; объект, который представляет
            собой набор записей из базы данных. Набор данных описан в
            приложении <quote><xref linkend="djangobook.appendix_c"
            endterm="djangobook.appendix_c.title"/></quote>. В
            оставшейся части этой главы мы будем рассматривать этот
            набор как список.
          </para>
        </listitem>
      </itemizedlist>
    </para>

    <para>
      Любая выборка из базы данных работает по определённому шаблону
      &mdash; мы используем методы менеджера, который подключен к
      модели, по которой производится выборка.
    </para>

    <section id="&BASEID;.select.filtering">

      <title id="&BASEID;.select.filtering.title">
        Фильтрация данных
      </title>

      <para>
        Естественно, что достаточно редко требуется получать
        <emphasis>весь набор</emphasis> данных из модели
        единовременно. В большинстве случаев нам требуется обработать
        небольшую часть данных. Мы можем осуществить это с помощью
        метода <function>filter()</function>:
        <screen>
          <![CDATA[
>>> Publisher.objects.filter(name='Apress')
[<Publisher: Apress>]
          ]]>
        </screen>
      </para>

      <para>
        Метод <function>filter()</function> принимает именованные
        аргументы, которые преобразуются в соответствующие SQL-условия
        <token>WHERE</token>. Предыдущий пример будет преобразован в
        нечто подобное:
        <screen>
          <![CDATA[
SELECT id, name, address, city, state_province, country, website
FROM books_publisher
WHERE name = 'Apress';
          ]]>
        </screen>
      </para>

      <para>
        Вы можете передать множество аргументов в
        <function>filter()</function> для сокращения диапазона
        выборки:
        <screen>
          <![CDATA[
>>> Publisher.objects.filter(country="U.S.A.", state_province="CA")
[<Publisher: Apress>]
          ]]>
        </screen>
      </para>

      <para>
        Множество аргументов будут объединены с помощью SQL операторов
        <token>AND</token>. Пример станет таким:
        <screen>
          <![CDATA[
SELECT id, name, address, city, state_province, country, website
FROM books_publisher
WHERE country = 'U.S.A.'
AND state_province = 'CA';
          ]]>
        </screen>
      </para>

      <para>
        Следует отметить, что по умолчанию выборка использует SQL
        оператор <token>=</token> для точного совпадения. Также можно
        выполнять другие виды запросов:
        <screen>
          <![CDATA[
>>> Publisher.objects.filter(name__contains="press")
[<Publisher: Apress>]
          ]]>
        </screen>
      </para>

      <para>
        Обратите внимание на <emphasis>двойное</emphasis>
        подчёркивание между <token>name</token> и
        <token>contains</token>. Подобно Python это используется
        Django для выполнения <quote>магических</quote> действий. В
        данном случае <token>__contains</token> преобразовывается в
        SQL оператор <token>LIKE</token>:
        <screen>
          <![CDATA[
SELECT id, name, address, city, state_province, country, website
FROM books_publisher
WHERE name LIKE '%press%';
          ]]>
        </screen>
      </para>

      <para>
        Доступны множество типов выборок, включая
        <token>icontains</token> (независящий от регистра LIKE),
        <token>startswith</token> и <token>endswith</token>, а также
        <token>range</token> (SQL оператор <token>BETWEEN</token>). В
        приложении <quote><xref linkend="djangobook.appendix_c"
        endterm="djangobook.appendix_c.title"/></quote> подробно
        описаны все типы выборок.
      </para>

    </section>

    <section id="&BASEID;.select.single">

      <title id="&BASEID;.select.single.title">
        Получение одного объекта
      </title>

      <para>
        Вышеприведённые примеры использования
        <function>filter()</function> всегда возвращают
        <classname>QuerySet</classname>, который можно использовать
        как список. Иногда более уместной является выборка
        единственного объекта. Для этого предназначен метод
        <function>get()</function>:
        <screen>
          <![CDATA[
>>> Publisher.objects.get(name="Apress")
<Publisher: Apress>
          ]]>
        </screen>
      </para>

      <para>
        Вместо списка (т.е., набора данных
        <classname>QuerySet</classname>) возвращается только один
        объект. По этой причине, запрос ожидающий множество объектов
        вызовет исключение:
        <screen>
          <![CDATA[
>>> Publisher.objects.get(country="U.S.A.")
Traceback (most recent call last):
    ...
MultipleObjectsReturned: get() returned more than one Publisher --
    it returned 2! Lookup parameters were {'country': 'U.S.A.'}
          ]]>
        </screen>
      </para>

      <para>
        Запрос не возвращающий ни одного объекта тоже вызовет
        исключение:
        <screen>
          <![CDATA[
>>> Publisher.objects.get(name="Penguin")
Traceback (most recent call last):
    ...
DoesNotExist: Publisher matching query does not exist.
          ]]>
        </screen>
      </para>

      <para>
        Исключение <classname>DoesNotExist</classname> является
        атрибутом класса модели &mdash;
        <token>Publisher.DoesNotExist</token>. В вашем приложении вы
        можете перехватывать такие исключения:
        <screen>
          <![CDATA[
try:
    p = Publisher.objects.get(name='Apress')
except Publisher.DoesNotExist:
    print "Apress isn't in the database yet."
else:
    print "Apress is in the database."
          ]]>
        </screen>
      </para>

    </section>

    <section id="&BASEID;.select.order">

      <title id="&BASEID;.select.order.title">
        Сортировка данных
      </title>

      <para>
        В процессе изучения предыдущих примеров вы могли заметить, что
        объекты возвращаются в случайном порядке. Раз мы не указали в
        каком порядке нам возвращать результат выборки, база данных
        отдаёт его в удобном для себя виде.
      </para>

      <para>
        Очевидно, что для вашего приложения потребуется отсортировать
        результат по какому-нибудь значению, скажем, по алфавиту. Для
        этого использую метод <function>order_by()</function>:
        <screen>
          <![CDATA[
>>> Publisher.objects.order_by("name")
[<Publisher: Apress>, <Publisher: O'Reilly>]
          ]]>
        </screen>
      </para>

      <para>
        Это не сильно отличается от примера с методом
        <function>all()</function>, но SQL представление теперь
        включает в себя оператор сортировки:
        <screen>
          <![CDATA[
SELECT id, name, address, city, state_province, country, website
FROM books_publisher
ORDER BY name;
          ]]>
        </screen>
      </para>

      <para>
        Мы можем производить сортировку по любому полю:
        <screen>
          <![CDATA[
>>> Publisher.objects.order_by("address")
[<Publisher: O'Reilly>, <Publisher: Apress>]

>>> Publisher.objects.order_by("state_province")
[<Publisher: Apress>, <Publisher: O'Reilly>]
          ]]>
        </screen>
      </para>

      <para>
        Для выполнения сортировки по множеству полей (когда второе
        поле используется для сортировки элементов, у которых первое
        поле совпадает), используют множество аргументов:
        <screen>
          <![CDATA[
>>> Publisher.objects.order_by("state_province", "address")
 [<Publisher: Apress>, <Publisher: O'Reilly>]
          ]]>
        </screen>
      </para>

      <para>
        Также мы можем указать необходимость выполнять обратную
        сортировку с помощью префикса <token>-</token>(минус) для
        имени поля:
        <screen>
          <![CDATA[
>>> Publisher.objects.order_by("-name")
[<Publisher: O'Reilly>, <Publisher: Apress>]
          ]]>
        </screen>
      </para>

      <para>
        Несмотря на все возможности, постоянное использование
        <function>order_by()</function> может надоесть. Чаще всего
        сортировку надо производить по жёстко определённому полю. В
        этих случаях Django позволяет указать стандартную сортировку
        для модели:
        <screen>
          <![CDATA[
class Publisher(models.Model):
    name = models.CharField(max_length=30)
    address = models.CharField(max_length=50)
    city = models.CharField(max_length=60)
    state_province = models.CharField(max_length=30)
    country = models.CharField(max_length=50)
    website = models.URLField()

    def __unicode__(self):
        return self.name

    class Meta:
        ordering = ["name"]
          ]]>
        </screen>
      </para>

      <para>
        Здесь мы ввели новую концепцию: класс
        <classname>Meta</classname>, который внедрён в определение
        класса <classname>Publisher</classname> (обратите внимание на
        отступы). Вы можете использовать данный класс
        <classname>Meta</classname> с любой моделью для указания
        различных параметров, влияющих на поведение модели. Полный
        список данных параметров описан в приложении B FIXME, но
        сейчас мы рассматривали только параметр
        <token>ordering</token>. Если вы определите его, то пока не
        будет использован явный вызов метода
        <function>order_by()</function>, все объекты
        <classname>Publisher</classname> будут выдаваться
        отсортированными по полю <token>name</token>.
      </para>

    </section>

    <section id="&BASEID;.select.chain">

      <title id="&BASEID;.select.chain.title">
        Формирование цепочки запросов
      </title>

      <para>
        Вы знаете как фильтровать данные и как их сортировать. Вы
        желаете узнать как это делать одновременно? Для этого следует
        <quote>сцепить</quote> операторы вместе:
        <screen>
          <![CDATA[
>>> Publisher.objects.filter(country="U.S.A.").order_by("-name")
[<Publisher: O'Reilly>, <Publisher: Apress>]
          ]]>
        </screen>
      </para>

      <para>
        Как вы можете предполагать, в SQL представлении это будет
        выглядеть так:
        <screen>
          <![CDATA[
SELECT id, name, address, city, state_province, country, website
FROM books_publisher
WHERE country = 'U.S.A'
ORDER BY name DESC;
          ]]>
        </screen>
      </para>

      <para>
        Количество таких цепочек никак не
        ограничено<footnote><para>Оставил из предыдущей версии
        (прим. переводчика).</para></footnote>.
      </para>

    </section>

    <section id="&BASEID;.select.slice">

      <title id="&BASEID;.select.slice.title">
        Выборка части результатов
      </title>

      <para>
        Часто требуется получить только несколько строк результата
        выборки. Представьте, что в вашей базе находится несколько
        тысяч издателей, но вам надо отобразить только первого. Вы
        можете это осуществить с помощью возможностей стандартного
        списка Python:
        <screen>
          <![CDATA[
>>> Publisher.objects.order_by('name')[0]
<Publisher: Apress>
          ]]>
        </screen>
      </para>

      <para>
        Это преобразуется в:
        <screen>
          <![CDATA[
SELECT id, name, address, city, state_province, country, website
FROM books_publisher
ORDER BY name
LIMIT 1;
          ]]>
        </screen>
      </para>

      <para>
        Аналогично, вы можете получать определённый набор данных с
        помощью стандартного синтаксиса языка Python для работы со
        списками:
        <screen>
          <![CDATA[
>>> Publisher.objects.order_by('name')[0:2]
          ]]>
        </screen>
      </para>

      <para>
        Этот код вернёт два объекта и будет преобразован в:
        <screen>
          <![CDATA[
SELECT id, name, address, city, state_province, country, website
FROM books_publisher
ORDER BY name
OFFSET 0 LIMIT 2;
          ]]>
        </screen>
      </para>

      <para>
        Следует отметить, что отрицательные значения <emphasis>не
        поддерживаются</emphasis>:
        <screen>
          <![CDATA[
>>> Publisher.objects.order_by('name')[-1]
Traceback (most recent call last):
  ...
AssertionError: Negative indexing is not supported.
          ]]>
        </screen>
      </para>

      <para>
        Но получить результат всё же возможно. Просто воспользуйтесь
        методом <function>order_by()</function>:
        <screen>
          <![CDATA[
>>> Publisher.objects.order_by('-name')[0]
          ]]>
        </screen>
      </para>

    </section>

    <section id="&BASEID;.select.multiple-update">

      <title id="&BASEID;.select.multiple-update.title">
        Изменение множества объектов одним запросом
      </title>

      <para>
        Мы упоминали в разделе <quote><xref
        linkend="&BASEID;.insert-update"
        endterm="&BASEID;.insert-update.title"/></quote> о том, что
        метод <function>save()</function> обновляет
        <emphasis>все</emphasis> поля записи. Иногда полезно уметь
        обновлять только выделенный набор полей.
      </para>

      <para>
        Например, нам требуется изменить в объекте
        <classname>Publisher</classname> поле <token>name</token> с
        <quote>Apress</quote> на <quote>Apress Publishing</quote>. При
        использовании <function>save()</function> это выглядит так:
        <screen>
          <![CDATA[
>>> p = Publisher.objects.get(name='Apress')
>>> p.name = 'Apress Publishing'
>>> p.save()
          ]]>
        </screen>
      </para>

      <para>
        Это примерно преобразовывается в следующий SQL:
        <screen>
          <![CDATA[
SELECT id, name, address, city, state_province, country, website
FROM books_publisher
WHERE name = 'Apress';

UPDATE books_publisher SET
    name = 'Apress Publishing',
    address = '2855 Telegraph Ave.',
    city = 'Berkeley',
    state_province = 'CA',
    country = 'U.S.A.',
    website = 'http://www.apress.com'
WHERE id = 52;
          ]]>
        </screen>
      </para>

      <para>
        (Следует отметить, что данный пример предполагает, что нужный
        нам объект имеет идентификатор 52.)
      </para>

      <para>
        Вы можете видеть в данном примере, что метод
        <function>save()</function> установит значения для
        <emphasis>всех</emphasis> полей, не только для
        <token>name</token>. Если в вашем случае, остальные поля могут
        изменяться другими процессами, правильнее будет изменять
        <emphasis>только</emphasis> поля, которые этого требуют. Для
        этого следует использовать метод <function>update()</function>
        объектов <classname>QuerySet</classname>. Пример:
        <screen>
          <![CDATA[
>>> Publisher.objects.filter(id=52).update(name='Apress Publishing')
          ]]>
        </screen>
      </para>

      <para>
        SQL код будет более эффективным и не сможет вызвать
        <quote>гонки</quote>:
        <screen>
          <![CDATA[
UPDATE books_publisher
SET name = 'Apress Publishing'
WHERE id = 52;
          ]]>
        </screen>
      </para>

      <para>
        Метод <function>update()</function> имеется у каждого
        <classname>QuerySet</classname> и это означает, что вы можете
        изменять множество записей за раз. Вот так вы можете изменить
        в поле <token>country</token> значение <quote>U.S.A.</quote>
        на <quote>USA</quote> для каждой записи
        <classname>Publisher</classname>:
        <screen>
          <![CDATA[
>>> Publisher.objects.all().filter(country='U.S.A.').update(country='USA')
2
          ]]>
        </screen>
      </para>

      <para>
        Метод <function>update()</function> вернул значение &mdash;
        целое, представляющее количество изменённых записей.
      </para>

    </section>

  </section>

  <section id="&BASEID;.delete">

    <title id="&BASEID;.delete.title">
      Удаление объектов
    </title>

    <para>
      Для удаления объектов следует использовать метод
      <function>delete()</function>:
      <screen>
        <![CDATA[
>>> p = Publisher.objects.get(name="O'Reilly")
>>> p.delete()
>>> Publisher.objects.all()
[<Publisher: Apress Publishing>]
        ]]>
      </screen>
    </para>

    <para>
      Вы также можете удалять сразу несколько объектов, для этого надо
      вызвать метод <function>delete()</function> объекта
      <classname>QuerySet</classname>. Эта методика аналогична
      использованию метода <function>update()</function>, описанному в
      предыдущем разделе:
      <screen>
        <![CDATA[
>>> Publisher.objects.filter(country='USA').delete()
>>> Publisher.objects.all().delete()
>>> Publisher.objects.all()
[]
        ]]>
      </screen>
    </para>

    <para>
      Будьте осторожны во время удаления своих данных! В качестве меры
      предосторожности против случайного удаления всех данных в
      таблице Django требует явного использования метода
      <function>all()</function> для удаления
      <emphasis>всех</emphasis> записей таблицы. Этот пример не
      сработает:
      <screen>
        <![CDATA[
>>> Publisher.objects.delete()
Traceback (most recent call last):
  File "<console>", line 1, in <module>
AttributeError: 'Manager' object has no attribute 'delete'
        ]]>
      </screen>
    </para>

     <para>
       Но сразу станет работать, если вы добавите метод
       <function>all()</function>:
       <screen>
         <![CDATA[
>>> Publisher.objects.all().delete()
         ]]>
       </screen>
     </para>

     <para>
       Если вам потребуется удалить выделенный набор записей, в таком
       случае не требуется использовать метод
       <function>all()</function>. Повторим предыдущий пример:
       <screen>
         <![CDATA[
>>> Publisher.objects.filter(country='USA').delete()
         ]]>
       </screen>
     </para>

  </section>

<!--
  <section id="&BASEID;.models-and-scripts">

    <title id="&BASEID;.models-and-scripts.title">
      Доступ к моделям из стороннего скрипта
    </title>

    <para>
      Однажды я столкнулся с необходимостью переноса и последующей
      синхронизации некоторого количества словарей из большой базы
      данных под управлением Oracle в проект, разработанный с помощью
      Django. Для экспорта данных был написан небольшой скрипт на
      языке Python, который упаковывал данные таблиц и информацию о
      структуре таблиц в Pickle объект. Для импорта данных был написан
      другой скрипт. Чтобы обеспечить его работу с любым типом баз
      данных, которые поддерживаются Django было принято решение
      воспользоваться стандартным Django DB API.
    </para>

    <para>
      Первым делом следует обеспечить установку переменных окружения
      перед выполнением скрипта импорта. Переменная
      <varname>PYTHONPATH</varname> должна указывать на каталог
      <emphasis>в котором находится каталог нашего проекта</emphasis>, т.е., если
      проект располагается в каталоге
      <filename>~/development/djangobook</filename>, то переменная
      должна содержать <token>~/development</token>. Переменная
      <varname>DJANGO_SETTINGS_MODULE</varname> должна указывать на
      модуль (файл) с настройками доступа к базе данных, в моём случае
      это будет <token>djangobook.settings</token>.
    </para>

    <para>
      Первым делом в скрипте следует выполнить импортирование моделей:
      <screen>
	<![CDATA[
import django
from arm.invite.models import Dictionary, DictionaryType
	]]>
      </screen>
    </para>

    <para>
      Дальше всё проще. Предположим, что вы уже загрузили данные в
      словарь и теперь будете замещать данные в сводной таблице:
      <screen>
	<![CDATA[
for k in dicts.keys():
    print "Processing %s...', % k,
    c = dicts[k].get('columns')
    d = dicts[k].get('data')
    # тут проверка данных
    try:
        index_cod = c.index('COD')
        index_text = c.index('TEXT')
    except:
        print ' failed [wrong structure].'
        continue
    # получаем объект - словарный тип
    try:
        t = DictionaryType.objects.get(title=k.lower())
    except:
        # если не нашли, то что-нибудь делаем
    # удаляем старые записи
    Dictionary.objects.filter(slvcode=t).delete()
    # заливаем новые
    for i in dicts[k].get('data'):
        try:
            r = Dictionary(slvcode=t, code=i[index_cod], text=i[index_text])
	    r.save()
        except:
	    pass
    print ' done.'
	]]>
      </screen>
    </para>

  </section>
//-->

</chapter>
