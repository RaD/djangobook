<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
"http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd"
[
<!ENTITY BASEID "djangobook.chap05">
]>

<chapter lang="ru" id="&BASEID;">

  <title id="&BASEID;.title">
    Работа с базой данных: Модели
  </title>

  <para>
    Перевод &copy; Попов Руслан &lt;radz &bull; yandex &bull; ru&gt;
  </para>

  <para>
    В главе <quote><xref linkend="djangobook.chap03"
    endterm="djangobook.chap03.title"/></quote> мы описали основы
    создания динамических сайтов с помощью Django: настройка
    представлений и схемы URL для них. Как мы описывали ранее,
    представление отвечает за <emphasis>некоторую произвольную
    логику</emphasis> и возвращает отклик. В примере логикой являлось
    вычисление текущей даты и времени.
  </para>

  <para>
    В современных веб-приложениях произвольная логика часто вовлечена
    в работу с базой данных. Рассмотрим внутреннюю кухню, сайт такого
    типа подключается к серверу базы данных, получает от него
    некоторые данные и, выполнив форматирование, отображает эти данные
    на странице. Так же сайт может предоставлять посетителям сайта
    возможность заполнять базу данных своими данными.
  </para>

  <para>
    Множество сложных сайтов предоставляют некую комбинацию этих двух
    вариантов. Например, <ulink url="http://www.amazon.com/"/>
    является отличным примером такого сайта. Каждая страница продукта,
    по существу, является запросом в базу данных продуктов Amazon,
    отформатированном в виде HTML. А когда вы отсылаете свой
    комментарий, он помещается в базу данных отзывов.
  </para>

  <para>
    Django отлично подходит для создания сайтов, ориентированных на
    использование совместно с базой данных, т.к., она поставляется с
    простыми, но мощными механизмами выполнения запросов к базе данных
    с помощью Python. Эта глава описывает этот механизм: слой Django
    для работы с базой данных.
  </para>

  <para>
    Следует отметить, что необязательно знать основы теории баз данных
    и SQL для использования этого слоя Django, но это крайне
    рекомендуется. Введение в эти понятия находится вне сферы этой
    книги. Вероятно, вы сможете понять концепции, учитывая контекст
    изложения.
  </para>

  <section id="&BASEID;.dumbway">

    <title id="&BASEID;.dumbway.title">
      Стандартный способ работы с запросами к БД в представлениях
    </title>

    <para>
      Подобно определённому в главе <quote><xref
      linkend="djangobook.chap03"
      endterm="djangobook.chap03.title"/></quote> способу генерации
      вывода с помощью представлений (вбивание руками текста прямо в
      код представления), существует <quote>простой</quote> способ
      получать в представлениях информацию из базы данных. Это просто:
      используйте любую существующую библиотеку языка Python для
      выполнения SQL запроса и обрабатывайте его результаты.
    </para>

    <para>
      В этом примере представления мы используем библиотеку
      <token>MySQLdb</token> (доступную по адресу <ulink
      url="http://www.djangoproject.com/r/python-mysql/"/>) для
      подключения к базе данных MySQL, получения нескольких записей и
      помещения их в шаблон для отображения на странице сайта:
      <screen>
from django.shortcuts import render_to_response
import MySQLdb

def book_list(request):
    db = MySQLdb.connect(user='me', db='mydb', passwd='secret', host='localhost')
    cursor = db.cursor()
    cursor.execute('SELECT name FROM books ORDER BY name')
    names = [row[0] for row in cursor.fetchall()]
    db.close()
    return render_to_response('book_list.html', {'names': names})
      </screen>
    </para>
    
    <para>
      Такой подход работает, но вы должны немедленно столкнуться с
      некоторыми проблемами:
      <itemizedlist>
	<listitem>
	  <para>
	    Мы жёстко определяем параметры соединения с базой
	    данных. В идеале, эти параметры должны храниться в
	    конфигурации проекта Django.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Мы должны писать нудный код: создать соединение,
	    создать курсор, выполнить оператор и закрыть соединение. В
	    идеале, всё что мы должны сделать &mdash; указать
	    необходимый нам результат.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Это привязывает нас к MySQL. Если, с течением времени, мы
	    решим перейти с MySQL на PostgreSQL, нам потребуется
	    использовать другой драйвер для базы данных (т.е.,
	    <token>psycopg</token> вместо <token>MySQLdb</token>),
	    изменить параметры соединения и, в зависимости от природы
	    SQL операторов, возможно, переписать SQL запросы. В
	    идеале, мы должны рассматривать сервер базы данных
	    абстрактно, т.е., для смены сервера мы должны внести
	    изменения в одно только место проекта.
	  </para>
	</listitem>
      </itemizedlist>
    </para>

    <para>
      Как вы можете ожидать, слой Django для работы с базами данных
      помогает решать такие проблемы. Далее представлен пример как
      надо изменить предыдущее представление для использования Django
      API для работы с базами данных:
      <screen>
from django.shortcuts import render_to_response
from mysite.books.models import Book

def book_list(request):
    books = Book.objects.order_by('name')
    return render_to_response('book_list.html', {'books': books})
      </screen>
    </para>

    <para>
      Мы разберём этот код немного позже в этой главе.
    </para>

  </section>

  <section id="&BASEID;.mtvdevpat">

    <title id="&BASEID;.mtvdevpat.title">
      Шаблоны MTV-разработки
    </title>

    <para>
      Прежде чем мы погрузимся в изучение кода, давайте рассмотрим
      общий дизайн БД ориентированных веб-приложений Django.
    </para>

    <para>
      Как мы рассказывали в предыдущих главах, Django поощряет
      свободное использование и строгое разделение частей
      приложения. Если следовать этой философии, то легко вносить
      изменения в одну конкретную часть приложения без ущерба для
      остальных частей. В функциях представления, например, мы
      обсуждали важность отделения бизнес-логики от логики отображения
      с помощью шаблонной системы. Используя слой для работы с базой
      данных, мы применяем эту же философию для логики доступа к
      данным.
    </para>

    <para>
      Эти три вещи вместе &mdash; логика доступа к данным,
      бизнес-логика и логика отображения &mdash; составляют концепцию,
      которую называют шаблоном
      <emphasis>Модель-Представление-Управление</emphasis>
      (<emphasis>Model-View-Controller</emphasis>, MVC) архитектуры
      программного обеспечения. В этой концепции термин
      <quote>Модель</quote> относится к логике доступа к данным;
      термин <quote>Представление</quote> относится к той части
      системы, которая определяет, что показать и как; а термин
      <quote>Управление</quote> относится к той части системы, которая
      определяет какое представление надо использовать, в зависимости
      от пользовательского ввода, по необходимости получая доступ к
      модели.
    </para>

    <para>
      <note>
	<title>
	  Почему используется сокращение?
	</title>

	<para>
	  Целью чёткого определения сокращений, подобных MVC, является
	  упорядочивание взаимодействия между разработчиками. Вместо
	  того, чтобы сказать вашим сотрудникам: <quote>Давайте
	  использовать абстрактный доступ к данным, затем создадим слой
	  управления отображением данных и тогда создадим слой между
	  ними, который всем этим управляет</quote> можно
	  воспользоваться общим термином: <quote>Давайте здесь
	  использовать подход MVC</quote>.
	</para>
      </note>
    </para>

    <para>
      Django следует модели MVC достаточно близко, т.е., может быть
      назван MVC совместимой средой разработки. Вот примерно как M, V
      и C используются в Django:
      <itemizedlist>
	<listitem>
	  <para>
	    <emphasis>M</emphasis>, доступ к данным, обрабатывается
	    слоем работы с базой данных, который описан в этой главе.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    <emphasis>V</emphasis>, эта часть, которая определяет
	    какие данные получать и как их отображать, обрабатывается
	    представлениями и шаблонами.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    <emphasis>C</emphasis>, эта часть, которая выбирает
	    представление в зависимости от пользовательского ввода,
	    обрабатывается самой средой разработки, следуя созданной
	    вами схемой URL, и вызывает соответствующую функцию Python
	    для указанного URL.
	  </para>
	</listitem>
      </itemizedlist>
    </para>

    <para>
      Так как <quote>C</quote> обрабатывается средой разработки и всё
      интересное в Django происходит в моделях, шаблонах и
      представлениях, на Django ссылаются как на
      <emphasis>MTV-ориентированную среду разработки</emphasis>. В
      MTV-подходе к разработке:
      <itemizedlist>
	<listitem>
	  <para>
	    <emphasis>M</emphasis> определено для
	    <quote>Модели</quote> (Model), слоя доступа к данным. Этот
	    слой знает всё о данных: как получить к ним доступ, как
	    проверить их, как с ними работать и как данные связаны
	    между собой.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    <emphasis>T</emphasis> определено для
	    <quote>Шаблона</quote> (Template), слоя представления
	    данных. Этот слой принимает решения относительно
	    представления данных: как и что должно отображаться на 
	    странице или в другом типе документа.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    <emphasis>V</emphasis> определено для
	    <quote>Представления</quote> (View), слоя
	    бизнес-логики. Этот слой содержит логику, как получать
	    доступ к моделям и применять соответствующий шаблон. Вы
	    можете рассматривать его как мост между моделями и
	    шаблонами.
	  </para>
	</listitem>
      </itemizedlist>
    </para>

    <para>
      Если вам приходилось работать с другими MVC ориентированными
      средами разработки, такими как Ruby on Rails, вы можете
      рассматривать представления в Django как
      <quote>контролёры</quote>, а шаблоны Django &mdash; как
      <quote>представления</quote>. Это печальная путаница возникла в
      результате различных толкований MVC. В интерпретации Django
      <quote>представление</quote> описывает данные, которые будут
      представлены пользователю. Неважно <emphasis>как</emphasis> эти
      данные будут выглядеть, важно <emphasis>какие</emphasis>
      данные. Напротив, в Ruby on Rails и подобных ему средах
      предполагается, что в работу контролёра включено принятие
      решения, какие данные будут представлены пользователю, в то
      время как представление точно определяет
      <emphasis>как</emphasis> эти данные будут выглядеть, а не
      <emphasis>какие</emphasis> данные будут представлены.
    </para>

    <para>
      Ни одна интерпретация не имеет преимуществ над другой. Важно
      понимать основную концепцию.
    </para>

  </section>

  <section id="&BASEID;.dbconfig">

    <title id="&BASEID;.dbconfig.title">
      Настройка базы данных
    </title>

    <para>
      Учитывая вышеописанную философию, начнём исследовать слой Django
      для работы с базой данных. Первое, что нам понадобится &mdash;
      необходимо позаботиться о начальной настройке. Необходимо
      указать Django какой сервер базы данных использовать и как к
      нему подключаться.
    </para>

    <para>
      <note>
	<title>
	  Используем кодировку UTF-8, пример для MySQL
	</title>

	<para>
	  Откроем на редактирование файл
	  <filename>/etc/mysql/my.cnf</filename>.
	</para>

	<para>
	  В конец секции <token>[client]</token> добавим строчку:
	  <screen>
default-character-set=utf8
	  </screen>
	</para>

	<para>
	  В конец секции <token>[mysqld]</token> добавим строчки:
	  <screen>
default-character-set=utf8
collation_server=utf8_unicode_ci
	  </screen>
	</para>

	<para>
	  Теперь следует перезапустить сервер базы данных и можно
	  приступать к созданию самой базы.
	</para>
      </note>
    </para>

    <para>
      <note>
	<title>
	  Проверка настроек кодировки
	</title>

	<para>
	  В результате вышеописанных действий вы должны получить:
	  <screen>
	    <![CDATA[
mysql> show variables like 'coll%';
+----------------------+-----------------+
| Variable_name        | Value           |
+----------------------+-----------------+
| collation_connection | utf8_general_ci |
| collation_database   | utf8_unicode_ci |
| collation_server     | utf8_unicode_ci |
+----------------------+-----------------+
3 rows in set (0.00 sec)

mysql> show variables like 'char%';
+--------------------------+----------------------------+
| Variable_name            | Value                      |
+--------------------------+----------------------------+
| character_set_client     | utf8                       |
| character_set_connection | utf8                       |
| character_set_database   | utf8                       |
| character_set_filesystem | binary                     |
| character_set_results    | utf8                       |
| character_set_server     | utf8                       |
| character_set_system     | utf8                       |
| character_sets_dir       | /usr/share/mysql/charsets/ |
+--------------------------+----------------------------+
8 rows in set (0.00 sec)
	    ]]>
	  </screen>
	</para>
      </note>
    </para>

    <para>
      Мы предполагаем, что вы уже установили сервер базы данных,
      запустили его и создали базу данных внутри. Пример для MySQL:
      <screen>
CREATE USER user@localhost IDENTIFIED BY "topsecret";
CREATE DATABASE mysite;
GRANT ALL ON mysite.* TO user@localhost;
      </screen>
    </para>

    <para>
      Использование SQLite является особым случаем: не требуется
      создавать базу данных, так как SQLite использует файлы на
      файловой системе для хранения своих данных.
    </para>

    <para>
      Подобно параметру <varname>TEMPLATE_DIRS</varname> из предыдущей
      главы, по умолчанию параметры соединения с базой данных
      определяются в файле конфигурации проекта,
      <filename>settings.py</filename>. Отредактируйте этот файл и
      посмотрите на настройки базы данных:
      <screen>
DATABASE_ENGINE = ''
DATABASE_NAME = ''
DATABASE_USER = ''
DATABASE_PASSWORD = ''
DATABASE_HOST = ''
DATABASE_PORT = ''
      </screen>
    </para>

    <para>
      Опишем каждый параметр:
      <itemizedlist>
	<listitem>
	  <para>
	    Параметр <varname>DATABASE_ENGINE</varname> указывает тип
	    базы данных. Может быть одним из показанных в таблице
	    <quote><xref linkend="&BASEID;.tbl1"
	    endterm="&BASEID;.tbl1.title"/></quote>.
	  </para>

	  <para>
	    <table id="&BASEID;.tbl1" frame="all" pgwide="1">

	      <title id="&BASEID;.tbl1.title">
		Настройки драйвера базы данных
	      </title>

	      <tgroup cols="3" align="left" colsep="1" rowsep="1">
	      <colspec colname="c1" colwidth="4cm"/>
	      <colspec colname="c2" colwidth="4cm"/>
	      <colspec colname="c3" colwidth="6cm"/>

	      <thead>
		<row>
		  <entry>Значение</entry>
		  <entry>База данных</entry>
		  <entry>Драйвер</entry>
		</row>
	      </thead>

	      <tbody>
		<row>
		  <entry><token>postgresql</token></entry>
		  <entry>PostgreSQL</entry>
		  <entry>
		    <token>psycopg</token> версия 1.х, <ulink
		    url="http://www.djangoproject.com/r/python-pgsql/1/"/>
		  </entry>
		</row>

		<row>
		  <entry><token>postgresql_psycopg2</token></entry>
		  <entry>PostgreSQL</entry>
		  <entry>
		    <token>psycopg</token> версия 2.х, <ulink
		    url="http://www.djangoproject.com/r/python-pgsql/"/>
		  </entry>
		</row>

		<row>
		  <entry><token>mysql</token></entry>
		  <entry>MySQL</entry>
		  <entry>
		    <token>MySQLdb</token>, <ulink
		    url="http://www.djangoproject.com/r/python-mysql/"/>
		  </entry>
		</row>

		<row>
		  <entry><token>sqlite3</token></entry>
		  <entry>SQLite</entry>
		  <entry>
		    При использовании Python 2.5+ драйвер не нужен. В
		    противном случае <ulink
		    url="http://www.djangoproject.com/r/python-sqlite/"/>
		  </entry>
		</row>

		<row>
		  <entry><token>ado_mssql</token></entry>
		  <entry>Microsoft SQL Server</entry>
		  <entry>
		    <token>adodbapi</token>, версия 2.0.1+, <ulink
		    url="http://www.djangoproject.com/r/python-ado/"/>
		  </entry>
		</row>

		<row>
		  <entry><token>oracle</token></entry>
		  <entry>Oracle</entry>
		  <entry>
		    <token>cx_Oracle</token>, <ulink
		    url="http://www.djangoproject.com/r/python-oracle/"/>
		  </entry>
		</row>
	      </tbody>
	      </tgroup>
	    </table>
	  </para>

	  <para>
	    Следует отметить, что для работы с базой данных
	    потребуется скачать и установить соответствующий
	    драйвер. Каждый описанный драйвер доступен бесплатно,
	    просто проследуйте по ссылке.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Параметр <varname>DATABASE_NAME</varname> указывает Django
	    имя вашей базы данных. Если вы использует SQLite, укажите
	    полный путь к файлу базы данных на файловой системе (т.е.,
	    <filename>/home/django/mydata.db</filename>).
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Параметр <varname>DATABASE_USER</varname> указывает Django
	    какое имя надо использовать при соединении с базой
	    данных. Если вы используете SQLite, оставьте этот параметр
	    пустым.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Параметр <varname>DATABASE_PASSWORD</varname> указывает
	    Django какой пароль надо использовать при соединении с
	    базой данных. Если вы используете SQLite, оставьте этот
	    параметр пустым.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Параметр <varname>DATABASE_HOST</varname> указывает Django
	    какое имя сервера надо использовать при соединении с базой
	    данных. Если база данных находится на том же компьютере
	    (т.е., <token>localhost</token>), оставьте параметр
	    пустым. Если вы используете SQLite, оставьте этот параметр
	    пустым.
	  </para>

	  <para>
	    MySQL является особым случаем. Если значение этого
	    параметра начинается с прямого слэша (<token>/</token>) и
	    вы используете MySQL, то соединение будет произведено
	    через UNIX сокет, например:
	    <screen>
DATABASE_HOST = '/var/run/mysql'
	    </screen>
	  </para>

	  <para>
	    Если вы используете MySQL и этот параметр <emphasis>не
	    начинается</emphasis> с прямого слэша, то значение
	    параметра считается именем сервера с базой данных.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Параметр <varname>DATABASE_PORT</varname> указывает Django
	    какой порт надо использовать при соединении с базой
	    данных. Если вы используете SQLite, оставьте этот параметр
	    пустым. В противном случае, соответствующий драйвер базы
	    данных будет использовать стандартный (для конкретной базы
	    данных) порт. В большинстве случаев используется
	    стандартный порт, можете оставить этот параметр пустым.
	  </para>
	</listitem>
      </itemizedlist>
    </para>

    <para>
      После заполнения этих параметров, проверьте свою
      конфигурацию. Сначала, из каталога проекта
      (<filename>mysite</filename>), созданного в главе <quote><xref
      linkend="djangobook.chap02.startproject"
      endterm="djangobook.chap02.startproject.title"/></quote>,
      запустите команду <command>python manage.py shell</command>.
    </para>

    <para>
      Вы можете подумать, что происходит запуск интерактивного
      интерпретатора Python. Но это не так. Существует важная разница
      между запуском команды <command>python manage.py shell</command>
      в каталоге проекта Django и запуском интерпретатора. Команда
      указывает Django какой файл настроек надо использовать перед
      стартом интерпретатора. Ключевым требованием к выполнению
      запросов к базе данных является необходимость Django прочитать
      настройки соединения из конфигурационного файла.
    </para>

    <para>
      Проще говоря, команда <command>python manage.py shell</command>
      просто предполагает, что файл настроек находится в том же
      каталоге, что и скрипт <filename>manage.py</filename>. Также
      существуют другие способы указания какой файл конфигурации надо
      использовать, но их мы рассмотрим позже.
    </para>

    <para>
      После входа в оболочку интерпретатора выполните следующие
      команды для проверки введённых настроек доступа к базе данных:
      <screen>
&gt;&gt;&gt; from django.db import connection
&gt;&gt;&gt; cursor = connection.cursor()
      </screen>
    </para>

    <para>
      Если ничего не произойдёт, то вы правильно указали настройки
      доступа. В противном случае, проверьте сообщение об ошибке,
      которое описывает, что произошло. Таблица <quote><xref
      linkend="&BASEID;.tbl2" endterm="&BASEID;.tbl2.title"/></quote>
      содержит некоторые стандартные ошибки.
    </para>

    <para>
      <table id="&BASEID;.tbl2" frame="all" pgwide="1">

	<title id="&BASEID;.tbl2.title">
	  Сообщения об ошибках в конфигурации доступа к базе данных
	</title>

	<tgroup cols="2" align="left" colsep="1" rowsep="1">

	  <colspec colname="c1" colwidth="7cm"/>
	  <colspec colname="c2" colwidth="7cm"/>

	  <thead>
	    <row rowsep="1">
	      <entry>Сообщение об ошибке</entry>
	      <entry>Решение</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry>
		Вы не определили значение параметра
		<varname>DATABASE_ENGINE</varname>. (You haven't set
		the DATABASE_ENGINE setting yet.)
	      </entry>
	      <entry>
		Установите значение параметра
		<varname>DATABASE_ENGINE</varname>. Не оставляйте его
		пустым.
	      </entry>
	    </row>

	    <row>
	      <entry>
		Не определена переменная среды
		<varname>DJANGO_SETTINGS_MODULE</varname>. (Environment
		variable DJANGO_SETTINGS_MODULE is undefined.)
	      </entry>
	      <entry>
		Запустите команду <command>python manage.py
		shell</command> вместо <command>python</command>.
	      </entry>
	    </row>

	    <row>
	      <entry>
		Ошибка при загрузке модуля _____. Нет модуля с именем
		_____. (Error loading _____ module: No module named
		_____.)
	      </entry>
	      <entry>
		Вы не установили соответствующий драйвер базы данных,
		т.е. <token>psycopg</token> или
		<token>MySQLdb</token>.
	      </entry>
	    </row>

	    <row>
	      <entry>
		_____ не является доступным драйвером базы
		данных. (_____ isn't an available database backend.
	      </entry>
	      <entry>
		Установите параметр
		<varname>DATABASE_ENGINE</varname>, указав
		используемую базу данных, как было описано
		ранее. Возможно вы опечатались?
	      </entry>
	    </row>

	    <row>
	      <entry>
		База данных _____ не существует. (database _____ does
		not exist.)
	      </entry>
	      <entry>
		Измените параметр <varname>DATABASE_NAME</varname>,
		чтобы он указывал на существующую базу данных, или
		выполните соответствующую команду <command>CREATE
		DATABASE</command> для создания базы данных.
	      </entry>
	    </row>

	    <row>
	      <entry>
		Роль _____ не существует. (role _____ does not exist.)
	      </entry>
	      <entry>
		Измените параметр <varname>DATABASE_USER</varname>,
		чтобы он указывал на существующего пользователя или
		создайте соответствующего пользователя в базе данных.
	      </entry>
	    </row>

	    <row>
	      <entry>
		Не могу подключиться к серверу. (could not connect to
		server.)
	      </entry>
	      <entry>
		Удостоверьтесь, что параметры
		<varname>DATABASE_HOST</varname> и
		<varname>DATABASE_PORT</varname> установлены
		правильно, а также, что сервер баз данных работает.
	      </entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>
    </para>
	    
  </section>

  <section id="&BASEID;.firstapp">

    <title id="&BASEID;.firstapp.title">
      Ваше первое приложение
    </title>

    <para>
      После того, как вы проверили работоспособность соединения с
      базой данных, пришло время создать
      <emphasis>Django-приложение</emphasis> &mdash; код, включающий в
      себя модели и представления, который объединён в один пакет
      Python и представляет собой цельное Django-приложение.
    </para>

    <para>
      Удобно согласовать терминологию здесь, это поможет новичкам. В
      главе <quote><xref linkend="djangobook.chap02.startproject"
      endterm="djangobook.chap02.startproject.title"/></quote> мы
      создали проект, но в чём же разница между проектом и
      приложением? Разница в том, что первое является конфигурацией, а
      второе &mdash; кодом:
      <itemizedlist>
	<listitem>
	  <para>
	    Проект &mdash; это экземпляр определённого набора кода
	    Django-приложений и конфигурация для этих приложений.
	  </para>
	  
	  <para>
	    С технической точки зрения существует одно требование к
	    проекту &mdash; наличие файла конфигурации, который
	    определяет способ соединения с базой данных, список
	    установленных приложений, каталог с шаблонами и так далее.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Приложение &mdash; это переносимый набор некой
	    функциональности, обычно включает в себя модели и
	    представления, которые хранятся вместе в едином пакете
	    языка Python.
	  </para>

	  <para>
	    Например, Django поставляется с рядом приложений, таких
	    как система комментирования и автоматический интерфейс
	    администратора. Важной особенностью этих приложений
	    является то, что они переносимы и их можно использовать во
	    множестве проектов.
	  </para>
	</listitem>
      </itemizedlist>
    </para>

    <para>
      Существует очень мало жёстких правил для соответствия вашего
      кода этой схеме. Если вы создаёте простой сайт, вы можете
      использовать единственное приложение. Если вы создаёте сложный
      сайт с несколькими независимыми частями, такими как
      интернет-магазин и форум, возможно вы пожелаете разнести их в
      отдельные приложения, что позволит использовать их раздельно в
      других проектах.
    </para>

    <para>
      В действительности нет нужды создавать приложения вообще, как
      это видно из примера функций представления, которые мы создали
      ранее. Для тех случаев мы просто создали файл с именем
      <filename>views.py</filename>, который содержал код функций
      представления и создали схему URL для этих функций. Никакое
      <quote>приложение</quote> нам для этого не понадобилось.
    </para>

    <para>
      Тем не менее, существует одно требование относящееся к
      приложениям: если вы используете Django API для работы с базой
      данных, то вы обязаны создать приложение. Модели должны
      находиться внутри приложения. Следовательно, для того, чтобы
      начать описывать наши модели нам потребуется создать новое
      приложение.
    </para>

    <para>
      Выполните нижеприведённую команду для создания нового приложения
      с именем <token>books</token> в каталоге проекта
      <filename>mysite</filename>, который мы создали в главе
      <quote><xref linkend="djangobook.chap02.startproject"
      endterm="djangobook.chap02.startproject.title"/></quote>:
      <screen>
python manage.py startapp books
      </screen>
    </para>

    <para>
      Эта команда ничего не выводит, она создаёт каталог
      <filename>books</filename> в каталоге
      <filename>mysite</filename>. Давайте глянем на содержимое этого
      каталога:
      <screen>
books/
    __init__.py
    models.py
    views.py
      </screen>
    </para>

    <para>
      Эти файлы будут содержать модели и представления для приложения.
    </para>

    <para>
      Посмотрите с помощью вашего текстового редактора файлы
      <filename>models.py</filename> и
      <filename>views.py</filename>. Оба файла сейчас пустые, исключая
      импорт в <filename>models.py</filename>. Это каркас для вашего
      приложения.
    </para>

  </section>

  <section id="&BASEID;.defmodels">

    <title id="&BASEID;.defmodels.title">
      Определение моделей в Python
    </title>

    <para>
      Как мы рассказывали в этой главе ранее, буква <quote>M</quote> в
      <token>MTV</token> определяет слово <quote>Модель</quote>
      (Model). Модель в Django &mdash; это описание данных, которые
      хранятся в базе данных, выполненное в виде кода на языке
      Python. Это форма ваших данных &mdash; эквивалент SQL операторов
      <command>CREATE TABLE</command> &mdash; только описана она на
      языке Python вместо SQL и включает в себя не только определение
      столбцов в базе данных. Django использует модель для фонового
      выполнения SQL и возвращает удобные структуры Python с данными,
      представляющими записи в таблицах вашей базы данных. Django
      также использует модели для представления высокоуровневых
      концепций, которые SQL вряд ли сможет обработать.
    </para>

    <para>
      Если вы уже работали с базами данных, вы могли подумать:
      <quote>Зачем дублировать определение моделей данных в Python
      <emphasis>и</emphasis> в SQL?</quote> Django действует таким
      образом по нескольким причинам:
      <itemizedlist>
	<listitem>
	  <para>
	    Самодиагностика занимает ресурсы и несовершенна. Для того,
	    чтобы предоставить удобный API для доступа к данным,
	    Django должна <emphasis>как-то</emphasis> получить
	    информацию о содержимом базы данных и существует два
	    способа сделать это. Первый: можно явно описать данные в
	    Python. Второй: самодиагностика базы данных при работе
	    приложения для определения моделей данных.
	  </para>

	  <para>
	    Второй способ кажется более очевидным, так как метаданные
	    в ваших таблицах хранятся в одном месте, но он приводит к
	    нескольким проблемам. Первое, самодиагностика базы данных
	    во время работы приложения потребляет ресурсы. Если среде
	    разработки потребуется проверять структуру базы данных при
	    выполнении каждого запроса, или хотя бы при каждом запуске
	    веб-сервера, вы получите значительную нагрузку на ресурсы
	    сервера. (В то время как некоторые считают такую нагрузку
	    приемлемой, разработчики Django нацелены на максимально
	    возможную скорость работы среды. И этот подход успешно
	    решает задачу обгона конкурентов в тестах.) Во-вторых,
	    некоторые базы данных, особенно старые версии MySQL, не
	    сохраняют достаточно метаинформации для точной и полной
	    самодиагностики.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Разрабатывать с помощью Python прикольно и хранение всего
	    в виде его кода сокращает число <quote>переключений
	    контекста</quote>, которые приходится делать вашему
	    мозгу. Если придерживаться единой среды
	    разработки/менталитета, это повысит продуктивность
	    работы. Необходимость писать SQL, затем код Python, а
	    потом опять SQL, отрицательно сказывается на
	    производительности разработчика.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Когда модели данных хранятся в виде кода, а не в базе
	    данных, это упрощает управление версиями этих моделей. Это
	    поможет вам хранить историю всех изменений моделей.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    SQL позволяет лишь определённый уровень хранения
	    метаинформации о формате данных. Большинство систем
	    управления базами данных не предоставляют
	    специализированных типов данных для представления адресов
	    электронной почты или URL. Модели Django
	    предоставляют. Преимущество высокоуровневых типов данных в
	    улучшении продуктивности и в большем повторном
	    использовании кода.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    SQL несовместим между разными платформами баз данных. При
	    распространении веб-приложения, более практично передавать
	    модуль на языке Python, который описывает формат ваших
	    данных, вместо отдельных наборов операторов
	    <command>CREATE TABLE</command> для MySQL, PostgreSQL и
	    SQLite.
	  </para>
	</listitem>
      </itemizedlist>
    </para>

    <para>
      Недостаток такого подхода, тем не менее, в том, что есть
      возможность для кода Python выйти из синхронизации с содержимым
      базы данных. При внесении изменений в модель, вам потребуется
      также изменить содержимое базы данных. Мы рассмотрим некоторые
      стратегии для решения этой проблемы далее в этой главе.
    </para>

    <para>
      Наконец, мы должны отметить, что Django включает в себя утилиту,
      которая может генерировать модели по метаинформации существующей
      базы данных. Это полезно для быстрого получения и начала работы
      с уже существующей информацией.
    </para>

  </section>

  <section id="&BASEID;.firstmodel">

    <title id="&BASEID;.firstmodel.title">
      Ваша первая модель
    </title>

    <para>
      В качестве постоянного примера в этой и следующих главах мы
      сосредоточимся на простом формате данных: книга, автор,
      издатель. Мы используем это в качестве нашего примера, потому
      что концептуальные взаимоотношения между этими понятиями широко
      известны и потому что этот общий формат данных используется в
      книгах по SQL. Вы также читаете книгу, которая создана авторами
      и напечатана издателем!
    </para>

    <para>
      Мы предположим следующие концепции, поля и взаимоотношения:
      <itemizedlist>
	<listitem>
	  <para>
	    Автор имеет звание (господин, госпожа, товарищ), имя,
	    фамилию, адрес электронной почты и фотографию.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Издатель имеет имя, адрес, город, область, страну и сайт.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Книга имеет название и дату издания. Она также имеет
	    одного или нескольких авторов (с авторами отношение
	    многие-ко-многим) и одного издателя (отношение
	    один-к-многим, как внешний ключ, к издателям).
	  </para>
	</listitem>
      </itemizedlist>
    </para>

    <para>
      Первым шагом в использовании этой схемы базы данных будет её
      выражение в виде кода Python. В файл
      <filename>models.py</filename>, который был создан командой
      <command>startapp</command>, добавьте следующее:
      <screen>
from django.db import models

class Publisher(models.Model):
    name = models.CharField(max_length=30)
    address = models.CharField(max_length=50)
    city = models.CharField(max_length=60)
    state_province = models.CharField(max_length=30)
    country = models.CharField(max_length=50)
    website = models.URLField()

class Author(models.Model):
    salutation = models.CharField(max_length=10)
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=40)
    email = models.EmailField()
    headshot = models.ImageField(upload_to='/tmp')

class Book(models.Model):
    title = models.CharField(max_length=100)
    authors = models.ManyToManyField(Author)
    publisher = models.ForeignKey(Publisher)
    publication_date = models.DateField()
      </screen>
    </para>

    <para>
      Быстро рассмотрим этот код, чтобы разобраться с
      основами. Первое, что следует отметить &mdash; каждая модель
      представлена в виде класса Python, который является потомком
      класса
      <token>django.db.models.</token><classname>Model</classname>. Родительский
      класс, <classname>Model</classname>, содержит всю необходимую
      функциональность для обеспечения работы объектов с базой
      данных. Таким образом наши модели несут полную ответственность
      за определение полей в кратком понятном виде. Верите или нет, но
      это весь код, который необходим для получения простого доступа к
      данным с помощью Django.
    </para>

    <para>
      Обычно каждая модель соответствует одной таблице в базе данных
      и, обычно, каждый атрибут модели соответствует столбцу в
      таблице. Имя атрибута модели соответствует имени столбца
      таблицы, а тип атрибута (т.е., <token>CharField</token>)
      соответствует типу столбца (т.е.,
      <token>varchar</token>). Например, модель
      <classname>Publisher</classname> эквивалентна следующей таблице
      (в синтаксисе для PostgreSQL):
      <screen>
CREATE TABLE "books_publisher" (
    "id" serial NOT NULL PRIMARY KEY,
    "name" varchar(30) NOT NULL,
    "address" varchar(50) NOT NULL,
    "city" varchar(60) NOT NULL,
    "state_province" varchar(30) NOT NULL,
    "country" varchar(50) NOT NULL,
    "website" varchar(200) NOT NULL
);
      </screen>
    </para>

    <para>
      На самом деле Django может сгенерировать такой оператор
      <token>CREATE TABLE</token> автоматически, мы это скоро покажем.
    </para>

    <para>
      Исключением из правила <quote>один класс для одной
      таблицы</quote> является случай отношения
      <quote>многие-ко-многим</quote>. В нашем примере
      <token>Book</token> имеет такое поле &mdash;
      <token>authors</token>. Это означает, что книга имеет одного или
      более авторов, но таблица <token>Book</token> не получает такого
      столбца, Django создаёт дополнительную таблицу, которая
      применяется для обеспечения этой функциональности.
    </para>

    <para>
      Полный список типов полей и опций синтаксиса моделей приведены в
      Приложении <quote><xref linkend="djangobook.appendix_b"
      endterm="djangobook.appendix_b.title"/></quote>.
    </para>

    <para>
      Наконец, следует отметить, что мы нигде явно не определяли
      первичные ключи. Если специально не запрещать, то Django
      автоматически создаёт поле <token>id</token> для таблицы каждой
      модели. Необходимо, чтобы каждая модель Django имела первичный
      ключ, созданный по одному полю.
    </para>

  </section>

  <section id="&BASEID;.install">

    <title id="&BASEID;.install.title">
      Установка модели
    </title>

    <para>
      Мы написали код. Давайте создадим таблицы в нашей базе
      данных. Чтобы это сделать мы должны
      <emphasis>активировать</emphasis> модели в нашем проекте. Это
      делается с помощью добавления приложения <token>books</token> к
      списку установленных приложений в файле параметров.
    </para>

    <para>
      Откройте файл <filename>settings.py</filename> снова и
      посмотрите на параметр <varname>INSTALLED_APPS</varname>. Этот
      параметр указывает Django какие приложения активированы для
      текущего проекта. По умолчанию, параметр выглядит так:
      <screen>
INSTALLED_APPS = (
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.sites',
)
      </screen>
    </para>

    <para>
      Временно закомментируйте все четыре строки с помощью символа
      <token>#</token>. (Эти приложения были активированы для
      удобства, но мы самостоятельно активируем и обсудим их позже.)
      Не закрывая файл, измените параметры
      <varname>MIDDLEWARE_CLASSES</varname> и
      <varname>TEMPLATE_CONTEXT_PROCESSORS</varname>. Эти параметры
      зависели от приложений, которые мы закомментировали. Теперь
      добавьте <token>mysite.books</token> в список
      <varname>INSTALLED_APPS</varname>:
      <screen>
MIDDLEWARE_CLASSES = (
#    'django.middleware.common.CommonMiddleware',
#    'django.contrib.sessions.middleware.SessionMiddleware',
#    'django.contrib.auth.middleware.AuthenticationMiddleware',
#    'django.middleware.doc.XViewMiddleware',
)

TEMPLATE_CONTEXT_PROCESSORS = ()
#...

INSTALLED_APPS = (
    #'django.contrib.auth',
    #'django.contrib.contenttypes',
    #'django.contrib.sessions',
    #'django.contrib.sites',
    'mysite.books',
)
      </screen>
    </para>

    <para>
      (Раз мы здесь работаем с одно-элементным кортежем, не забудьте о
      завершающей запятой. Между прочим, авторы этой книги
      предпочитают ставить запятую после <emphasis>каждого</emphasis>
      элемента в кортеже, независимо от того, что кортеж имеет
      единственный элемент. Это помогает избежать проблемы забытых
      запятых и никак не влияет на производительность.)
    </para>

    <para>
      Элемент <token>mysite.books</token> ссылается на приложение
      <token>books</token>, над которым мы работаем. Каждое
      приложение, перечисленное в <varname>INSTALLED_APPS</varname>,
      представлено полным путём к нему &mdash; он, путь к пакетам,
      разделён точками.
    </para>

    <para>
      После того как приложение было активировано в файле конфигурации
      проекта, мы можем создать таблицы в нашей базе данных. Сначала,
      давайте проверим модели с помощью команды:
      <screen>
python manage.py validate
      </screen>
    </para>

    <para>
      Команда <token>validate</token> проверяет корректность
      синтаксиса и логики моделей. Если всё в порядке, вы увидите
      сообщение <quote>0 errors found</quote>. Если нет,
      удостоверьтесь, что вы корректно набрали код модели. Вывод
      ошибки должен дать вам полезную информацию об ошибке в коде.
    </para>

    <para>
      Каждый раз когда вам кажется, что есть проблемы с вашими моделями,
      используйте команду <command>python manage.py
      validate</command>. Она поможет выявить все стандартные
      проблемы.
    </para>

    <para>
      Если ваши модели не имеют ошибок, выполните следующую команду,
      чтобы Django сгенерировало операторы <token>CREATE TABLE</token>
      для моделей приложения <token>books</token> (с полной подсветкой
      синтаксиса, если вы используете Unix):
      <screen>
python manage.py sqlall books
      </screen>
    </para>

    <para>
      В данной команде <token>books</token> является именем
      приложения. Это имя вы указывали при выполнении команды
      <command>manage.py startapp</command>. После запуска команды вы
      должны увидеть нечто подобное:
      <screen>
	<![CDATA[
BEGIN;
CREATE TABLE "books_publisher" (
    "id" serial NOT NULL PRIMARY KEY,
    "name" varchar(30) NOT NULL,
    "address" varchar(50) NOT NULL,
    "city" varchar(60) NOT NULL,
    "state_province" varchar(30) NOT NULL,
    "country" varchar(50) NOT NULL,
    "website" varchar(200) NOT NULL
);
CREATE TABLE "books_book" (
    "id" serial NOT NULL PRIMARY KEY,
    "title" varchar(100) NOT NULL,
    "publisher_id" integer NOT NULL REFERENCES "books_publisher" ("id"),
    "publication_date" date NOT NULL
);
CREATE TABLE "books_author" (
    "id" serial NOT NULL PRIMARY KEY,
    "salutation" varchar(10) NOT NULL,
    "first_name" varchar(30) NOT NULL,
    "last_name" varchar(40) NOT NULL,
    "email" varchar(75) NOT NULL,
    "headshot" varchar(100) NOT NULL
);
CREATE TABLE "books_book_authors" (
    "id" serial NOT NULL PRIMARY KEY,
    "book_id" integer NOT NULL REFERENCES "books_book" ("id"),
    "author_id" integer NOT NULL REFERENCES "books_author" ("id"),
    UNIQUE ("book_id", "author_id")
);
CREATE INDEX books_book_publisher_id ON "books_book" ("publisher_id");
COMMIT;
	]]>
      </screen>
    </para>

    <para>
      Отметим следующее:
      <itemizedlist>
	<listitem>
	  <para>
	    Имена таблиц генерируются автоматически, комбинируется имя
	    приложения (<token>books</token>) и имя модели в нижнем
	    регистре (<token>publisher</token>, <token>book</token> и
	    <token>author</token>). Вы можете изменить это поведение,
	    подробности смотрите в приложении <quote><xref
	    linkend="djangobook.appendix_b"
	    endterm="djangobook.appendix_b.title"/></quote>.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Как мы уже упоминали, Django автоматически добавляет
	    первичный ключ для каждой таблицы &mdash; поле
	    <token>id</token>. Вы можете изменить и это.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    По правилу Django добавляет
	    <quote><token>_id</token></quote> к имени поля внешнего
	    ключа. Как вы можете предположить, вы можете изменить и
	    это поведение.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Привязка внешнего ключа явно определяется с помощью
	    оператора <token>REFERENCES</token>.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Операторы <token>CREATE TABLE</token> адаптируются к
	    используемой базе данных, таким образом специфичные типы
	    полей, такие как <token>auto_increment</token> (MySQL),
	    <token>serial</token> (PostgreSQL) или <token>integer
	    primary key</token> (SQLite) обрабатываются
	    автоматически. То же самое происходит с экранированием
	    имён полей (т.е., используются двойные или одинарные
	    кавычки). В данном примере приведён синтаксис для
	    PostgreSQL.
	  </para>
	</listitem>
      </itemizedlist>
    </para>

    <para>
      Команда <command>sqlall</command> не создаёт таблицы и никак не
      воздействует на базу данных &mdash; она просто выводит SQL
      операторы на экран и вы можете посмотреть, что будет передано в
      базу данных. Если вы пожелаете, можно вручную скопировать эти
      операторы в командную строку клиента базы данных или
      перенаправить данные в клиент напрямую. Тем не менее, Django
      предоставляет простой способ выполнения SQL в базе
      данных. Выполните команду <command>syncdb</command>:
      <screen>
python manage.py syncdb
      </screen>
    </para>

    <para>
      Вы увидите подобное:
      <screen>
Creating table books_publisher
Creating table books_book
Creating table books_author
Installing index for books.Book model
      </screen>
    </para>

    <para>
      Команда <command>syncdb</command> просто
      <emphasis>синхронизирует</emphasis> ваши модели в базе
      данных. Она просматривает все модели каждого приложения,
      указанного в параметре <varname>INSTALLED_APPS</varname>,
      проверяет наличие соответствующих таблиц в базе данных и по
      необходимости создаёт их. Следует отметить, что
      <command>syncdb</command> <emphasis>не</emphasis> синхронизирует
      изменения в моделях или удаления моделей. Если вы изменили
      модель или удалили её, то команда <command>syncdb</command> не
      поможет с внесением изменений в базу. Подробности позже.
    </para>

    <para>
      При повторном запуске команды <command>python manage.py
      syncdb</command> ничего не произойдёт, так как вы не добавили
      модели в приложение <token>books</token> или не добавили новое
      приложение в <varname>INSTALLED_APPS</varname>. Следовательно,
      безопасно запускать эту команду &mdash; она не испортит базу
      данных.
    </para>

    <para>
      Если вам интересно, то изучите подробнее клиент вашей базы
      данных и просмотрите созданную базу данных. Вы можете вручную
      запустить клиент (т.е., <command>psql</command> для PostgreSQL)
      или вы можете применить команду <command>python manage.py
      dbshell</command>, которая запускает клиент, используя параметр
      <varname>DATABASE_ENGINE</varname>. Последний вариант более
      удобен.
    </para>

  </section>

  <section id="&BASEID;.basic-access">

    <title id="&BASEID;.basic-access.title">
      Доступ к данным
    </title>

    <para>
      После создания модели Django автоматически предоставляет
      высокоуровневый API для работы с этими моделями. Изучите его,
      запустив команду <command>python manage.py shell</command> и
      набрав следующее:
      <screen>
	<![CDATA[
>>> from books.models import Publisher
>>> p1 = Publisher(name='Addison-Wesley', address='75 Arlington Street',
...     city='Boston', state_province='MA', country='U.S.A.',
...     website='http://www.apress.com/')
>>> p1.save()
>>> p2 = Publisher(name="O'Reilly", address='10 Fawcett St.',
...     city='Cambridge', state_province='MA', country='U.S.A.',
...     website='http://www.oreilly.com/')
>>> p2.save()
>>> publisher_list = Publisher.objects.all()
>>> publisher_list
[<Publisher: Publisher object>, <Publisher: Publisher object>]
	]]>
      </screen>
    </para>

    <para>
      Эти несколько строк кода выполняют немного. Вот основное:
      <itemizedlist>
	<listitem>
	  <para>
	    Для того, чтобы создать объект просто импортируйте
	    соответствующий класс модели и создайте экземпляр этого
	    класса, передав значения для каждого поля.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Чтобы сохранить объект в базе данных, вызовите метод
	    <function>save()</function>. Django выполнит для этого SQL
	    оператор <token>INSERT</token>.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Для того, чтобы получить объекты из базы данных,
	    используйте атрибут
	    <token>Publisher.objects</token>. Получить список всех
	    объектов <classname>Publisher</classname> из базы данных
	    можно с помощью метода
	    <token>objects.</token><function>all()</function>.  Django
	    выполнит SQL оператор <token>SELECT</token>.
	  </para>
	</listitem>
      </itemizedlist>
    </para>

    <para>
      Действительно, можно делать многое с помощью API для работы с
      базой данных, но сначала давайте позаботимся о небольших
      неудобствах.
    </para>

  </section>

  <section id="&BASEID;.model-representation">

    <title id="&BASEID;.model-representation.title">
      Добавляем строковое представление модели
    </title>

    <para>
      Когда мы распечатали список издателей, всё что мы получили
      &mdash; бесполезный вывод, который затрудняет понимание:
      <screen>
	<![CDATA[
[<Publisher: Publisher object>, <Publisher: Publisher object>]
	]]>
      </screen>
    </para>

    <para>
      Это можно легко исправить, добавив метод
      <function>__unicode__()</function> к нашему объекту
      <classname>Publisher</classname>. Метод
      <function>__unicode__()</function> указывает Python как
      отображать текстовое представление объекта.

      <note>
	<title>
	  Почему именно <function>__unicode__()</function>, а не
	  <function>__str__()</function>?
	</title>

	<para>
	  Обратимся к файлу
	  <filename>trunk/docs/model-api.txt</filename>. Там написано
	  следующее. Метод <function>__str__()</function> используется
	  Django в основном для отображения объекта в виде строки на
	  административном интерфейсе или в шаблоне, отображающем этот
	  объект. Следовательно, вы должны всегда предоставлять такую
	  строку для объекта. Это не обязательно, но желательно. Метод
	  <function>__unicode__()</function> делает то же самое, но
	  вот только работает с Unicode. Если для модели определён
	  метод <function>__unicode__()</function> и не определён
	  метод <function>__str__()</function>, Django автоматически
	  создаст последний метод, который будет вызывать метод
	  <function>__unicode__()</function> и возвращать корректную
	  UTF-8 строку. Раз мы не являемся <quote>семибитными жителями
	  Северной Америки</quote>, думаю, нам больше нет смысла
	  останавливаться на обсуждении метода
	  <function>__str__()</function>.
	</para>
      </note>

      Добавим этот метод к трём моделям:
      <screen>
	<![CDATA[
from django.db import models

class Publisher(models.Model):
    name = models.CharField(max_length=30)
    address = models.CharField(max_length=50)
    city = models.CharField(max_length=60)
    state_province = models.CharField(max_length=30)
    country = models.CharField(max_length=50)
    website = models.URLField()

    def __unicode__(self):
        return self.name

class Author(models.Model):
    salutation = models.CharField(max_length=10)
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=40)
    email = models.EmailField()
    headshot = models.ImageField(upload_to='/tmp')

    def __unicode__(self):
        return '%s %s' % (self.first_name, self.last_name)

class Book(models.Model):
    title = models.CharField(max_length=100)
    authors = models.ManyToManyField(Author)
    publisher = models.ForeignKey(Publisher)
    publication_date = models.DateField()

    def __unicode__(self):
        return self.title
	]]>
      </screen>
    </para>

    <para>
      Как видно, метод <function>__unicode__()</function> может делать
      всё необходимое для того, чтобы возвратить строковое
      представление. В данном случае, методы
      <function>__unicode__()</function> для
      <classname>Publisher</classname> и <classname>Book</classname>
      просто возвращают имя объекта и заголовок, соответственно, но
      метод <function>__unicode__()</function> для
      <classname>Author</classname> более сложный &mdash; он
      объединяет поля <token>first_name</token> и
      <token>last_name</token>. Единственное требование к методу
      <function>__unicode__()</function> &mdash; он должен возвращать
      строку. В противном случае, когда метод возвращает целое число,
      Python вызовет исключение <token>TypeError</token> с сообщением
      <quote>__unicode__ returned non-string</quote>.
    </para>

    <para>
      Для того, чтобы эти изменения вступили в силу надо выйти из
      оболочки и запустить её снова командой <command>python manage.py
      shell</command>. (Это самый простой способ для активации
      изменений.) Теперь список объектов
      <classname>Publisher</classname> более понятен:
      <screen>
	<![CDATA[
>>> from books.models import Publisher
>>> publisher_list = Publisher.objects.all()
>>> publisher_list
[<Publisher: Addison-Wesley>, <Publisher: O'Reilly>]
	]]>
      </screen>
    </para>

    <para>
      Удостоверьтесь, что каждая определённая вами модель имеет метод
      <function>__unicode__()</function>. Это необходимо не только для
      вашего удобства, но и потому что Django использует результат
      вызова этого метода при отображении объектов.
    </para>

    <para>
      Наконец, следует отметить, что <function>__unicode__()</function>
      является хорошим примером добавления <emphasis>нового
      поведения</emphasis> моделям. Модель Django описывает большее
      чем просто таблицу для объекта, она также описывает всю
      функциональность этого объекта. Метод
      <function>__unicode__()</function> является одним из примеров такой
      функциональности &mdash; модель знает как отображать себя.
    </para>

  </section>

  <section id="&BASEID;.insert-update">

    <title id="&BASEID;.insert-update.title">
      Вставка и изменение данных
    </title>

    <para>
      Вы уже видели как это делается: для того, чтобы вставить запись
      в вашу базу данных сначала надо создать экземпляр модели с
      помощью именованных аргументов, вот так:
      <screen>
	<![CDATA[
>>> p = Publisher(name='Apress',
...         address='2855 Telegraph Ave.',
...         city='Berkeley',
...         state_province='CA',
...         country='U.S.A.',
...         website='http://www.apress.com/')
	]]>
      </screen>
    </para>

    <para>
      Этот пример создания экземпляра модели <emphasis>не</emphasis>
      производит изменений в базе данных.
    </para>

    <para>
      Для того, чтобы сохранить запись в базе данных (т.е., выполнить
      SQL оператор <token>INSERT</token>) используйте метод
      <function>save()</function>:
      <screen>
	<![CDATA[
>>> p.save()
	]]>
      </screen>
    </para>

    <para>
      Вышеприведённые действия с точки зрения SQL операторов выглядят
      так:
      <screen>
	<![CDATA[
INSERT INTO book_publisher
    (name, address, city, state_province, country, website)
VALUES
    ('Apress', '2855 Telegraph Ave.', 'Berkeley', 'CA',
     'U.S.A.', 'http://www.apress.com/');
	]]>
      </screen>
    </para>

    <para>
      Так как модель <classname>Publisher</classname> использует
      автоматически увеличивающийся первичный ключ <token>id</token>,
      первый вызов метода <function>save()</function> выполнит ещё и
      вычисление значения для первичного ключа и подставит это
      значение в атрибут <token>id</token>:
      <screen>
	<![CDATA[
>>> p.id
52    # значение может отличаться для ваших данных
	]]>
      </screen>
    </para>

    <para>
      Последующие вызовы метода <function>save()</function> будут
      перезаписывать существующую запись, не создавая новую (т.е.,
      будут выполнять SQL оператор <token>UPDATE</token> вместо
      <token>INSERT</token>):
      <screen>
	<![CDATA[
>>> p.name = 'Apress Publishing'
>>> p.save()
	]]>
      </screen>
    </para>

    <para>
      В SQL это будет выглядеть так:
      <screen>
	<![CDATA[
UPDATE book_publisher SET
    name = 'Apress Publishing',
    address = '2855 Telegraph Ave.',
    city = 'Berkeley',
    state_province = 'CA',
    country = 'U.S.A.',
    website = 'http://www.apress.com'
WHERE id = 52;
	]]>
      </screen>
    </para>

  </section>

  <section id="&BASEID;.select">

    <title id="&BASEID;.select.title">
      Выборка объектов
    </title>

    <para>
      Создавать и изменять данные несомненно прикольно, но также это
      бесполезно при отсутствии способа анализировать эти данные. Мы
      уже знаем способ получения всех данных определённой модели:
      <screen>
	<![CDATA[
>>> Publisher.objects.all()
[<Publisher: Addison-Wesley>, <Publisher: O'Reilly>, <Publisher: Apress Publishing>]
	]]>
      </screen>
    </para>

    <para>
      В общих чертах в SQL это выглядит так:
      <screen>
	<![CDATA[
SELECT
    id, name, address, city, state_province, country, website
FROM book_publisher;
	]]>
      </screen>
    </para>

    <para>
      <note>
	<para>
	  Следует отметить, что Django не использует <token>SELECT
	  *</token> при просмотре данных, а вместо этого явно
	  перечисляет все поля. Так было задумано изначально: в
	  некоторых случаях использование <token>SELECT *</token>
	  может повлиять на производительность, а главное,
	  перечисление полей более соответствует нормам Искусства
	  программирования на языке Python: <quote>Явное лучше
	  неявного</quote>.
	</para>

	<para>
	  Для получения более подробной информации об Искусстве
	  программирования на языке Python выполните в консоли Python
	  команду <command>import this</command>.
	</para>
      </note>
    </para>

    <para>
      Теперь внимательно рассмотрим строку
      <token>Publisher.objects.all()</token>:
      <itemizedlist>
	<listitem>
	  <para>
	    Сначала у нас есть определённая нами модель
	    <classname>Publisher</classname>. Ничего удивительного:
	    при необходимости получить доступ к данным вы используете
	    модель.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Затем мы работаем с <token>objects</token>. Технически
	    этот объект можно назвать
	    <emphasis>менеджером</emphasis>. Менеджеры более подробно
	    будут описаны в приложении <quote><xref
	    linkend="djangobook.appendix_b"
	    endterm="djangobook.appendix_b.title"/></quote>. Сейчас
	    вам надо знать только то, что менеджеры отвечают за
	    операции <quote>табличного уровня</quote> над данными, что
	    самое главное, включая операции выборки данных.
	  </para>

	  <para>
	    Все модели автоматически получают менеджер
	    <token>objects</token>. Он используется при каждом доступе
	    к данным.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Наконец, у нас есть <function>all()</function>. Это метод
	    объекта <token>objects</token>, который возвращает все
	    записи, относящиеся к этой модели, из базы
	    данных. Несмотря на то, что этот объект
	    <emphasis>выглядит</emphasis> как список, в
	    действительности это <emphasis>набор данных
	    (QuerySet)</emphasis> &mdash; объект, который представляет
	    собой набор записей из базы данных. Набор данных описан в
	    приложении <quote><xref linkend="djangobook.appendix_c"
	    endterm="djangobook.appendix_c.title"/></quote>. В
	    оставшейся части этой главы мы будем рассматривать этот
	    набор как список.
	  </para>
	</listitem>
      </itemizedlist>
    </para>

    <para>
      Любая выборка из базы данных работает по определённому шаблону
      &mdash; мы используем методы менеджера, который подключен к
      модели, по которой производится выборка.
    </para>

    <section id="&BASEID;.select.filtering">

      <title id="&BASEID;.select.filtering.title">
	Фильтрация данных
      </title>

      <para>
	При выполнении полных выборок данных, чаще всего мы желаем
	работать с ограниченным набором данных. Мы можем осуществить
	это с помощью метода <function>filter()</function>:
	<screen>
	  <![CDATA[
>>> Publisher.objects.filter(name="Apress Publishing")
[<Publisher: Apress Publishing>]
	  ]]>
	</screen>
      </para>

      <para>
	Метод <function>filter()</function> принимает именованные
	аргументы, которые преобразуются в соответствующие SQL-условия
	<token>WHERE</token>. Предыдущий пример будет преобразован в
	нечто подобное:
	<screen>
	  <![CDATA[
SELECT
    id, name, address, city, state_province, country, website
FROM book_publisher
WHERE name = 'Apress Publishing';
	  ]]>
	</screen>
      </para>

      <para>
	Вы можете передать множество аргументов в
	<function>filter()</function> для сокращения диапазона
	выборки:
	<screen>
	  <![CDATA[
>>> Publisher.objects.filter(country="U.S.A.", state_province="CA")
[<Publisher: Apress Publishing>]
	  ]]>
	</screen>
      </para>

      <para>
	Множество аргументов будут объединены с помощью SQL операторов
	<token>AND</token>. Пример станет таким:
	<screen>
	  <![CDATA[
SELECT
    id, name, address, city, state_province, country, website
FROM book_publisher
WHERE country = 'U.S.A.' AND state_province = 'CA';
	  ]]>
	</screen>
      </para>

      <para>
	Следует отметить, что по умолчанию выборка использует SQL
	оператор <token>=</token> для точного совпадения. Также можно
	выполнять другие виды запросов:
	<screen>
	  <![CDATA[
>>> Publisher.objects.filter(name__contains="press")
[<Publisher: Apress Publishing>]
	  ]]>
	</screen>
      </para>

      <para>
	Обратите внимание на двойное подчёркивание между
	<token>name</token> и <token>contains</token>. Подобно Python
	это используется Django для выполнения
	<quote>магических</quote> действий. В данном случае таких:
	<screen>
	  <![CDATA[
SELECT
    id, name, address, city, state_province, country, website
FROM book_publisher
WHERE name LIKE '%press%';
	  ]]>
	</screen>
      </para>

      <para>
	Доступны множество типов выборок, включая
	<token>icontains</token> (независящий от регистра LIKE),
	<token>startswith</token> и <token>endswith</token>, а также
	<token>range</token> (SQL оператор <token>BETWEEN</token>). В
	приложении <quote><xref linkend="djangobook.appendix_c"
	endterm="djangobook.appendix_c.title"/></quote> подробно
	описаны все типы выборок.
      </para>

    </section>

    <section id="&BASEID;.select.single">

      <title id="&BASEID;.select.single.title">
	Получение одного объекта
      </title>

      <para>
	Иногда требуется получить только один объект. Для этого
	предназначен метод <function>get()</function>:
	<screen>
	  <![CDATA[
>>> Publisher.objects.get(name="Apress Publishing")
<Publisher: Apress Publishing>
	  ]]>
	</screen>
      </para>

      <para>
	Вместо списка (т.е., набора данных) возвращается только один
	объект. По этой причине, запрос ожидающий множество объектов
	вызовет исключение:
	<screen>
	  <![CDATA[
>>> Publisher.objects.get(country="U.S.A.")
Traceback (most recent call last):
    ...
AssertionError: get() returned more than one Publisher -- it returned 2!
	  ]]>
	</screen>
      </para>

      <para>
	Запрос не возвращающий ни одного объекта тоже вызовет
	исключение:
	<screen>
	  <![CDATA[
>>> Publisher.objects.get(name="Penguin")
Traceback (most recent call last):
    ...
DoesNotExist: Publisher matching query does not exist.
	  ]]>
	</screen>
      </para>

    </section>

    <section id="&BASEID;.select.order">

      <title id="&BASEID;.select.order.title">
	Сортировка данных
      </title>

      <para>
	В процессе работы с предыдущими примерами вы могли заметить,
	что объекты возвращаются в случайном порядке. Раз мы не
	указали в каком порядке нам возвращать результат выборки, база
	данных отдаёт его в удобном для себя виде.
      </para>

      <para>
	Очевидно, что это не совсем уместно. Нам не нужна страница,
	которая отображает список издателей в случайном порядке. Таким
	образом, на практике, нам понадобится использовать метод
	<function>order_by()</function> для сортировки полученных
	данных:
	<screen>
	  <![CDATA[
>>> Publisher.objects.order_by("name")
[<Publisher: Addison-Wesley>, <Publisher: Apress Publishing>, <Publisher: O'Reilly>]
	  ]]>
	</screen>
      </para>

      <para>
	Это не сильно отличается от примера с методом
	<function>all()</function>, но SQL представление теперь
	включает в себя оператор сортировки:
	<screen>
	  <![CDATA[
SELECT
    id, name, address, city, state_province, country, website
FROM book_publisher
ORDER BY name;
	  ]]>
	</screen>
      </para>

      <para>
	Мы можем производить сортировку по любому полю:
	<screen>
	  <![CDATA[
>>> Publisher.objects.order_by("address")
[<Publisher: O'Reilly>, <Publisher: Apress Publishing>, <Publisher: Addison-Wesley>]

>>> Publisher.objects.order_by("state_province")
[<Publisher: Apress Publishing>, <Publisher: Addison-Wesley>, <Publisher: O'Reilly>]
	  ]]>
	</screen>
      </para>

      <para>
	и по множеству полей:
	<screen>
	  <![CDATA[
>>> Publisher.objects.order_by("state_province", "address")
 [<Publisher: Apress Publishing>, <Publisher: O'Reilly>, <Publisher: Addison-Wesley>]
	  ]]>
	</screen>
      </para>

      <para>
	Также мы можем указать необходимость выполнять обратную
	сортировку с помощью префикса <token>-</token> для имени поля:
	<screen>
	  <![CDATA[
>>> Publisher.objects.order_by("-name")
[<Publisher: O'Reilly>, <Publisher: Apress Publishing>, <Publisher: Addison-Wesley>]
	  ]]>
	</screen>
      </para>

      <para>
	Несмотря на все возможности, постоянное использование
	<function>order_by()</function> может надоесть. Чаще всего
	сортировку надо производить по жёстко определённому полю. В
	этих случаях Django позволяет указать стандартную сортировку
	для модели:
	<screen>
	  <![CDATA[
class Publisher(models.Model):
    name = models.CharField(max_length=30)
    address = models.CharField(max_length=50)
    city = models.CharField(max_length=60)
    state_province = models.CharField(max_length=30)
    country = models.CharField(max_length=50)
    website = models.URLField()

    def __unicode__(self):
        return self.name

    class Meta:
        ordering = ["name"]
	  ]]>
	</screen>
      </para>

      <para>
	Строка <token>ordering = ["name"]</token> указывает Django по
	какому полю следует производить сортировку пока явно не
	определено иное с помощью метода
	<function>order_by()</function>.
      </para>

      <para>
	<note>
	  <title>
	    Что это за Meta?
	  </title>

	  <para>
	    Django использует внутренний класс
	    <classname>Meta</classname> для определения дополнительных
	    метаданных для модели. Это необязательная возможность, но
	    она иногда может быть полезной. Обратитесь к приложению
	    <quote><xref linkend="djangobook.appendix_b"
	    endterm="djangobook.appendix_b.title"/></quote> за
	    подробностями.
	  </para>
	</note>
      </para>
    </section>

    <section id="&BASEID;.select.chain">

      <title id="&BASEID;.select.chain.title">
	Формирование цепочки запросов
      </title>

      <para>
	Вы знаете как фильтровать данные и как их сортировать. Вы
	желаете узнать как это делать одновременно? Для этого следует
	<quote>сцепить</quote> операторы вместе:
	<screen>
	  <![CDATA[
>>> Publisher.objects.filter(country="U.S.A.").order_by("-name")
[<Publisher: O'Reilly>, <Publisher: Apress Publishing>, <Publisher: Addison-Wesley>]
	  ]]>
	</screen>
      </para>

      <para>
	Как вы можете предполагать, в SQL представлении это будет
	выглядеть так:
	<screen>
	  <![CDATA[
SELECT
    id, name, address, city, state_province, country, website
FROM book_publisher
WHERE country = 'U.S.A'
ORDER BY name DESC;
	  ]]>
	</screen>
      </para>

      <para>
	Количество таких цепочек никак не ограничено.
      </para>

    </section>
    
    <section id="&BASEID;.select.slice">

      <title id="&BASEID;.select.slice.title">
	Выборка части результатов
      </title>

      <para>
	Часто требуется получить только несколько строк результата
	выборки. Представьте, что в вашей базе находится несколько
	тысяч издателей, но вам надо отобразить только первого. Вы
	можете это осуществить с помощью возможностей стандартного
	списка Python:
	<screen>
	  <![CDATA[
>>> Publisher.objects.all()[0]
<Publisher: Addison-Wesley>
	  ]]>
	</screen>
      </para>

      <para>
	Это преобразуется в:
	<screen>
	  <![CDATA[
SELECT
    id, name, address, city, state_province, country, website
FROM book_publisher
ORDER BY name
LIMIT 1;
	  ]]>
	</screen>
      </para>

      <para>
	<note>
	  <title>
	    А ещё...
	  </title>
	  <para>
	    Мы лишь коснулись задачи работы с моделями, но теперь вы
	    должны знать достаточно для понимания последующих
	    примеров. Когда вы будете готовы к изучению полной
	    информации по работе с моделями, обратитесь к приложению
	    <quote><xref linkend="djangobook.appendix_c"
	    endterm="djangobook.appendix_c.title"/></quote>.
	  </para>
	</note>
      </para>

    </section>

  </section>
  
  <section id="&BASEID;.delete">

    <title id="&BASEID;.delete.title">
      Удаление объектов
    </title>

    <para>
      Для удаления объектов следует использовать метод
      <function>delete()</function>:
      <screen>
	<![CDATA[
>>> p = Publisher.objects.get(name="Addison-Wesley")
>>> p.delete()
>>> Publisher.objects.all()
[<Publisher: Apress Publishing>, <Publisher: O'Reilly>]
	]]>
      </screen>
    </para>

    <para>
      Вы также можете удалять объекты оптом, для этого надо вызвать
      метод <function>delete()</function> для результата запроса:
      <screen>
	<![CDATA[
>>> publishers = Publisher.objects.all()
>>> publishers.delete()
>>> Publisher.objects.all()
[]
	]]>
      </screen>
    </para>

    <para>
      <note>
	<para>
	  Произведённое удаление <emphasis>невозможно
	  откатить</emphasis>, будьте осторожны! В случае реального
	  сайта, хорошей идеей будет вообще не удалять данные, до тех
	  пор пока это не будет необходимо &mdash; реляционные базы
	  данных обычно не поддерживают откат, а восстановление данных
	  из резервной копии будет проблематичным.
	</para>

	<para>
	  Часто достаточно добавить флаг активности к моделям
	  данных. Вы сможете просматривать только
	  <quote>активные</quote> объекты и проще сбрасывать этот флаг
	  вместо реального удаления объекта. В случае ошибочного
	  действия у вас будет возможность вернуть данные.
	</para>
      </note>
    </para>

  </section>

  <section id="&BASEID;.change-schema">

    <title id="&BASEID;.change-schema.title">
      Внесение изменений в схему базы данных
    </title>

    <para>
      Когда мы описывали команду <command>syncdb</command> в этой
      главе, мы отметили, что эта команда создаёт только те таблицы,
      которых ещё нет в базе данных. Она <emphasis>не
      синхронизирует</emphasis> изменения в моделях и не выполняет
      удаление моделей. Если вы изменили или добавили поле в модель,
      или если вы удалили модель, вам потребуется вручную внести эти
      изменения в базу данных. Этот раздел объяснит как это сделать.
    </para>

    <para>
      При работе с изменениями схемы следует помнить особенности
      работы Django API для доступа к базе данных:
      <itemizedlist>
	<listitem>
	  <para>
	    Django будет сильно ругаться, если модель содержит поле,
	    которое ещё не было создано в таблице базы данных. Это
	    приведёт к ошибке при первом обращении к этой таблице
	    (т.е., ошибка произойдёт во время выполнения, не во время
	    компиляции).
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Django <emphasis>не</emphasis> беспокоится о том, что
	    таблица может содержать столбцы, которые не определены в
	    модели.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Django <emphasis>не</emphasis> беспокоится о том, что база
	    данных может содержать таблицу, которая не представлена в
	    виде модели.
	  </para>
	</listitem>
      </itemizedlist>
    </para>

    <para>
      Внесение изменений в схему означает изменение нескольких частей
      проекта &mdash; сначала в коде, а потом в самой базе данных.
    </para>

    <section id="&BASEID;.change-schema.add-field">

      <title id="&BASEID;.change-schema.add-field.title">
	Добавление полей
      </title>

      <para>
	При добавлении поля в таблицу/модель работающего сайта следует
	воспользоваться тем моментом, что Django не обращает внимание
	на поле таблицы, пока оно не определено в модели.
	Следовательно, стратегия такая &mdash; добавляем поле в
	таблицу, затем вносим изменения в модель.
      </para>

      <para>
	Тем не менее, здесь существует проблема курицы и яйца, так
	как, чтобы узнать как должен выглядеть оператор для добавления
	поля, вам потребуется посмотреть на вывод команды
	<command>manage.py sqlall</command>, которая требует наличия
	этого поля в модели. (Следует отметить, что нет
	<emphasis>требования</emphasis> создавать поле с помощью
	предлагаемого Django SQL кода, но по-хорошему это было бы
	правильно.)
      </para>

      <para>
	Решением проблемы курицы и яйца является использование
	отдельной среды разработки, вместо внесения изменений в код
	работающего сервера. (Надеемся, вы
	<emphasis>используете</emphasis> отдельную среду разработки,
	так?)
      </para>

      <para>
	Сначала, выполните это в среде разработки (т.е., не на рабочем
	сервере):
	<orderedlist>
	  <listitem>
	    <para>
	      Добавьте поле в вашу модель.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      Запустите команду <command>manage.py sqlall
	      [ИМЯ_ПРИЛОЖЕНИЯ]</command>, чтобы посмотреть новый
	      оператор <token>CREATE TABLE</token> для модели. Следует
	      посмотреть на определение нового поля.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      Запустите оболочку клиента базы данных (т.е.,
	      <command>psql</command> или <command>mysql</command> или
	      вы можете использовать <command>manage.py
	      dbshell</command>). Выполните оператор <token>ALTER
	      TABLE</token> для добавления нового поля.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      (Необязательный.) Запустите оболочку Python с помощью
	      команды <command>manage.py shell</command> и проверьте,
	      что новое поле добавлено правильно, т.е., импортируйте
	      модель и произведите выборку из таблицы (например,
	      <token>MyModel.objects.all()[:5]</token>).
	    </para>
	  </listitem>
	</orderedlist>
      </para>

      <para>
	Затем выполните на рабочем сервере следующие шаги:
	<orderedlist>
	  <listitem>
	    <para>
	      Запустите оболочку базы данных.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      Выполните оператор <token>ALTER TABLE</token>, который
	      вы использовали в шаге 3 при работе с тестовым сервером.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      Добавьте поле в вашу модель. Если вы используете систему
	      контроля версий и сохранили в ней изменения в коде,
	      сделанные в шаге 1 при работе с тестовым сервером,
	      пришло время внести эти изменения в код, выполняющийся
	      на боевом сервере (например, <command>svn
	      update</command>).
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      Перезапустите веб-сервер для активации изменений.
	    </para>
	  </listitem>
	</orderedlist>
      </para>

      <para>
	Для примера рассмотрим, что произойдёт если мы добавим поле
	<token>num_pages</token> к модели <classname>Book</classname>,
	описанной ранее в этой главе. Сначала мы должны внести
	изменения в модель тестового сервера:
	<screen>
	  <![CDATA[
class Book(models.Model):
    title = models.CharField(max_length=100)
    authors = models.ManyToManyField(Author)
    publisher = models.ForeignKey(Publisher)
    publication_date = models.DateField()
    num_pages = models.IntegerField(blank=True, null=True)

    def __unicode__(self):
        return self.title
	  ]]>
	</screen>
      </para>

      <para>
	Следует отметить, что параметры <token>blank=True</token> и
	<token>null=True</token> разрешают выборку <token>NOT
	NULL</token> значений из поля <token>num_pages</token>.
      </para>

      <para>
	Затем мы выполнили <command>manage.py sqlall books</command>,
	чтобы посмотреть на оператор <token>CREATE TABLE</token>:
	<screen>
	  <![CDATA[
CREATE TABLE "books_book" (
    "id" serial NOT NULL PRIMARY KEY,
    "title" varchar(100) NOT NULL,
    "publisher_id" integer NOT NULL REFERENCES "books_publisher" ("id"),
    "publication_date" date NOT NULL,
    "num_pages" integer NULL
);
	  ]]>
	</screen>
      </para>

      <para>
	Новое поле представлено как:
	<screen>
"num_pages" integer NULL
	</screen>
      </para>

      <para>
	Затем, мы запустили оболочку базы данных на рабочем сервере,
	набрав <command>psql</command> (для PostgreSQL) и выполнили
	следующий оператор:
	<screen>
ALTER TABLE books_book ADD COLUMN num_pages integer;
	</screen>
      </para>

      <para>
	<note>
	  <title>
	    Добавление NOT NULL полей
	  </title>

	  <para>
	    Существует одна тонкость, которую следует упомянуть. При
	    добавлении поля <token>num_pages</token> в модель мы
	    указали параметры <token>blank=True</token> и
	    <token>null=True</token>. Мы сделали это, потому что это
	    поле будет содержать NULL значения при своём создании.
	  </para>

	  <para>
	    Однако, также есть возможность добавлять поля, которые не
	    могут содержать NULL значения. Для этого вам потребуется
	    создать поле, которое может содержать значения
	    <token>NULL</token>, затем добавить несколько значений и
	    после этого изменить тип поля на <token>NOT
	    NULL</token>. Например:
	    <screen>
BEGIN;
ALTER TABLE books_book ADD COLUMN num_pages integer;
UPDATE books_book SET num_pages=0;
ALTER TABLE books_book ALTER COLUMN num_pages SET NOT NULL;
COMMIT;
	    </screen>
	  </para>

	  <para>
	    Если вы пойдёте по этому пути, запомните, что вы должны
	    оставить параметры <token>blank=True</token> и
	    <token>null=True</token> в вашей модели.
	  </para>
	</note>
      </para>

      <para>
	После выполнения оператора <token>ALTER TABLE</token> мы
	проверили, что изменения работают правильно, запустив оболочку
	Python и выполнив код:
	<screen>
	  <![CDATA[
>>> from mysite.books.models import Book
>>> Book.objects.all()[:5]
	  ]]>
	</screen>
      </para>

      <para>
	Если этот код выполнился без ошибок, мы переключаемся на
	рабочий сервер и выполняем оператор <token>ALTER TABLE</token>
	на рабочей базе данных. Затем, мы обновляем модель и
	перезапускаем веб-сервер.
      </para>

    </section>

    <section id="&BASEID;.change-schema.remove-field">

      <title id="&BASEID;.change-schema.remove-field.title">
	Удаление полей
      </title>

      <para>
	Удалять поля из модели гораздо проще, чем добавлять. Для
	удаления поля просто следуйте следующим шагам:
	<orderedlist>
	  <listitem>
	    <para>
	      Удалите поля из вашей модели и перезапустите веб-сервер.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      Удалите поле из таблицы с помощью команды:
	      <screen>
ALTER TABLE books_book DROP COLUMN num_pages;
	      </screen>
	    </para>
	  </listitem>
	</orderedlist>
      </para>
    </section>

    <section id="&BASEID;.change-schema.remove-field-m2m">

      <title id="&BASEID;.change-schema.remove-field-m2m.title">
	Удаление полей со связями многие-ко-многим
      </title>

      <para>
	Так как поля со связями <quote>многие-ко-многим</quote>
	отличаются от обычных полей, процесс их удаления немного
	отличается:
	<orderedlist>
	  <listitem>
	    <para>
	      Удалите поле <token>ManyToManyField</token> из модели и
	      перезапустите веб-сервер.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      Удалите соответствующую таблицу из базы данных:
	      <screen>
DROP TABLE books_books_publishers;
	      </screen>
	    </para>
	  </listitem>
	</orderedlist>
      </para>

    </section>

    <section id="&BASEID;.change-schema.remove-models">

      <title id="&BASEID;.change-schema.remove-models.title">
	Удаление моделей
      </title>

      <para>
	Удаление модели в целом не сложнее удаления поля. Для того,
	чтобы удалить модель, просто следуйте этим шагам:
	<orderedlist>
	  <listitem>
	    <para>
	      Удалите модель из файла <filename>models.py</filename> и
	      перезапустите веб-сервер.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      Удалите таблицу из базы данных с помощью команды:
	      <screen>
DROP TABLE books_book;
	      </screen>
	    </para>
	  </listitem>
	</orderedlist>
      </para>

    </section>

  </section>

  <section id="&BASEID;.models-and-scripts">

    <title id="&BASEID;.models-and-scripts.title">
      Доступ к моделям из стороннего скрипта
    </title>

    <para>
      Однажды я столкнулся с необходимостью переноса и последующей
      синхронизации некоторого количества словарей из большой базы
      данных под управлением Oracle в проект, разработанный с помощью
      Django. Для экспорта данных был написан небольшой скрипт на
      языке Python, который упаковывал данные таблиц и информацию о
      структуре таблиц в Pickle объект. Для импорта данных был написан
      другой скрипт. Чтобы обеспечить его работу с любым типом баз
      данных, которые поддерживаются Django было принято решение
      воспользоваться стандартным Django DB API.
    </para>

    <para>
      Первым делом следует обеспечить установку переменных окружения
      перед выполнением скрипта импорта. Переменная
      <varname>PYTHONPATH</varname> должна указывать на каталог
      <emphasis>в котором находится каталог нашего проекта</emphasis>, т.е., если
      проект располагается в каталоге
      <filename>~/development/djangobook</filename>, то переменная
      должна содержать <token>~/development</token>. Переменная
      <varname>DJANGO_SETTINGS_MODULE</varname> должна указывать на
      модуль (файл) с настройками доступа к базе данных, в моём случае
      это будет <token>djangobook.settings</token>.
    </para>

    <para>
      Первым делом в скрипте следует выполнить импортирование моделей:
      <screen>
	<![CDATA[
import django
from arm.invite.models import Dictionary, DictionaryType
	]]>
      </screen>
    </para>

    <para>
      Дальше всё проще. Предположим, что вы уже загрузили данные в
      словарь и теперь будете замещать данные в сводной таблице:
      <screen>
	<![CDATA[
for k in dicts.keys():
    print "Processing %s...', % k,
    c = dicts[k].get('columns')
    d = dicts[k].get('data')
    # тут проверка данных
    try:
        index_cod = c.index('COD')
        index_text = c.index('TEXT')
    except:
        print ' failed [wrong structure].'
        continue
    # получаем объект - словарный тип
    try:
        t = DictionaryType.objects.get(title=k.lower())
    except:
        # если не нашли, то что-нибудь делаем
    # удаляем старые записи
    Dictionary.objects.filter(slvcode=t).delete()
    # заливаем новые
    for i in dicts[k].get('data'):
        try:
            r = Dictionary(slvcode=t, code=i[index_cod], text=i[index_text])
	    r.save()
        except:
	    pass
    print ' done.'
	]]>
      </screen>
    </para>

  </section>

</chapter>
