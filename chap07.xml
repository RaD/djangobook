<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
"http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd"
[
<!ENTITY BASEID "djangobook.chap07">
]>

<chapter lang="ru" id="&BASEID;">

  <title id="&BASEID;.title">
    Обработка форм
  </title>

  <para>
    Перевод &copy; Попов Руслан &lt;radz &bull; yandex &bull; ru&gt;
  </para>

  <para>
    После прочтения предыдущей главы вы должны иметь всё необходимое
    для создания какого-нибудь простого сайта. В этой главе мы будем
    взаимодействовать со следующей частью головоломки &mdash; создание
    представлений, которые принимают данные от пользователя.
  </para>

  <para>
    Мы начнём с создания <quote>вручную</quote> простой поисковой
    формы и посмотрим как обрабатывать данные переданные через
    браузер. С этой точки мы начинаем использовать средства обработки
    форм Django.
  </para>

  <section id="&BASEID;.search">

    <title id="&BASEID;.search.title">
      Поиск
    </title>

    <para>
      В интернет всё крутится вокруг поиска. Две больших успешных
      истории в сети, Google и Yahoo, построили свои многомиллиардные
      бизнесы на поиске. Почти каждый сайт получает большой процент
      трафика через свои поисковые страницы. Часто разница между
      успехом и неудачей сайта лежит в качестве его поисковых
      возможностей. Похоже нам понадобится добавить возможность поиска
      к нашему сайту с книгами, не так ли?
    </para>

    <para>
      Мы начнём с добавления поискового представления в наш файл
      привязок (<token>mysite.urls</token>). Помните, это означает,
      что надо добавить, что-то подобное <token>(r'^search/$',
      'mysite.books.views.search')</token> в набор шаблонов URL.
    </para>

    <para>
      Затем, мы создадим это поисковое представление,
      <token>search</token>, в нашем модуле представлений
      (<token>mysite.books.views</token>):
      <screen>
from django.db.models import Q
from django.shortcuts import render_to_response
from models import Book

def search(request):
    query = request.GET.get('q', '')
    if query:
        qset = (
            Q(title__icontains=query) |
            Q(authors__first_name__icontains=query) |
            Q(authors__last_name__icontains=query)
        )
        results = Book.objects.filter(qset).distinct()
    else:
        results = []
    return render_to_response("books/search.html", {
        "results": results,
        "query": query
    })
      </screen>
    </para>

    <para>
      Здесь приведены несколько вещей, которые вы ещё не
      видели. Во-первых, здесь есть <token>request.GET</token>. Так вы
      получаете данные, переданные через GET запрос, от
      Django. Данные, передаваемые POST запросом, передаются
      аналогично &mdash; <token>request.POST</token>. Эти объекты
      ведут себя точно так же как обычный словарь Python с некоторыми
      дополнительными возможностями, которые описаны в приложении
      <quote><xref linkend="djangobook.appendix_h"
      endterm="djangobook.appendix_h.title"/></quote>.
    </para>

    <para>
      <note>
	<title>
	  Что такое GET и POST?
	</title>
	<para>
	  GET и POST являются методами с помощью которых браузер
	  передаёт данные на сервер. Чаще всего они упоминаются при
	  определении форм:
	  <screen>
	    <![CDATA[
<form action="/books/search/" method="get">
	    ]]>
	  </screen>
	</para>

	<para>
	  Этот тэг указывает браузеру, что данные надо переслать по
	  URL <token>/books/search/</token> с помощью метода GET.
	</para>

	<para>
	  Существуют важные различия между семантиками GET и POST,
	  которые мы сейчас не рассмотрим. Но если вам хочется узнать
	  больше, перейдите на <ulink
	  url="http://www.w3.org/2001/tag/doc/whenToUseGet.html"/>.
	</para>
      </note>
    </para>

    <para>
      Таким образом, строка:
      <screen>
query = request.GET.get('q', '')
      </screen>
      ожидает GET параметр по имени <token>q</token> и возвращает
      пустую строку, если такой параметр не был передан.
    </para>

    <para>
      Следует отметить, что мы используем метод
      <function>get()</function> объекта
      <classname>request.GET</classname>, что потенциально может
      запутать неопытных разработчиков. Метод
      <function>get()</function> является методом, который существует
      в каждом словаре Python. Мы используем его для безопасности:
      <emphasis>опасно</emphasis> предполагать, что
      <classname>request.GET</classname> всегда имеет параметр
      <token>q</token>, поэтому мы использовали <token>get('q',
      '')</token> для обеспечения функциональности в случае отсутствия
      этого параметра. Если же мы просто используем
      <token>request.GET['q']</token>, такой код может вызвать ошибку
      <token>KeyError</token> при отсутствии параметра
      <token>q</token> в GET запросе.
    </para>

    <para>
      Во-вторых, что делает <token>Q</token>? Объекты <token>Q</token>
      используются для построения сложных запросов &mdash; в данном
      случае, мы производим поиск любой книги, у которой название или
      имя одного из авторов совпадает с поисковым запросом. С
      технической стороны, эти объекты <token>Q</token> содержат
      <token>QuerySet</token> и вы можете узнать о них больше в
      приложении <quote><xref linkend="djangobook.appendix_c"
      endterm="djangobook.appendix_c.title"/></quote>.
    </para>

    <para>
      В этих запросах используется <token>icontains</token> &mdash;
      нечувствительный к регистру поиск, который применяет SQL
      оператор <token>LIKE</token> в используемой базе данных.
    </para>

    <para>
      По причине того, что мы производим поиск по полю
      многие-ко-многим, существует возможность многократного отражения
      в результате одной и той же книги (т.е. книга с двумя авторами,
      имена у которых оба совпадают с поисковым запросом). С помощью
      добавления <token>.distinct()</token> в фильтр мы ограничиваем
      результаты только уникальными значениями.
    </para>

    <para>
      Несмотря на всё это, у нас до сих пор нет шаблона для поискового
      представления. Сделаем так:
      <screen>
	<![CDATA[
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html lang="en">
<head>
    <title>Search{% if query %} Results{% endif %}</title>
</head>
<body>
  <h1>Search</h1>
  <form action="." method="GET">
    <label for="q">Search: </label>
    <input type="text" name="q" value="{{ query|escape }}">
    <input type="submit" value="Search">
  </form>

  {% if query %}
    <h2>Results for "{{ query|escape }}":</h2>

    {% if results %}
      <ul>
      {% for book in results %}
        <li>{{ book|escape }}</li>
      {% endfor %}
      </ul>
    {% else %}
      <p>No books found</p>
    {% endif %}
  {% endif %}
</body>
</html>
	]]>
      </screen>
    </para>

    <para>
      Хочется надеяться на то, что сейчас всё достаточно
      очевидно. Однако, есть несколько тонкостей, которые следует
      отметить:
      <itemizedlist>
	<listitem>
	  <para>
	    Действием формы является <token>.</token> (точка), что
	    означает <quote>текущий URL</quote>. Это стандартная
	    проверенная практика: не используйте раздельные
	    представления для страницы с формой и для страницы с
	    результатом. Используйте для этого одну, которая
	    обрабатывает форму и результаты.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Мы повторно вставляем значение запроса обратно в тэг
	    <![CDATA[<input>]]>. Это позволит пользователям легко
	    изменять их запросы без необходимости каждый раз печатать
	    всё сначала.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Везде где используются <token>query</token> и
	    <token>book</token>, мы передаём их через фильтр
	    <token>escape</token>, чтобы потенциально опасный
	    поисковый текст отфильтровывался перед вставкой в
	    страницу.
	  </para>

	  <para>
	    <emphasis>Крайне необходимо</emphasis>, чтобы вы делали
	    тоже самое с данными, которые ввёл пользователь! В
	    противном случае, вы открываете ваш сайт для XSS атак
	    (cross-site scripting). Глава <quote><xref
	    linkend="djangobook.chap19"
	    endterm="djangobook.chap19.title"/></quote> описывает XSS
	    и безопасность более подробно.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Однако, нам не следует беспокоиться о вредной информации,
	    которая может быть передана в вашу базу данных. Слой
	    Django для работы с базами данных самостоятельно
	    отслеживает аспект безопасности для вас.
	  </para>
	</listitem>
      </itemizedlist>
    </para>

    <para>
      Теперь у нас есть работающий поиск. Следующим улучшением будет
      помещение поисковой формы на каждую страницу (т.е. в основной
      шаблон) сайта. Мы позволим сделать вам это самостоятельно.
    </para>

    <para>
      Затем, мы рассмотрим более сложный пример. Но перед этим,
      давайте обсудим более абстрактную тему: <quote>идеальная
      форма</quote>.
    </para>

  </section>

  <section id="&BASEID;.perfectform">

    <title id="&BASEID;.perfectform.title">
      Идеальная форма
    </title>

    <para>
      Формы чаще всего могут быть причиной разочарования пользователей
      вашего сайта. Давайте рассмотрим поведение гипотетической
      идеальной формы:
      <itemizedlist>
	<listitem>
	  <para>
	    Форма должна запрашивать некую информацию у
	    пользователя. Это очевидно. Доступность и удобность здесь
	    имеют значение. Здесь имеет особое значение полезная
	    контекстная помощь и разумное использование HTML тэга
	    <![CDATA[<label>]]>.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Передаваемые данные должны интенсивно проверяться. Золотое
	    правило безопасности веб-приложений &mdash; <quote>никогда
	    не доверять входящим данным</quote>.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Если пользователь сделает любую ошибку, форма должна
	    отобразиться снова с подробным, информативным отчётом об
	    ошибке. Ранее введённые данные должны быть уже введены в
	    форму, это сохранит время пользователю.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Форма должна отображаться снова и снова, пока все данные
	    не будут введены верно.
	  </para>
	</listitem>
      </itemizedlist>
    </para>

    <para>
      Создание идеальной формы кажется серьёзной работой! К счастью,
      средство Django для работы с формами разработано для выполнения
      большей части этой работы за вас. Вы предоставляете описание
      полей формы, правил проверки и простой шаблон, а Django делает
      всё остальное. Результатом является <quote>идеальная
      форма</quote> с небольшим приложением усилий.
    </para>

  </section>

  <section id="&BASEID;.feedbackform">

    <title id="&BASEID;.feedbackform.title">
      Создание формы для отзывов
    </title>

    <para>
      Лучший способ создания сайта, который люди будут обожать &mdash;
      прислушиваться к их отзывам. Многие сайты производят впечатление
      того, что они забыли об этом. Они прячут свою контактную
      информацию под уровнем ЧаВо и кажется, что они сделаны насколько
      возможно запутанными, чтобы трудно было найти контакт человека.
    </para>

    <para>
      Когда вашим сайтом пользуются миллионы людей, это может быть
      приемлемой стратегией. В случае, когда вы пытаетесь создать
      аудиторию, вам надо прислушиваться к отзывам при каждой
      возможности. Давайте создадим простую форму для отзывов и
      используем для этого средства Django.
    </para>

    <para>
      Мы начнём с добавления <token>(r'^contact/$',
      'mysite.books.views.contact')</token> в файл привязок URL. Затем
      определим нашу форму. Формы в Django создаются способом
      аналогичным случаю с моделями: декларативно, с использованием
      класса Python. Ниже представлен класс для нашей простой
      формы. Для удобства, мы вставим его в новый файл
      <filename>forms.py</filename> в каталоге нашего приложения:
      <screen>
from django import forms

TOPIC_CHOICES = (
    ('general', 'General enquiry'),
    ('bug', 'Bug report'),
    ('suggestion', 'Suggestion'),
)

class ContactForm(forms.Form):
    topic = forms.ChoiceField(choices=TOPIC_CHOICES)
    message = forms.CharField()
    sender = forms.EmailField(required=False)
      </screen>
    </para>

    <para>
      <note>
	<title>
	  <quote>Новые</quote> формы? Зачем?
	</title>

	<para>
	  <note>
	    <title>
	      newforms теперь стало forms
	    </title>

	    <para>
	      Надо заставить себя изменить данный раздел в
	      соответствии с реальным положением дел.
	    </para>
	  </note>
	</para>

	<para>
	  Когда Django был впервые выпущен в свет, он имел сложную
	  запутанную систему работы с формами. Она делала работу с
	  формами слишком сложно, поэтому была полностью переписана и
	  теперь называется <quote>newforms</quote>. Однако, пока ещё
	  существует весьма значительная часть кода, которая зависит
	  от <quote>старой</quote> системы форм, так что в настоящее
	  время с Django поставляется два вида пакетов.
	</para>

	<para>
	  На время написания книги старая система форм была доступна
	  через пакет <token>django.forms</token>, а новая &mdash;
	  через пакет <token>django.newforms</token>. Через какое-то
	  время <token>django.forms</token> будет указывать на пакет с
	  новой системой для работы с формами. Тем не менее, все
	  примеры в книге будут ссылаться на
	  <token>django.newforms</token>.
	</para>
      </note>
    </para>

    <para>
      Форма в Django является подклассом
      <classname>django.newforms</classname>. Форма, так же как и
      модель Django, является подклассом
      <classname>django.db.models.Model</classname>. Модуль
      <token>django.newforms</token> также содержит ряд классов
      <classname>Field</classname>. Полный список доступен на <ulink
      url="http://www.djangoproject.com/documentation/0.96/newforms/">странице
      документации</ulink>.
    </para>

    <para>
      Наша форма <token>ContactForm</token> содержит три поля:
      заголовок, который выбирается из трёх вариантов; сообщение,
      которое является полем ввода символов; и отправитель, который
      является полем для адреса электронной почтой, это поле
      необязательно (т.к. анонимные отзывы могут быть
      полезны). Существуют ряд других типов полей и вы можете создать
      собственный тип, если функциональности существующих не хватает.
    </para>

    <para>
      Сам объект формы знает как выполнить ряд полезных действий. Он
      может проверять коллекции данных, он может генерировать свои
      HTML <quote>отображения</quote>, он может сконструировать набор
      полезных сообщений об ошибках и, если нас одолела лень, он может
      даже отрисовать целую форму для нас. Давайте присоединим его к
      представлению и посмотрим на него в действии. В
      <filename>views.py</filename> будет это:
      <screen>
from django.db.models import Q
from django.shortcuts import render_to_response
from models import Book
from forms import ContactForm

def search(request):
    query = request.GET.get('q', '')
    if query:
        qset = (
            Q(title__icontains=query) |
            Q(authors__first_name__icontains=query) |
            Q(authors__last_name__icontains=query)
        )
        results = Book.objects.filter(qset).distinct()
    else:
        results = []
    return render_to_response("books/search.html", {
        "results": results,
        "query": query
    })

def contact(request):
    form = ContactForm()
    return render_to_response('contact.html', {'form': form})
      </screen>
    </para>

    <para>
      а это в <filename>contact.html</filename>:
      <screen>
	<![CDATA[
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html lang="en">
<head>
    <title>Contact us</title>
</head>
<body>
    <h1>Contact us</h1>
    <form action="." method="POST">
        <table>
            {{ form.as_table }}
        </table>
        <p><input type="submit" value="Submit"></p>
    </form>
</body>
</html>
	]]>
      </screen>
    </para>

    <para>
      Наиболее интересная здесь строка &mdash; <token>{{ form.as_table
      }}</token>. Объект <token>form</token> является экземпляром
      нашего класса <classname>ContactForm</classname> и передаётся в
      <function>render_to_response</function>. Метод
      <token>as_table</token> является методом этого объекта, который
      отображает форму в виде последовательности рядов таблицы (также
      можно использовать <token>as_ul</token> и
      <token>as_p</token>). Сгенерированный HTML выглядит так:
      <screen>
	<![CDATA[
<tr>
    <th><label for="id_topic">Topic:</label></th>
    <td>
        <select name="topic" id="id_topic">
            <option value="general">General enquiry</option>
            <option value="bug">Bug report</option>
            <option value="suggestion">Suggestion</option>
        </select>
    </td>
</tr>
<tr>
    <th><label for="id_message">Message:</label></th>
    <td><input type="text" name="message" id="id_message" /></td>
</tr>
<tr>
    <th><label for="id_sender">Sender:</label></th>
    <td><input type="text" name="sender" id="id_sender" /></td>
</tr>
	]]>
      </screen>
    </para>

    <para>
      Следует отметить, что тэги <![CDATA[<table>]]> и
      <![CDATA[<form>]]> не включены. Вам следует определить их в
      шаблоне самостоятельно, что даёт вам контроль над поведением
      формы при её отправке. Метки <emphasis>включены</emphasis>, они
      позволяют получать доступ к элементам формы.
    </para>

    <para>
      Наша форма сейчас использует элемент <![CDATA[<input
      type="text">]]> для текстового поля. Мы не желаем ограничивать
      наших пользователей одной строкой текста, так что заменим этот
      тэг на &lt;textarea&gt;:
      <screen>
class ContactForm(forms.Form):
    topic = forms.ChoiceField(choices=TOPIC_CHOICES)
    message = forms.CharField(widget=forms.Textarea())
    sender = forms.EmailField(required=False)
      </screen>
    </para>

    <para>
      Система для работы с формами выделяет презентационную логику
      каждого поля в набор виджетов. Каждый тип поля имеет стандартный
      виджет, но его можно легко переопределять или назначать
      созданный вами виджет.
    </para>

    <para>
      В это время, передача формы ничего не делает. Давайте привяжем к
      ней наши правила проверки данных:
      <screen>
def contact(request):
    if request.method == 'POST':
        form = ContactForm(request.POST)
    else:
        form = ContactForm()
    return render_to_response('contact.html', {'form': form})
      </screen>
    </para>

    <para>
      Экземпляр формы может находиться в одном из двух состояний:
      связанное и несвязанное. <emphasis>Связанный</emphasis>
      экземпляр создаётся со словарём (или похожим на него объектом) и
      он знает как проверять и заново отображать данные из
      него. <emphasis>Несвязанная</emphasis> форма не имеет
      ассоциированных с собой данных и просто знает как отображать
      себя.
    </para>

    <para>
      Попробуйте щёлкнуть на <guibutton>Submit</guibutton> на пустой
      форме. Страница должна отобразиться заново, показав ошибку
      проверки, которая информирует нас, что требуется заполнить поле
      сообщения.
    </para>

    <para>
      Попробуйте ввести неверный адрес электронной
      почты. <token>EmailField</token> знает как проверять
      правильность адреса электронной почты, как минимум на
      достаточном уровне.
    </para>

    <para>
      <note>
	<title>
	  Установка начальных данных
	</title>

	<para>
	  Передавая данные напрямую конструктору формы, привязывает
	  эти данные и указывает, что необходимо осуществлять проверку
	  пользовательского ввода. Хотя, часто нам требуется
	  отображать форму, у которой некоторые поля уже заполнены
	  &mdash; например, форму редактирования. Мы можем реализовать
	  это с помощью ключевого слова <token>initial</token>:
	  <screen>
form = CommentForm(initial={'sender': 'user@example.com'})
	  </screen>
	</para>

	<para>
	  Если наша форма будет <emphasis>всегда</emphasis>
	  использовать одни и те же значения по умолчанию, мы можем
	  указать их в определении формы:
	  <screen>
message = forms.CharField(widget=forms.Textarea(),
                          initial="Replace with your feedback")
	  </screen>
	</para>
      </note>
    </para>

  </section>

  <section id="&BASEID;.submit">

    <title id="&BASEID;.submit.title">
      Обработка данных
    </title>

    <para>
      Как только пользователь заполнил форму, она передаётся на
      проверку по нашим правилам, здесь мы должны сделать что-то
      полезное с данными. В этом случае, мы желаем создать и отправить
      электронное сообщение содержащее отзыв пользователя. Мы будем
      использовать пакет Django для работы с электронной почтой.
    </para>

    <para>
      Во-первых, нам необходимо знать, что данные верны и нам нужен
      доступ к проверенным данным. Система для работы с формами
      выполняет больше работы, чем просто проверка данных, она
      преобразовывает данные в типы языка Python. Наша форма работает
      только со строками, но если бы мы использовали
      <token>IntegerField</token> или <token>DateTimeField</token>,
      система бы обеспечила конвертацию типа в целое или объект
      <classname>datetime</classname>, соответственно.
    </para>

    <para>
      Для того, чтобы узнать связана ли форма с проверенными данными,
      используйте метод <function>is_valid()</function>:
      <screen>
form = ContactForm(request.POST)
if form.is_valid():
    # Process form data
      </screen>
    </para>

    <para>
      Теперь нам нужен доступ к данным. Мы можем получить их напрямую
      из <token>request.POST</token>. Но в этом случае мы пропустим
      этап преобразования данных, который выполняется системой. Вместо
      этого, мы используем <function>form.cleaned_data</function>:
      <screen>
if form.is_valid():
    topic = form.cleaned_data['topic']
    message = form.cleaned_data['message']
    sender = form.cleaned_data.get('sender', 'noreply@example.com')
    # ...
      </screen>
    </para>


    <para>
      Следует отметить, что раз <token>sender</token> не является
      обязательным, мы предоставляем значение по умолчанию в случае,
      если параметр ничего не содержит. Наконец, нам надо записать
      отзыв пользователя. Самым простым способом записи является
      отправка его через электронную почту администратору сайта. Мы
      можем осуществить это с помощью функции
      <function>send_mail</function>:
      <screen>
from django.core.mail import send_mail

# ...

send_mail(
    'Feedback from your site, topic: %s' % topic,
    message, sender,
    ['administrator@example.com']
)
      </screen>
    </para>

    <para>
      Функция <function>send_mail</function> имеет четыре обязательных
      параметра: заголовок сообщения, тело сообщения, адрес
      <quote>from</quote> и список получателей. Эта функция является
      удобной заменой для класса Django
      <classname>EmailMessage</classname>, который предоставляет
      расширенные возможности, такие как поддержка вложений, multipart
      (предложенный вариант <quote>составные</quote> мне не нравится)
      сообщения и полный контроль над заголовками сообщения.
    </para>

    <para>
      После отправки отзыва по электронной почте мы перенаправляем
      нашего пользователя на статическую страницу с подтверждением
      обработки его сообщения. Окончательно функция представления
      выглядит так:
      <screen>
from django.http import HttpResponseRedirect
from django.shortcuts import render_to_response
from django.core.mail import send_mail
from forms import ContactForm

def contact(request):
    if request.method == 'POST':
        form = ContactForm(request.POST)
        if form.is_valid():
            topic = form.cleaned_data['topic']
            message = form.cleaned_data['message']
            sender = form.cleaned_data.get('sender', 'noreply@example.com')
            send_mail(
                'Feedback from your site, topic: %s' % topic,
                message, sender,
                ['administrator@example.com']
            )
            return HttpResponseRedirect('/contact/thanks/')
    else:
        form = ContactForm()
    return render_to_response('contact.html', {'form': form})
      </screen>
    </para>

    <para>
      <note>
	<title>
	  Перенаправление после POST запроса
	</title>

	<para>
	  Если пользователь попробует обновить страницу, которая была
	  отображена в результате POST запроса, этот запрос будет
	  выполнен снова. Это часто приводит к нежелаемому поведению
	  сайта, такому как дублирование записей, которые добавляются
	  в базу данных. Перенаправление после POST запроса является
	  полезным шаблоном, который помогает избежать таких
	  проблем. После успешной обработки POST запроса,
	  перенаправьте пользователя на другую страницу, которая
	  возвращает обычный HTML.
	</para>
      </note>
    </para>

  </section>

  <section id="&BASEID;.rules">

    <title id="&BASEID;.rules.title">
      Свои правила для проверки данных
    </title>

    <para>
      Представим, что мы запустили в работу нашу форму для отзывов и к
      нам пошёл поток электронных сообщений. Но есть одна проблема:
      некоторое из этих сообщений содержат всего одно-два слова и не
      несут смысловой нагрузки. Мы решаем поправить наше правило:
      четыре слова или больше, пожалуйста.
    </para>

    <para>
      Существует ряд способов для подключения своей проверки в форму
      Django. Если мы будем использовать такую проверку часто, то
      рекомендуется создать свой тип поля. Хотя большинство
      пользовательских проверок можно реализовывать прямо в классе
      формы.
    </para>

    <para>
      Нам нужна дополнительная проверка поля <token>message</token>,
      значит нам следует добавить метод
      <function>clean_message</function> в нашу форму:
      <screen>
	<![CDATA[
class ContactForm(forms.Form):
    topic = forms.ChoiceField(choices=TOPIC_CHOICES)
    message = forms.CharField(widget=forms.Textarea())
    sender = forms.EmailField(required=False)

    def clean_message(self):
        message = self.cleaned_data.get('message', '')
        num_words = len(message.split())
        if num_words < 4:
            raise forms.ValidationError("Not enough words!")
        return message
	]]>
      </screen>
    </para>

    <para>
      Этот новый метод будет вызываться после стандартной проверки (в
      этом случае, после проверки для типа
      <token>CharField</token>). Так как данные поля уже были частично
      проверены, мы должны брать это поле из словаря формы
      <token>cleaned_data</token>.
    </para>

    <para>
      Мы наивно используем комбинацию <function>len()</function> и
      <function>split()</function> для подсчёта количества слов. Если
      пользователь введёт слишком мало слов, мы получим исключение
      <token>ValidationError</token>. Строка, передаваемая с этим
      исключением, будет отображена пользователю в виде элемента
      списка ошибок.
    </para>

    <para>
      Очень важно то, что мы явно возвращаем значение поля в конце
      метода. Это позволяет нам изменять значение (или преобразовывать
      его в различные типы языка Python) внутри нашего метода
      проверки. Если мы забудем оператор <token>return</token>, тогда
      будет возвращено <token>None</token> и оригинальное значение
      будет потеряно.
    </para>

  </section>

  <section id="&BASEID;.look-n-feel">

    <title id="&BASEID;.look-n-feel.title">
      Настройка вида формы
    </title>

    <para>
      Самым быстрым способом настройки внешнего вида формы является
      CSS. В частности, отображение перечня ошибок можно улучшить, тэг
      &lt;ul&gt; имеет атрибут класса <token>errorlist</token> для
      этой цели. Следующий CSS выделяет наши ошибки:
      <screen>
	<![CDATA[
<style type="text/css">
    ul.errorlist {
        margin: 0;
        padding: 0;
    }
    .errorlist li {
        background-color: red;
        color: white;
        display: block;
        font-size: 10px;
        margin: 0 0 3px;
        padding: 4px 5px;
    }
</style>
	]]>
      </screen>
    </para>

    <para>
      Несмотря на то, что удобно получать сгенерированный HTML для
      нашей формы, во многих случаях стандартная генерация не подойдёт
      для нашего приложения. Элементы <token>{{ form.as_table
      }}</token> и другие являются полезными сокращениями во время
      разработки нашего приложения, но все остальные аспекты
      отображения формы могут быть изменены, в основном в рамках этого
      шаблона.
    </para>

    <para>
      Виджет для каждого поля (<token>&lt;input
      type="text"&gt;</token>, <token>&lt;select&gt;</token>,
      <token>&lt;textarea&gt;</token> и другие) могут быть отображены
      отдельно через <token>{{ form.fieldname }}</token>. Любые
      ошибки, относящиеся к полям, доступны через <token>{{
      form.fieldname.errors }}</token>. Мы можем использовать эти
      переменные формы для построения своего шаблона для нашей
      контактной формы:
      <screen>
	<![CDATA[
<form action="." method="POST">
    <div class="fieldWrapper">
        {{ form.topic.errors }}
        <label for="id_topic">Kind of feedback:</label>
        {{ form.topic }}
    </div>
    <div class="fieldWrapper">
        {{ form.message.errors }}
        <label for="id_message">Your message:</label>
        {{ form.message }}
    </div>
    <div class="fieldWrapper">
        {{ form.sender.errors }}
        <label for="id_sender">Your email (optional):</label>
        {{ form.sender }}
    </div>
    <p><input type="submit" value="Submit"></p>
</form>
	]]>
      </screen>
    </para>

    <para>
      Элемент <token>{{ form.message.errors }}</token> отобразится как
      <token>&lt;ul class="errorlist"&gt;</token> при наличии ошибок и
      как пустая строка (если поле проверено нормально или если форма
      не связана). Мы также можем рассматривать
      <token>form.message.errors</token> в качестве булевого значения
      или даже итеративно обработать его как список, например:
      <screen>
	<![CDATA[
<div class="fieldWrapper{% if form.message.errors %} errors{% endif %}">
    {% if form.message.errors %}
        <ol>
        {% for error in form.message.errors %}
            <li><strong>{{ error|escape }}</strong></li>
        {% endfor %}
        </ol>
    {% endif %}
    {{ form.message }}
</div>
	]]>
      </screen>
    </para>

    <para>
      При наличии ошибок проверки, этот код добавит класс
      <quote>errors</quote> к &lt;div&gt; и отобразить список ошибок в
      виде нумерованного списка.
    </para>

  </section>

  <section id="&BASEID;.create">

    <title id="&BASEID;.create.title">
      Создание формы по модели
    </title>

    <para>
      Давайте создадим что-нибудь поинтереснее: форму, которая
      передаёт информацию о новом издателе в наше приложение из главы
      <quote><xref linkend="djangobook.chap05"
      endterm="djangobook.chap05.title"/></quote>.
    </para>

    <para>
      Не повторяйся (Don't Repeat YourSelf, DRY) &mdash; этому правилу
      разработки программного обеспечения старается следовать
      Django. Andy Hurt и Dave Thomas в <emphasis>The Pragmatic
      Programmer</emphasis> сделали такое определение:
      <screen>
Каждый элемент информации должен иметь единое, недвусмысленное, 
достоверное представление внутри системы.
      </screen>
    </para>

    <para>
      Наш класс модели <classname>Publisher</classname> определяет,
      что издатель имеет имя, адрес, город, область, страну и веб
      сайт.  Дублирование этой информации в определении формы нарушит
      правило DRY. Мы можем использовать полезное сокращение:
      <function>form_for_model()</function>:
      <screen>
from models import Publisher
from django.newforms import form_for_model

PublisherForm = form_for_model(Publisher)
      </screen>
    </para>

    <para>
      Класс <classname>PublisherForm</classname> является потомком
      класса <classname>Form</classname>, аналогично классу
      <classname>ContactForm</classname>, который мы создали вручную
      ранее. Мы можем использовать его аналогичным образом:
      <screen>
from forms import PublisherForm

def add_publisher(request):
    if request.method == 'POST':
        form = PublisherForm(request.POST)
        if form.is_valid():
            form.save()
            return HttpResponseRedirect('/add_publisher/thanks/')
    else:
        form = PublisherForm()
    return render_to_response('books/add_publisher.html', {'form': form})
      </screen>
    </para>

    <para>
      Файл <filename>add_publisher.html</filename> практически
      совпадает с нашим оригинальным шаблоном
      <filename>contact.html</filename>, так что его можно
      исключить. Также не забудьте добавить новый шаблон в файл
      привязок URL &mdash; <token>(r'^add_publisher/$',
      'mysite.books.views.add_publisher')</token>.
    </para>

    <para>
      Здесь было продемонстрировано ещё одно сокращение. Так как
      созданные по модели формы часто используются для сохранения
      новых экземпляров модели в базе данных, класс формы, созданный с
      помощью <function>form_for_model()</function>, включает в себя
      удобный метод <function>save()</function>. Это касается общего
      случая: вы можете игнорировать этот метод, если вы желаете
      разнообразить обработку передаваемых данных.
    </para>

    <para>
      Метод <function>form_for_instance()</function> является методом,
      который может создать предварительно заполненную форму по
      экземпляру класса модели. Это удобно для создания форм
      редактирования.
    </para>

  </section>

</chapter>
